"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/page",{

/***/ "(app-pages-browser)/./src/store/gameStore.ts":
/*!********************************!*\
  !*** ./src/store/gameStore.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameStore: () => (/* binding */ useGameStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n// src/store/gameStore.ts\n\n\n\n\n\n// Helper to get today's date as ISO string for consistency\nconst getTodayDateString = ()=>{\n    // Use consistent ISO format for all dates\n    return new Date().toISOString();\n};\n// Helper to check if two dates are consecutive days\nconst isConsecutiveDay = (previousDate, currentDate)=>{\n    if (!previousDate) return false;\n    // Parse dates (using Date constructor with YYYY-MM-DD format)\n    const prev = new Date(previousDate);\n    const curr = new Date(currentDate);\n    // Set to same time to compare just the dates\n    prev.setHours(0, 0, 0, 0);\n    curr.setHours(0, 0, 0, 0);\n    // Calculate difference in days\n    const timeDiff = curr.getTime() - prev.getTime();\n    const daysDiff = timeDiff / (1000 * 3600 * 24);\n    // Return true if the dates are exactly 1 day apart\n    return Math.round(daysDiff) === 1;\n};\n// Helper to check if dates are the same day\nconst isSameDay = (dateStr1, dateStr2)=>{\n    if (!dateStr1 || !dateStr2) return false;\n    return dateStr1 === dateStr2;\n};\n// Helper to get tomorrow's date as ISO string for consistency\nconst getTomorrowDateString = ()=>{\n    const tomorrow = new Date();\n    tomorrow.setDate(tomorrow.getDate() + 1);\n    return tomorrow.toISOString();\n};\n// Generate sections with levels\nconst generateSections = function() {\n    let count = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, levelsPerSection = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;\n    return Array.from({\n        length: count\n    }).map((_, sectionIndex)=>({\n            id: sectionIndex,\n            title: \"Section \".concat(sectionIndex + 1),\n            description: \"Complete all levels in Section \".concat(sectionIndex + 1),\n            isLocked: sectionIndex !== 0,\n            isCompleted: false,\n            levels: Array.from({\n                length: levelsPerSection\n            }).map((_, levelIndex)=>({\n                    id: levelIndex,\n                    title: \"Level \".concat(levelIndex + 1),\n                    isLocked: levelIndex !== 0,\n                    isCompleted: false,\n                    bestScore: 0,\n                    attempts: 0,\n                    lastPlayed: null\n                }))\n        }));\n};\n// Generate daily quests\nconst generateDailyQuests = ()=>{\n    // Get tomorrow's date in YYYY-MM-DD format (using local time)\n    const expiresAt = getTomorrowDateString();\n    return [\n        {\n            id: 'streak-bonus',\n            title: 'Get 3 Correct in a Row',\n            description: 'Answer three questions correctly in a row',\n            reward: 10,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'complete-games',\n            title: 'Complete 3 Games',\n            description: 'Complete any 3 games today (any score)',\n            reward: 15,\n            progress: 0,\n            target: 3,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'perfect-score',\n            title: 'Perfect Score',\n            description: 'Complete a level with a perfect score',\n            reward: 20,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        }\n    ];\n};\n// Collection name for user game progress\nconst GAME_PROGRESS_COLLECTION = 'gameProgress';\nconst useGameStore = (0,zustand__WEBPACK_IMPORTED_MODULE_2__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_3__.persist)((set, get)=>({\n        // Initial state\n        profile: null,\n        score: 0,\n        streak: 0,\n        lastStreakDate: '',\n        streakState: 'none',\n        totalChallengesCompleted: 0,\n        progress: {},\n        achievements: [],\n        gameAchievements: {},\n        recentChallenges: [],\n        // Basic game actions\n        addPoints: (points, gameType)=>set((state)=>{\n                const gameProgress = state.progress[gameType];\n                if (!gameProgress) return state;\n                console.log(\"[XP Debug] Adding \".concat(points, \" points to \").concat(gameType));\n                console.log(\"[XP Debug] Current XP: \".concat(gameProgress.xp));\n                // Prevent negative XP - calculate new XP ensuring it doesn't go below 0\n                const newXP = Math.max(0, gameProgress.xp + points);\n                // Update XP for the specific game type\n                const updatedGameProgress = {\n                    ...gameProgress,\n                    xp: newXP\n                };\n                console.log(\"[XP Debug] New total XP: \".concat(updatedGameProgress.xp));\n                // Update daily quest progress for XP - DIRECTLY use the game's total XP value for consistency\n                const updatedQuests = gameProgress.quests;\n                const newState = {\n                    score: state.score + points,\n                    progress: {\n                        ...state.progress,\n                        [gameType]: {\n                            ...updatedGameProgress,\n                            quests: updatedQuests\n                        }\n                    }\n                };\n                // Save to Firebase after updating local state\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return newState;\n            }),\n        increaseStreak: ()=>set((state)=>{\n                const today = getTodayDateString();\n                let newStreak = state.streak;\n                // Case 1: Already logged streak today - don't increase, just make active\n                if (isSameDay(state.lastStreakDate, today)) {\n                    return {\n                        ...state,\n                        streakState: 'active'\n                    };\n                }\n                // Case 2: First time playing or continuing streak from yesterday\n                if (isConsecutiveDay(state.lastStreakDate, today) || !state.lastStreakDate) {\n                    newStreak += 1;\n                } else {\n                    newStreak = 1; // Start a new streak\n                }\n                const newState = {\n                    streak: newStreak,\n                    lastStreakDate: today,\n                    streakState: 'active'\n                };\n                // Save to Firebase after updating local state\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return newState;\n            }),\n        resetStreak: ()=>set((state)=>{\n                const newState = {\n                    streak: 0,\n                    lastStreakDate: '',\n                    streakState: 'none'\n                };\n                // Save to Firebase after updating local state\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return newState;\n            }),\n        // Progress tracking\n        initializeGameProgress: (gameType)=>{\n            set((state)=>{\n                // Check if progress already exists for this game type\n                if (state.progress[gameType] && state.progress[gameType].sections && state.progress[gameType].sections.length > 0) {\n                    console.log(\"Game progress for \".concat(gameType, \" already initialized.\"));\n                    return state;\n                }\n                console.log(\"Initializing game progress for \".concat(gameType));\n                // Default sections with 5 sections and 5 levels each\n                const sections = generateSections();\n                // First section and first level are always unlocked\n                if (sections.length > 0) {\n                    sections[0].isLocked = false;\n                    if (sections[0].levels && sections[0].levels.length > 0) {\n                        sections[0].levels[0].isLocked = false;\n                    }\n                }\n                // Generate fresh daily quests if needed\n                const quests = generateDailyQuests();\n                return {\n                    progress: {\n                        ...state.progress,\n                        [gameType]: {\n                            sections,\n                            xp: 0,\n                            quests,\n                            currentSection: 0,\n                            currentLevel: 0,\n                            completedLevels: []\n                        }\n                    }\n                };\n            });\n        },\n        completeLevel: (gameType, sectionId, levelId, score)=>{\n            set((state)=>{\n                const gameProgress = state.progress[gameType];\n                if (!gameProgress) return state;\n                // Create a deep copy of sections\n                const updatedSections = JSON.parse(JSON.stringify(gameProgress.sections));\n                // Get the section and level\n                const section = updatedSections[sectionId];\n                if (!section || !section.levels[levelId]) return state;\n                // Update level stats - this happens regardless of score\n                const level = section.levels[levelId];\n                level.attempts = (level.attempts || 0) + 1;\n                level.lastPlayed = new Date().toISOString();\n                // Store the best score if higher than previous\n                if (score !== undefined && (level.bestScore === undefined || score > level.bestScore)) {\n                    level.bestScore = score;\n                }\n                // Create a unique ID for this level to track completion\n                const levelKey = \"\".concat(sectionId, \"-\").concat(levelId);\n                // Track completed levels for summary stats\n                let completedLevels = [\n                    ...gameProgress.completedLevels || []\n                ];\n                // Get achievements arrays\n                let achievements = [\n                    ...state.achievements || []\n                ];\n                let gameTypeAchievements = [\n                    ...state.gameAchievements[gameType] || []\n                ];\n                // Track where the user should go next (current position)\n                let nextSectionId = sectionId;\n                let nextLevelId = levelId;\n                // Mark level as completed if score is at least 80% (threshold for completing a level)\n                const isLevelCompleted = score !== undefined && score >= 80;\n                if (isLevelCompleted) {\n                    // Mark the level as completed\n                    level.isCompleted = true;\n                    // Add to completed levels array if not already there\n                    if (!completedLevels.includes(levelKey)) {\n                        completedLevels.push(levelKey);\n                    }\n                    // Check for \"Perfect Score\" achievement - score must be at least 100 (including bonuses)\n                    if (score >= 100 && !gameTypeAchievements.includes('perfect-score')) {\n                        // Add to game-specific achievements\n                        gameTypeAchievements.push('perfect-score');\n                        // Also add to global achievements for backward compatibility\n                        if (!achievements.includes('perfect-score')) {\n                            achievements.push('perfect-score');\n                        }\n                        console.log(\"[Achievement] Unlocked: Perfect Score in \".concat(gameType));\n                    }\n                    // Calculate the next level ID - advance to the next level\n                    if (levelId < section.levels.length - 1) {\n                        // Move to the next level in the same section\n                        nextLevelId = levelId + 1;\n                        // Unlock the next level\n                        section.levels[nextLevelId].isLocked = false;\n                    } else if (levelId === section.levels.length - 1) {\n                        section.isCompleted = true;\n                        // Check for \"Section Champion\" achievement\n                        // A section is considered completed when all its levels are completed\n                        const isSectionCompleted = section.levels.every((lvl)=>lvl.isCompleted);\n                        if (isSectionCompleted && !gameTypeAchievements.includes('section-champion')) {\n                            // Add to game-specific achievements\n                            gameTypeAchievements.push('section-champion');\n                            // Also add to global achievements for backward compatibility\n                            if (!achievements.includes('section-champion')) {\n                                achievements.push('section-champion');\n                            }\n                            console.log(\"[Achievement] Unlocked: Section Champion in \".concat(gameType));\n                        }\n                        // Move to the next section if available\n                        if (sectionId < updatedSections.length - 1) {\n                            nextSectionId = sectionId + 1;\n                            nextLevelId = 0; // Start at the first level of the next section\n                            // Unlock the next section\n                            updatedSections[nextSectionId].isLocked = false;\n                            // Unlock the first level of the next section\n                            updatedSections[nextSectionId].levels[0].isLocked = false;\n                        }\n                    }\n                }\n                // Update quest progress for game completion\n                const updatedQuests = gameProgress.quests.map((quest)=>{\n                    // For the 'perfect-score' quest, count games with a score of at least 100 (including bonuses)\n                    if (quest.id === 'perfect-score' && !quest.isCompleted && score !== undefined && score >= 100) {\n                        const newProgress = Math.min(quest.progress + 1, quest.target);\n                        const isCompleted = newProgress >= quest.target;\n                        return {\n                            ...quest,\n                            progress: newProgress,\n                            isCompleted\n                        };\n                    }\n                    return quest;\n                });\n                // Calculate XP Master achievement\n                if (gameProgress.xp >= 1000 && !gameTypeAchievements.includes('xp-master')) {\n                    // Add to game-specific achievements\n                    gameTypeAchievements.push('xp-master');\n                    // Also add to global achievements for backward compatibility\n                    if (!achievements.includes('xp-master')) {\n                        achievements.push('xp-master');\n                    }\n                    console.log(\"[Achievement] Unlocked: XP Master in \".concat(gameType));\n                }\n                // Prepare updated gameAchievements object\n                const updatedGameAchievements = {\n                    ...state.gameAchievements,\n                    [gameType]: gameTypeAchievements\n                };\n                // Prepare updated state\n                const newState = {\n                    achievements,\n                    gameAchievements: updatedGameAchievements,\n                    progress: {\n                        ...state.progress,\n                        [gameType]: {\n                            ...gameProgress,\n                            sections: updatedSections,\n                            quests: updatedQuests,\n                            completedLevels,\n                            // Update the current position to the next level\n                            currentSection: nextSectionId,\n                            currentLevel: nextLevelId\n                        }\n                    }\n                };\n                // Log the level transition\n                console.log(\"[Progress] Advanced to Section \".concat(nextSectionId, \", Level \").concat(nextLevelId));\n                // Save to Firebase after updating local state\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return newState;\n            });\n        },\n        canAccessLevel: (gameType, sectionId, levelId)=>{\n            const state = get();\n            // Check if game progress exists\n            if (!state.progress || !state.progress[gameType]) return false;\n            const gameProgress = state.progress[gameType];\n            // Check if sections array exists and sectionId is valid\n            if (!gameProgress.sections || !Array.isArray(gameProgress.sections) || sectionId < 0 || sectionId >= gameProgress.sections.length) {\n                return false;\n            }\n            const section = gameProgress.sections[sectionId];\n            // Check if section is locked\n            if (!section || section.isLocked) return false;\n            // Check if levels array exists and levelId is valid\n            if (!section.levels || !Array.isArray(section.levels) || levelId < 0 || levelId >= section.levels.length) {\n                return false;\n            }\n            const level = section.levels[levelId];\n            // Check if level exists and is not locked\n            return level && !level.isLocked;\n        },\n        unlockSection: (gameType, sectionId)=>{\n            set((state)=>{\n                const gameProgress = state.progress[gameType];\n                if (!gameProgress) return state;\n                const updatedSections = [\n                    ...gameProgress.sections\n                ];\n                if (updatedSections[sectionId]) {\n                    updatedSections[sectionId].isLocked = false;\n                    // Also unlock the first level\n                    if (updatedSections[sectionId].levels[0]) {\n                        updatedSections[sectionId].levels[0].isLocked = false;\n                    }\n                }\n                const newState = {\n                    progress: {\n                        ...state.progress,\n                        [gameType]: {\n                            ...gameProgress,\n                            sections: updatedSections\n                        }\n                    }\n                };\n                // Save to Firebase after updating local state\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return newState;\n            });\n        },\n        // Daily quests\n        addProgressToQuest: (gameType, questId, amount)=>{\n            set((state)=>{\n                const gameProgress = state.progress[gameType];\n                if (!gameProgress) return state;\n                const updatedQuests = gameProgress.quests.map((quest)=>{\n                    if (quest.id === questId && !quest.isCompleted) {\n                        const newProgress = Math.min(quest.progress + amount, quest.target);\n                        const isCompleted = newProgress >= quest.target;\n                        if (!quest.isCompleted && isCompleted) {\n                            (async ()=>{\n                                try {\n                                    const { createXpGrant } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_services_user_xpGrants_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/services/user/xpGrants */ \"(app-pages-browser)/./src/services/user/xpGrants.ts\"));\n                                    await createXpGrant({\n                                        sourceType: 'quest',\n                                        sourceId: \"\".concat(gameType, \":\").concat(quest.id),\n                                        amount: quest.reward\n                                    });\n                                    console.log('[XP] Quest completion grant persisted from store', quest.id);\n                                } catch (e) {\n                                    console.warn('[XP] Failed to persist quest grant from store (queued if offline)', e);\n                                }\n                            })();\n                        }\n                        return {\n                            ...quest,\n                            progress: newProgress,\n                            isCompleted\n                        };\n                    }\n                    return quest;\n                });\n                const newState = {\n                    progress: {\n                        ...state.progress,\n                        [gameType]: {\n                            ...gameProgress,\n                            quests: updatedQuests\n                        }\n                    }\n                };\n                // Save to Firebase after updating local state\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return newState;\n            });\n        },\n        completeQuest: (gameType, questId)=>{\n            set((state)=>{\n                // Skip if no progress data for this game type\n                if (!state.progress || !state.progress[gameType]) return state;\n                // Get the quests for this specific game type\n                const gameProgress = state.progress[gameType];\n                // Update only the streak-bonus quest for this game type\n                const updatedQuests = gameProgress.quests.map((quest)=>{\n                    if (quest.id === questId) {\n                        if (!quest.isCompleted) {\n                            (async ()=>{\n                                try {\n                                    const { createXpGrant } = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_src_services_user_xpGrants_ts\").then(__webpack_require__.bind(__webpack_require__, /*! @/services/user/xpGrants */ \"(app-pages-browser)/./src/services/user/xpGrants.ts\"));\n                                    await createXpGrant({\n                                        sourceType: 'quest',\n                                        sourceId: \"\".concat(gameType, \":\").concat(quest.id),\n                                        amount: quest.reward\n                                    });\n                                    console.log('[XP] Quest completion grant persisted from store (manual complete)', quest.id);\n                                } catch (e) {\n                                    console.warn('[XP] Failed to persist quest grant from store (manual complete)', e);\n                                }\n                            })();\n                        }\n                        return {\n                            ...quest,\n                            progress: quest.target,\n                            isCompleted: true\n                        };\n                    }\n                    return quest;\n                });\n                // Create the updated progress for just this game type\n                const updatedProgress = {\n                    ...state.progress,\n                    [gameType]: {\n                        ...gameProgress,\n                        quests: updatedQuests\n                    }\n                };\n                // Save to Firebase after updating\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return {\n                    progress: updatedProgress\n                };\n            });\n        },\n        checkAndRefreshQuests: (gameType)=>{\n            set((state)=>{\n                const gameProgress = state.progress[gameType];\n                if (!gameProgress) return state;\n                const today = getTodayDateString();\n                let questsNeedReset = false;\n                // Check if any quests have expired\n                if (gameProgress.quests && Array.isArray(gameProgress.quests)) {\n                    gameProgress.quests.forEach((quest)=>{\n                        // Compare dates in YYYY-MM-DD format (local time)\n                        // If the expiration date is today or earlier, the quest has expired\n                        if (quest.expiresAt <= today) {\n                            questsNeedReset = true;\n                        }\n                    });\n                } else {\n                    // If quests array doesn't exist or is not an array, we need to reset\n                    questsNeedReset = true;\n                }\n                // If quests need to be reset, generate new ones\n                if (questsNeedReset) {\n                    console.log(\"Resetting quests for \".concat(gameType, \" as they have expired\"));\n                    const newState = {\n                        progress: {\n                            ...state.progress,\n                            [gameType]: {\n                                ...gameProgress,\n                                quests: generateDailyQuests()\n                            }\n                        }\n                    };\n                    // Save to Firebase after updating local state\n                    setTimeout(()=>get().saveUserProgress(), 0);\n                    return newState;\n                }\n                return state;\n            });\n        },\n        resetQuests: (gameType)=>{\n            set((state)=>{\n                const gameProgress = state.progress[gameType];\n                if (!gameProgress) return state;\n                // Generate fresh quests\n                const freshQuests = generateDailyQuests();\n                const newState = {\n                    progress: {\n                        ...state.progress,\n                        [gameType]: {\n                            ...gameProgress,\n                            quests: freshQuests\n                        }\n                    }\n                };\n                // Save to Firebase after updating local state\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return newState;\n            });\n        },\n        completeStreakBonusQuest: (gameType)=>{\n            set((state)=>{\n                // Skip if no progress data for this game type\n                if (!state.progress || !state.progress[gameType]) return state;\n                // Get the quests for this specific game type\n                const gameProgress = state.progress[gameType];\n                // Update only the streak-bonus quest for this game type\n                const updatedQuests = gameProgress.quests.map((quest)=>{\n                    if (quest.id === 'streak-bonus' && !quest.isCompleted) {\n                        return {\n                            ...quest,\n                            progress: 1,\n                            isCompleted: true\n                        };\n                    }\n                    return quest;\n                });\n                // Create the updated progress for just this game type\n                const updatedProgress = {\n                    ...state.progress,\n                    [gameType]: {\n                        ...gameProgress,\n                        quests: updatedQuests\n                    }\n                };\n                // Save to Firebase after updating\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return {\n                    progress: updatedProgress\n                };\n            });\n        },\n        // Challenge tracking\n        addChallengeResult: (result)=>{\n            set((state)=>{\n                const newChallenges = [\n                    ...state.recentChallenges,\n                    result\n                ];\n                // Cap at 50 challenges to prevent document size issues\n                const cappedChallenges = newChallenges.slice(-50);\n                return {\n                    recentChallenges: cappedChallenges\n                };\n            });\n        },\n        // Check if streak should be reset\n        checkStreakReset: ()=>{\n            set((state)=>{\n                console.log('[StreakCheck] Current state:', {\n                    streak: state.streak,\n                    lastStreakDate: state.lastStreakDate,\n                    streakState: state.streakState\n                });\n                // If there's no last streak date, no need to check\n                if (!state.lastStreakDate) {\n                    console.log('[StreakCheck] No last streak date, setting to none');\n                    return {\n                        ...state,\n                        streakState: 'none'\n                    };\n                }\n                const today = getTodayDateString();\n                // If they already played today, streak is active\n                if (isSameDay(state.lastStreakDate, today)) {\n                    console.log('[StreakCheck] Played today, keeping streak active');\n                    return {\n                        ...state,\n                        streakState: 'active'\n                    };\n                }\n                // If they last played yesterday, streak is valid but inactive\n                if (isConsecutiveDay(state.lastStreakDate, today)) {\n                    console.log('[StreakCheck] Played yesterday, streak inactive but valid');\n                    return {\n                        ...state,\n                        streakState: 'inactive'\n                    };\n                }\n                // If it's been more than a day since last play, reset streak\n                console.log('[StreakCheck] Resetting streak due to inactivity');\n                return {\n                    ...state,\n                    streak: 0,\n                    streakState: 'none'\n                };\n            });\n        },\n        checkStreakStatus: ()=>{\n            set((state)=>{\n                const today = getTodayDateString();\n                // If no streak, status is \"none\"\n                if (state.streak === 0) {\n                    return {\n                        ...state,\n                        streakState: 'none'\n                    };\n                }\n                // If played today, streak is active\n                if (isSameDay(state.lastStreakDate, today)) {\n                    return {\n                        ...state,\n                        streakState: 'active'\n                    };\n                }\n                // Otherwise, streak exists but is inactive\n                return {\n                    ...state,\n                    streakState: 'inactive'\n                };\n            });\n        },\n        // Complete a game and handle streak/XP tracking\n        completeGame: (gameType, score, isCorrect)=>set((state)=>{\n                if (!gameType) return state;\n                console.log(\"[GameDB] Completing game: \".concat(gameType, \", Score: \").concat(score, \", Correct: \").concat(isCorrect));\n                // Update the last played timestamp\n                const gameProgress = state.progress[gameType] || {\n                    sections: generateSections(),\n                    xp: 0,\n                    quests: generateDailyQuests(),\n                    currentSection: 0,\n                    currentLevel: 0,\n                    completedLevels: [],\n                    lastPlayedAt: ''\n                };\n                // Create updated game progress with timestamp\n                const updatedGameProgress = {\n                    ...gameProgress,\n                    lastPlayedAt: new Date().toISOString()\n                };\n                // Update streak handling - IMPORTANT: streak is not reset on wrong answers\n                // It only updates (increases) when it's the first correct answer of a new day\n                const today = getTodayDateString();\n                const streakUpdates = {};\n                // Only consider streak updates for correct answers\n                if (isCorrect) {\n                    if (state.lastStreakDate !== today) {\n                        // This is the first correct answer of a new day - increase streak\n                        streakUpdates.streak = state.streak + 1;\n                        streakUpdates.lastStreakDate = today;\n                        streakUpdates.streakState = 'active';\n                        console.log(\"[GameDB] Increasing streak to \".concat(streakUpdates.streak, \" (first correct answer today)\"));\n                    } else {\n                        // Already played today and got something correct - streak remains active\n                        streakUpdates.streakState = 'active';\n                    }\n                }\n                // Update achievements - track each game type separately\n                let achievements = [\n                    ...state.achievements || []\n                ];\n                let gameTypeAchievements = [\n                    ...state.gameAchievements[gameType] || []\n                ];\n                // Check for \"First Steps\" achievement - completing any game\n                if (!gameTypeAchievements.includes('first-steps')) {\n                    // Add to game-specific achievements\n                    gameTypeAchievements.push('first-steps');\n                    // Also add to global achievements for backward compatibility\n                    if (!achievements.includes('first-steps')) {\n                        achievements.push('first-steps');\n                    }\n                    console.log(\"[Achievement] Unlocked: First Steps in \".concat(gameType, \" - Completed your first game!\"));\n                }\n                // Check for \"Perfect Score\" achievement - score must be at least 100 (including bonuses)\n                if (score >= 100 && !gameTypeAchievements.includes('perfect-score')) {\n                    // Add to game-specific achievements\n                    gameTypeAchievements.push('perfect-score');\n                    // Also add to global achievements for backward compatibility\n                    if (!achievements.includes('perfect-score')) {\n                        achievements.push('perfect-score');\n                    }\n                    console.log(\"[Achievement] Unlocked: Perfect Score in \".concat(gameType, \" - Scored 100% or higher!\"));\n                }\n                // Check for \"Streak Master\" achievement - maintain a 7-day streak\n                // Note: Streak Master is a global achievement, not game-specific\n                if (streakUpdates.streak !== undefined && streakUpdates.streak >= 7 && !achievements.includes('streak-master')) {\n                    // Add directly to global achievements\n                    achievements.push('streak-master');\n                    // But also add to game-specific achievements for the current game type\n                    if (!gameTypeAchievements.includes('streak-master')) {\n                        gameTypeAchievements.push('streak-master');\n                    }\n                    console.log('[Achievement] Unlocked: Streak Master - Maintained a 7-day streak!');\n                }\n                // Prepare updated gameAchievements object\n                const updatedGameAchievements = {\n                    ...state.gameAchievements,\n                    [gameType]: gameTypeAchievements\n                };\n                // Update progress with the game progress\n                const updatedProgress = {\n                    ...state.progress,\n                    [gameType]: updatedGameProgress\n                };\n                // Create a challenge result record\n                const challengeResult = {\n                    id: \"\".concat(gameType, \"-\").concat(Date.now()),\n                    challengeType: gameType,\n                    score,\n                    maxScore: 100,\n                    completedAt: new Date().toISOString(),\n                    duration: 0,\n                    isCorrect,\n                    gameType\n                };\n                // Add to recent challenges\n                const updatedRecentChallenges = [\n                    ...state.recentChallenges,\n                    challengeResult\n                ];\n                // Create the final state updates\n                const gameUpdates = {\n                    progress: updatedProgress,\n                    achievements,\n                    gameAchievements: updatedGameAchievements,\n                    totalChallengesCompleted: state.totalChallengesCompleted + 1,\n                    recentChallenges: updatedRecentChallenges,\n                    ...streakUpdates\n                };\n                // Save to database\n                setTimeout(()=>get().saveUserProgress(), 0);\n                return gameUpdates;\n            }),\n        // Save user progress to database with better error handling\n        saveUserProgress: async ()=>{\n            const user = _lib_firebase__WEBPACK_IMPORTED_MODULE_1__.auth.currentUser;\n            if (!user) {\n                console.error('[Database] Cannot save: No authenticated user');\n                return;\n            }\n            try {\n                console.log('[Database] Saving user progress to Firestore...');\n                // Get the user document reference\n                const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, GAME_PROGRESS_COLLECTION, user.uid);\n                // Prepare data to save - ensure all fields exist\n                const dataToSave = {\n                    // User profile\n                    profile: get().profile,\n                    // Game statistics\n                    score: get().score || 0,\n                    streak: get().streak || 0,\n                    lastStreakDate: get().lastStreakDate || '',\n                    streakState: get().streakState || 'none',\n                    totalChallengesCompleted: get().totalChallengesCompleted || 0,\n                    // Achievements\n                    achievements: get().achievements || [],\n                    gameAchievements: get().gameAchievements || {},\n                    // Challenge history\n                    recentChallenges: get().recentChallenges || [],\n                    // Game progress data\n                    progress: get().progress || {},\n                    // Metadata\n                    updatedAt: new Date().toISOString()\n                };\n                // Log a summary of what's being saved\n                console.log(\"[Database] Saving - Score: \".concat(dataToSave.score, \", Streak: \").concat(dataToSave.streak, \", Achievements: \").concat(dataToSave.achievements.length));\n                // Deep clone to avoid Firebase warnings about objects with custom prototypes\n                const cleanData = JSON.parse(JSON.stringify(dataToSave));\n                // Use merge to avoid overwriting any fields not included in current state\n                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(userProgressRef, cleanData, {\n                    merge: true\n                });\n                console.log('[Database] Successfully saved user progress to Firestore');\n            } catch (error) {\n                console.error('[Database] Error saving user progress:', error);\n                // Try to save again after a delay\n                setTimeout(()=>{\n                    console.log('[Database] Retrying failed save operation...');\n                    get().saveUserProgress();\n                }, 3000);\n            }\n        },\n        // User-specific progress\n        loadUserProgress: async ()=>{\n            const user = _lib_firebase__WEBPACK_IMPORTED_MODULE_1__.auth.currentUser;\n            if (!user) {\n                console.log('[Auth] No authenticated user found when trying to load progress');\n                return;\n            }\n            try {\n                console.log(\"[Auth] Loading progress for user: \".concat(user.uid));\n                const userProgressRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_1__.db, GAME_PROGRESS_COLLECTION, user.uid);\n                const userProgressDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDoc)(userProgressRef);\n                if (userProgressDoc.exists()) {\n                    const data = userProgressDoc.data();\n                    set((state)=>({\n                            ...state,\n                            profile: data.profile || null,\n                            score: data.score || 0,\n                            streak: data.streak || 0,\n                            lastStreakDate: data.lastStreakDate || '',\n                            streakState: data.streakState || 'none',\n                            totalChallengesCompleted: data.totalChallengesCompleted || 0,\n                            achievements: data.achievements || [],\n                            gameAchievements: data.gameAchievements || {},\n                            recentChallenges: data.recentChallenges || [],\n                            progress: data.progress || {}\n                        }));\n                    console.log('[Auth] Successfully loaded user progress from Firestore');\n                } else {\n                    console.log('[Auth] No saved progress found for user. Initializing new progress.');\n                    // Create initial game progress structure\n                    const initialProgress = {\n                        'make-sentence': {\n                            sections: generateSections(),\n                            xp: 0,\n                            quests: generateDailyQuests(),\n                            currentSection: 0,\n                            currentLevel: 0,\n                            completedLevels: []\n                        },\n                        'multiple-choice': {\n                            sections: generateSections(),\n                            xp: 0,\n                            quests: generateDailyQuests(),\n                            currentSection: 0,\n                            currentLevel: 0,\n                            completedLevels: []\n                        }\n                    };\n                    // First, unlock the first level of each game type\n                    for (const gameType of Object.keys(initialProgress)){\n                        if (initialProgress[gameType].sections.length > 0) {\n                            initialProgress[gameType].sections[0].isLocked = false;\n                            if (initialProgress[gameType].sections[0].levels.length > 0) {\n                                initialProgress[gameType].sections[0].levels[0].isLocked = false;\n                            }\n                        }\n                    }\n                    // Create initial user profile\n                    const initialProfile = {\n                        displayName: user.displayName,\n                        email: user.email,\n                        photoURL: user.photoURL,\n                        joinDate: new Date().toISOString(),\n                        lastActiveDate: new Date().toISOString(),\n                        gradeLevel: null,\n                        preferences: {\n                            emailNotifications: false,\n                            dailyReminder: true\n                        }\n                    };\n                    // Create initial state to update locally\n                    const newUserData = {\n                        profile: initialProfile,\n                        score: 0,\n                        streak: 0,\n                        lastStreakDate: '',\n                        streakState: 'none',\n                        totalChallengesCompleted: 0,\n                        achievements: [],\n                        gameAchievements: {},\n                        recentChallenges: [],\n                        progress: initialProgress,\n                        createdAt: new Date().toISOString(),\n                        updatedAt: new Date().toISOString(),\n                        userId: user.uid\n                    };\n                    // Update local state\n                    set((state)=>({\n                            ...state,\n                            ...newUserData\n                        }));\n                    // IMPORTANT: Save the initial data to Firestore immediately\n                    // This ensures the user has a gameProgress document from the start\n                    try {\n                        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(userProgressRef, newUserData);\n                        console.log('[Auth] Successfully created new user progress document in Firestore');\n                    } catch (error) {\n                        console.error('[Auth] Error creating initial progress document:', error);\n                    }\n                }\n                // Check if streak should be reset after loading data\n                get().checkStreakReset();\n            } catch (error) {\n                console.error('[Auth] Error loading user progress:', error);\n            }\n        },\n        // Ensure game progress exists for a given game type\n        ensureGameProgressExists: (gameType)=>{\n            set((state)=>{\n                if (!state.progress[gameType]) {\n                    const newProgress = {\n                        sections: generateSections(),\n                        xp: 0,\n                        quests: generateDailyQuests(),\n                        currentSection: 0,\n                        currentLevel: 0,\n                        completedLevels: []\n                    };\n                    return {\n                        progress: {\n                            ...state.progress,\n                            [gameType]: newProgress\n                        }\n                    };\n                }\n                return state;\n            });\n        },\n        // Profile management\n        updateUserProfile: (updates)=>{\n            set((state)=>({\n                    profile: {\n                        ...state.profile,\n                        ...updates\n                    }\n                }));\n        }\n    }), {\n    name: 'game-storage',\n    // Don't persist user progress from localStorage to avoid hydration issues\n    partialize: (state)=>({}),\n    // Only enable storage on the client side\n    skipHydration: true\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9nYW1lU3RvcmUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFDUTtBQUNZO0FBQ29DO0FBQzdDO0FBQ0U7QUE2SXRDLDJEQUEyRDtBQUMzRCxNQUFNTyxxQkFBcUI7SUFDekIsMENBQTBDO0lBQzFDLE9BQU8sSUFBSUMsT0FBT0MsV0FBVztBQUMvQjtBQUVBLG9EQUFvRDtBQUNwRCxNQUFNQyxtQkFBbUIsQ0FBQ0MsY0FBc0JDO0lBQzlDLElBQUksQ0FBQ0QsY0FBYyxPQUFPO0lBRTFCLDhEQUE4RDtJQUM5RCxNQUFNRSxPQUFPLElBQUlMLEtBQUtHO0lBQ3RCLE1BQU1HLE9BQU8sSUFBSU4sS0FBS0k7SUFFdEIsNkNBQTZDO0lBQzdDQyxLQUFLRSxRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7SUFDdkJELEtBQUtDLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRztJQUV2QiwrQkFBK0I7SUFDL0IsTUFBTUMsV0FBV0YsS0FBS0csT0FBTyxLQUFLSixLQUFLSSxPQUFPO0lBQzlDLE1BQU1DLFdBQVdGLFdBQVksUUFBTyxPQUFPLEVBQUM7SUFFNUMsbURBQW1EO0lBQ25ELE9BQU9HLEtBQUtDLEtBQUssQ0FBQ0YsY0FBYztBQUNsQztBQUVBLDRDQUE0QztBQUM1QyxNQUFNRyxZQUFZLENBQUNDLFVBQWtCQztJQUNuQyxJQUFJLENBQUNELFlBQVksQ0FBQ0MsVUFBVSxPQUFPO0lBQ25DLE9BQU9ELGFBQWFDO0FBQ3RCO0FBRUEsOERBQThEO0FBQzlELE1BQU1DLHdCQUF3QjtJQUM1QixNQUFNQyxXQUFXLElBQUlqQjtJQUNyQmlCLFNBQVNDLE9BQU8sQ0FBQ0QsU0FBU0UsT0FBTyxLQUFLO0lBQ3RDLE9BQU9GLFNBQVNoQixXQUFXO0FBQzdCO0FBRUEsZ0NBQWdDO0FBQ2hDLE1BQU1tQixtQkFBbUI7UUFBQ0MseUVBQWdCLEdBQUdDLG9GQUEyQjtJQUN0RSxPQUFPQyxNQUFNQyxJQUFJLENB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QUcrSCxPQUFPO29CQUNaO2dCQUNGO1FBQ0Y7SUFDRixJQUNBO0lBQ0VDLE1BQU07SUFDTiwwRUFBMEU7SUFDMUVDLFlBQVksQ0FBQ3JILFFBQVcsRUFBQztJQUN6Qix5Q0FBeUM7SUFDekNzSCxlQUFlO0FBQ2pCLElBRUYiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lcnZpbnJhcGhhZWxhbGJhL0Rlc2t0b3AvWDQyMC9zcmMvc3RvcmUvZ2FtZVN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9zdG9yZS9nYW1lU3RvcmUudHNcbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xuaW1wb3J0IHsgcGVyc2lzdCB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBkb2MsIGdldERvYywgc2V0RG9jLCB1cGRhdGVEb2MsIGRlbGV0ZUZpZWxkIH0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcbmltcG9ydCB7IGRiIH0gZnJvbSAnQC9saWIvZmlyZWJhc2UnO1xuaW1wb3J0IHsgYXV0aCB9IGZyb20gJ0AvbGliL2ZpcmViYXNlJztcblxuLy8gU2VjdGlvbiByZXByZXNlbnRzIGEgZ3JvdXAgb2YgbGV2ZWxzICg1IGxldmVscyBwZXIgc2VjdGlvbiwgNSBzZWN0aW9ucyB0b3RhbClcbmV4cG9ydCB0eXBlIFNlY3Rpb24gPSB7XG4gIGlkOiBudW1iZXI7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGlzTG9ja2VkOiBib29sZWFuO1xuICBpc0NvbXBsZXRlZDogYm9vbGVhbjtcbiAgbGV2ZWxzOiBMZXZlbFtdO1xufTtcblxuLy8gTGV2ZWwgcmVwcmVzZW50cyBhbiBpbmRpdmlkdWFsIGNoYWxsZW5nZSBsZXZlbFxuZXhwb3J0IHR5cGUgTGV2ZWwgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGlzTG9ja2VkOiBib29sZWFuO1xuICBpc0NvbXBsZXRlZDogYm9vbGVhbjtcbiAgYmVzdFNjb3JlOiBudW1iZXI7XG4gIGF0dGVtcHRzOiBudW1iZXI7XG4gIGxhc3RQbGF5ZWQ6IHN0cmluZyB8IG51bGw7XG59O1xuXG4vLyBEYWlseSBxdWVzdCByZXByZXNlbnRhdGlvblxuZXhwb3J0IHR5cGUgRGFpbHlRdWVzdCA9IHtcbiAgaWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgcmV3YXJkOiBudW1iZXI7IC8vIFhQIHJld2FyZFxuICBwcm9ncmVzczogbnVtYmVyO1xuICB0YXJnZXQ6IG51bWJlcjtcbiAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47XG4gIGV4cGlyZXNBdDogc3RyaW5nOyAvLyBJU08gZGF0ZSBzdHJpbmdcbn07XG5cbi8vIFVzZXIgcHJvZmlsZSBkYXRhIChjb25zb2xpZGF0ZWQgZnJvbSBVc2VyU2VydmljZSlcbi8vIE5vdGU6IHVpZCBpcyBub3Qgc3RvcmVkIHNpbmNlIGRvY3VtZW50IElEIGlzIGFscmVhZHkgdGhlIHVzZXIgSURcbmV4cG9ydCB0eXBlIFVzZXJQcm9maWxlID0ge1xuICBkaXNwbGF5TmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgZW1haWw6IHN0cmluZyB8IG51bGw7XG4gIHBob3RvVVJMOiBzdHJpbmcgfCBudWxsO1xuICBqb2luRGF0ZTogc3RyaW5nO1xuICBsYXN0QWN0aXZlRGF0ZTogc3RyaW5nO1xuICAvLyBOZXc6IGdyYWRlIGxldmVsIG9uYm9hcmRpbmcgc2VsZWN0aW9uOyBudWxsIHVudGlsIHVzZXIgcGlja3Mgb25lXG4gIGdyYWRlTGV2ZWw/OiAnRzFfMicgfCAnRzNfNCcgfCAnRzVfNicgfCBudWxsO1xuICBwcmVmZXJlbmNlczoge1xuICAgIGVtYWlsTm90aWZpY2F0aW9uczogYm9vbGVhbjtcbiAgICBkYWlseVJlbWluZGVyOiBib29sZWFuO1xuICB9O1xufTtcblxuLy8gQ2hhbGxlbmdlIHJlc3VsdCB0cmFja2luZ1xuZXhwb3J0IHR5cGUgQ2hhbGxlbmdlUmVzdWx0ID0ge1xuICBpZDogc3RyaW5nO1xuICBjaGFsbGVuZ2VUeXBlOiAnbWFrZS1zZW50ZW5jZScgfCAnbXVsdGlwbGUtY2hvaWNlJyB8ICdjb252ZXJzYXRpb24nO1xuICBzY29yZTogbnVtYmVyO1xuICBtYXhTY29yZTogbnVtYmVyO1xuICBjb21wbGV0ZWRBdDogc3RyaW5nO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBpc0NvcnJlY3Q6IGJvb2xlYW47XG4gIGdhbWVUeXBlOiBzdHJpbmc7XG59O1xuXG4vLyBSZWNvcmQgb2YgY29tcGxldGVkIGxldmVscyBmb3IgcHJvZ3Jlc3Npb24gdHJhY2tpbmdcbnR5cGUgTGV2ZWxQcm9ncmVzcyA9IHtcbiAgW2dhbWVUeXBlOiBzdHJpbmddOiB7XG4gICAgY3VycmVudExldmVsOiBudW1iZXI7XG4gICAgY3VycmVudFNlY3Rpb246IG51bWJlcjtcbiAgICBzZWN0aW9uczogU2VjdGlvbltdO1xuICAgIHhwOiBudW1iZXI7XG4gICAgcXVlc3RzOiBEYWlseVF1ZXN0W107XG4gICAgY29tcGxldGVkTGV2ZWxzOiBzdHJpbmdbXTtcbiAgICBsYXN0UGxheWVkQXQ/OiBzdHJpbmc7XG4gIH1cbn07XG5cbi8vIERlZmluZSBhY2hpZXZlbWVudCB0eXBlc1xuZXhwb3J0IGludGVyZmFjZSBBY2hpZXZlbWVudCB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgdW5sb2NrZWRBdD86IHN0cmluZztcbiAgZ2FtZVR5cGU/OiBzdHJpbmc7IC8vIFdoaWNoIGdhbWUgdHlwZSB0aGlzIGFjaGlldmVtZW50IHdhcyBlYXJuZWQgaW5cbn1cblxuLy8gR2FtZVN0YXRlIHJlcHJlc2VudHMgdGhlIGdsb2JhbCBnYW1lIHN0YXRlIChjb25zb2xpZGF0ZWQgZGF0YSBtb2RlbClcbnR5cGUgR2FtZVN0YXRlID0ge1xuICAvLyBVc2VyIHByb2ZpbGVcbiAgcHJvZmlsZTogVXNlclByb2ZpbGUgfCBudWxsO1xuICBcbiAgLy8gR2FtZSBzdGF0aXN0aWNzXG4gIHNjb3JlOiBudW1iZXI7XG4gIHN0cmVhazogbnVtYmVyO1xuICBsYXN0U3RyZWFrRGF0ZTogc3RyaW5nO1xuICBzdHJlYWtTdGF0ZTogXCJub25lXCIgfCBcImluYWN0aXZlXCIgfCBcImFjdGl2ZVwiO1xuICB0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQ6IG51bWJlcjtcbiAgXG4gIC8vIEdhbWUgcHJvZ3Jlc3NcbiAgcHJvZ3Jlc3M6IExldmVsUHJvZ3Jlc3M7XG4gIGFjaGlldmVtZW50czogc3RyaW5nW107IC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgdXNlcnNcbiAgZ2FtZUFjaGlldmVtZW50czoge1xuICAgIFtnYW1lVHlwZTogc3RyaW5nXTogc3RyaW5nW107IC8vIEdhbWUtc3BlY2lmaWMgYWNoaWV2ZW1lbnRzIGJ5IGdhbWUgdHlwZVxuICB9O1xuICBcbiAgLy8gQ2hhbGxlbmdlIGhpc3RvcnlcbiAgcmVjZW50Q2hhbGxlbmdlczogQ2hhbGxlbmdlUmVzdWx0W107XG4gIFxuICAvLyBBY3Rpb25zXG4gIGFkZFBvaW50czogKHBvaW50czogbnVtYmVyLCBnYW1lVHlwZTogc3RyaW5nKSA9PiB2b2lkO1xuICBpbmNyZWFzZVN0cmVhazogKCkgPT4gdm9pZDtcbiAgcmVzZXRTdHJlYWs6ICgpID0+IHZvaWQ7XG4gIFxuICAvLyBHYW1lIHByb2dyZXNzaW9uXG4gIGNvbXBsZXRlTGV2ZWw6IChnYW1lVHlwZTogc3RyaW5nLCBzZWN0aW9uSWQ6IG51bWJlciwgbGV2ZWxJZDogbnVtYmVyLCBzY29yZT86IG51bWJlcikgPT4gdm9pZDtcbiAgY2FuQWNjZXNzTGV2ZWw6IChnYW1lVHlwZTogc3RyaW5nLCBzZWN0aW9uSWQ6IG51bWJlciwgbGV2ZWxJZDogbnVtYmVyKSA9PiBib29sZWFuO1xuICB1bmxvY2tTZWN0aW9uOiAoZ2FtZVR5cGU6IHN0cmluZywgc2VjdGlvbklkOiBudW1iZXIpID0+IHZvaWQ7XG4gIGluaXRpYWxpemVHYW1lUHJvZ3Jlc3M6IChnYW1lVHlwZTogc3RyaW5nKSA9PiB2b2lkO1xuICBcbiAgLy8gRGFpbHkgcXVlc3RzXG4gIGFkZFByb2dyZXNzVG9RdWVzdDogKGdhbWVUeXBlOiBzdHJpbmcsIHF1ZXN0SWQ6IHN0cmluZywgYW1vdW50OiBudW1iZXIpID0+IHZvaWQ7XG4gIGNvbXBsZXRlUXVlc3Q6IChnYW1lVHlwZTogc3RyaW5nLCBxdWVzdElkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGNoZWNrQW5kUmVmcmVzaFF1ZXN0czogKGdhbWVUeXBlOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHJlc2V0UXVlc3RzOiAoZ2FtZVR5cGU6IHN0cmluZykgPT4gdm9pZDtcbiAgY29tcGxldGVTdHJlYWtCb251c1F1ZXN0OiAoZ2FtZVR5cGU6IHN0cmluZykgPT4gdm9pZDtcbiAgXG4gIC8vIENoYWxsZW5nZSB0cmFja2luZ1xuICBhZGRDaGFsbGVuZ2VSZXN1bHQ6IChyZXN1bHQ6IENoYWxsZW5nZVJlc3VsdCkgPT4gdm9pZDtcbiAgXG4gIC8vIFVzZXIgc3BlY2lmaWMgZGF0YVxuICBsb2FkVXNlclByb2dyZXNzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBzYXZlVXNlclByb2dyZXNzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBtaWdyYXRlVXNlckRhdGE/OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBjaGVja1N0cmVha1Jlc2V0OiAoKSA9PiB2b2lkO1xuICBjaGVja1N0cmVha1N0YXR1czogKCkgPT4gdm9pZDtcbiAgY29tcGxldGVHYW1lOiAoZ2FtZVR5cGU6IHN0cmluZywgc2NvcmU6IG51bWJlciwgaXNDb3JyZWN0OiBib29sZWFuKSA9PiB2b2lkO1xuICBlbnN1cmVHYW1lUHJvZ3Jlc3NFeGlzdHM6IChnYW1lVHlwZTogc3RyaW5nKSA9PiB2b2lkO1xuICBcbiAgLy8gUHJvZmlsZSBtYW5hZ2VtZW50XG4gIHVwZGF0ZVVzZXJQcm9maWxlOiAodXBkYXRlczogUGFydGlhbDxVc2VyUHJvZmlsZT4pID0+IHZvaWQ7XG59O1xuXG4vLyBIZWxwZXIgdG8gZ2V0IHRvZGF5J3MgZGF0ZSBhcyBJU08gc3RyaW5nIGZvciBjb25zaXN0ZW5jeVxuY29uc3QgZ2V0VG9kYXlEYXRlU3RyaW5nID0gKCkgPT4ge1xuICAvLyBVc2UgY29uc2lzdGVudCBJU08gZm9ybWF0IGZvciBhbGwgZGF0ZXNcbiAgcmV0dXJuIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbn07XG5cbi8vIEhlbHBlciB0byBjaGVjayBpZiB0d28gZGF0ZXMgYXJlIGNvbnNlY3V0aXZlIGRheXNcbmNvbnN0IGlzQ29uc2VjdXRpdmVEYXkgPSAocHJldmlvdXNEYXRlOiBzdHJpbmcsIGN1cnJlbnREYXRlOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgaWYgKCFwcmV2aW91c0RhdGUpIHJldHVybiBmYWxzZTtcbiAgXG4gIC8vIFBhcnNlIGRhdGVzICh1c2luZyBEYXRlIGNvbnN0cnVjdG9yIHdpdGggWVlZWS1NTS1ERCBmb3JtYXQpXG4gIGNvbnN0IHByZXYgPSBuZXcgRGF0ZShwcmV2aW91c0RhdGUpO1xuICBjb25zdCBjdXJyID0gbmV3IERhdGUoY3VycmVudERhdGUpO1xuICBcbiAgLy8gU2V0IHRvIHNhbWUgdGltZSB0byBjb21wYXJlIGp1c3QgdGhlIGRhdGVzXG4gIHByZXYuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIGN1cnIuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIFxuICAvLyBDYWxjdWxhdGUgZGlmZmVyZW5jZSBpbiBkYXlzXG4gIGNvbnN0IHRpbWVEaWZmID0gY3Vyci5nZXRUaW1lKCkgLSBwcmV2LmdldFRpbWUoKTtcbiAgY29uc3QgZGF5c0RpZmYgPSB0aW1lRGlmZiAvICgxMDAwICogMzYwMCAqIDI0KTtcbiAgXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBkYXRlcyBhcmUgZXhhY3RseSAxIGRheSBhcGFydFxuICByZXR1cm4gTWF0aC5yb3VuZChkYXlzRGlmZikgPT09IDE7XG59O1xuXG4vLyBIZWxwZXIgdG8gY2hlY2sgaWYgZGF0ZXMgYXJlIHRoZSBzYW1lIGRheVxuY29uc3QgaXNTYW1lRGF5ID0gKGRhdGVTdHIxOiBzdHJpbmcsIGRhdGVTdHIyOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgaWYgKCFkYXRlU3RyMSB8fCAhZGF0ZVN0cjIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGRhdGVTdHIxID09PSBkYXRlU3RyMjtcbn07XG5cbi8vIEhlbHBlciB0byBnZXQgdG9tb3Jyb3cncyBkYXRlIGFzIElTTyBzdHJpbmcgZm9yIGNvbnNpc3RlbmN5XG5jb25zdCBnZXRUb21vcnJvd0RhdGVTdHJpbmcgPSAoKTogc3RyaW5nID0+IHtcbiAgY29uc3QgdG9tb3Jyb3cgPSBuZXcgRGF0ZSgpO1xuICB0b21vcnJvdy5zZXREYXRlKHRvbW9ycm93LmdldERhdGUoKSArIDEpO1xuICByZXR1cm4gdG9tb3Jyb3cudG9JU09TdHJpbmcoKTtcbn07XG5cbi8vIEdlbmVyYXRlIHNlY3Rpb25zIHdpdGggbGV2ZWxzXG5jb25zdCBnZW5lcmF0ZVNlY3Rpb25zID0gKGNvdW50OiBudW1iZXIgPSA1LCBsZXZlbHNQZXJTZWN0aW9uOiBudW1iZXIgPSA1KTogU2VjdGlvbltdID0+IHtcbiAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0pLm1hcCgoXywgc2VjdGlvbkluZGV4KSA9PiAoe1xuICAgIGlkOiBzZWN0aW9uSW5kZXgsXG4gICAgdGl0bGU6IGBTZWN0aW9uICR7c2VjdGlvbkluZGV4ICsgMX1gLFxuICAgIGRlc2NyaXB0aW9uOiBgQ29tcGxldGUgYWxsIGxldmVscyBpbiBTZWN0aW9uICR7c2VjdGlvbkluZGV4ICsgMX1gLFxuICAgIGlzTG9ja2VkOiBzZWN0aW9uSW5kZXggIT09IDAsIC8vIE9ubHkgZmlyc3Qgc2VjdGlvbiBpcyB1bmxvY2tlZFxuICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcbiAgICBsZXZlbHM6IEFycmF5LmZyb20oeyBsZW5ndGg6IGxldmVsc1BlclNlY3Rpb24gfSkubWFwKChfLCBsZXZlbEluZGV4KSA9PiAoe1xuICAgICAgaWQ6IGxldmVsSW5kZXgsXG4gICAgICB0aXRsZTogYExldmVsICR7bGV2ZWxJbmRleCArIDF9YCxcbiAgICAgIGlzTG9ja2VkOiBsZXZlbEluZGV4ICE9PSAwLCAvLyBPbmx5IGZpcnN0IGxldmVsIGluIGVhY2ggc2VjdGlvbiBpcyB1bmxvY2tlZCBpbml0aWFsbHlcbiAgICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcbiAgICAgIGJlc3RTY29yZTogMCxcbiAgICAgIGF0dGVtcHRzOiAwLFxuICAgICAgbGFzdFBsYXllZDogbnVsbFxuICAgIH0pKVxuICB9KSk7XG59O1xuXG4vLyBHZW5lcmF0ZSBkYWlseSBxdWVzdHNcbmNvbnN0IGdlbmVyYXRlRGFpbHlRdWVzdHMgPSAoKTogRGFpbHlRdWVzdFtdID0+IHtcbiAgLy8gR2V0IHRvbW9ycm93J3MgZGF0ZSBpbiBZWVlZLU1NLUREIGZvcm1hdCAodXNpbmcgbG9jYWwgdGltZSlcbiAgY29uc3QgZXhwaXJlc0F0ID0gZ2V0VG9tb3Jyb3dEYXRlU3RyaW5nKCk7XG4gIFxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGlkOiAnc3RyZWFrLWJvbnVzJyxcbiAgICAgIHRpdGxlOiAnR2V0IDMgQ29ycmVjdCBpbiBhIFJvdycsXG4gICAgICBkZXNjcmlwdGlvbjogJ0Fuc3dlciB0aHJlZSBxdWVzdGlvbnMgY29ycmVjdGx5IGluIGEgcm93JyxcbiAgICAgIHJld2FyZDogMTAsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHRhcmdldDogMSwgLy8gSnVzdCBuZWVkcyB0byBiZSBhY2hpZXZlZCBvbmNlXG4gICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICBleHBpcmVzQXRcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAnY29tcGxldGUtZ2FtZXMnLFxuICAgICAgdGl0bGU6ICdDb21wbGV0ZSAzIEdhbWVzJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29tcGxldGUgYW55IDMgZ2FtZXMgdG9kYXkgKGFueSBzY29yZSknLFxuICAgICAgcmV3YXJkOiAxNSxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgdGFyZ2V0OiAzLFxuICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgZXhwaXJlc0F0XG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ3BlcmZlY3Qtc2NvcmUnLFxuICAgICAgdGl0bGU6ICdQZXJmZWN0IFNjb3JlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29tcGxldGUgYSBsZXZlbCB3aXRoIGEgcGVyZmVjdCBzY29yZScsXG4gICAgICByZXdhcmQ6IDIwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB0YXJnZXQ6IDEsXG4gICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICBleHBpcmVzQXRcbiAgICB9XG4gIF07XG59O1xuXG4vLyBDb2xsZWN0aW9uIG5hbWUgZm9yIHVzZXIgZ2FtZSBwcm9ncmVzc1xuY29uc3QgR0FNRV9QUk9HUkVTU19DT0xMRUNUSU9OID0gJ2dhbWVQcm9ncmVzcyc7XG5cbmV4cG9ydCBjb25zdCB1c2VHYW1lU3RvcmUgPSBjcmVhdGU8R2FtZVN0YXRlPigpKFxuICBwZXJzaXN0KFxuICAgIChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC8vIEluaXRpYWwgc3RhdGVcbiAgICAgIHByb2ZpbGU6IG51bGwsXG4gICAgICBzY29yZTogMCxcbiAgICAgIHN0cmVhazogMCxcbiAgICAgIGxhc3RTdHJlYWtEYXRlOiAnJyxcbiAgICAgIHN0cmVha1N0YXRlOiAnbm9uZScgYXMgJ25vbmUnIHwgJ2luYWN0aXZlJyB8ICdhY3RpdmUnLFxuICAgICAgdG90YWxDaGFsbGVuZ2VzQ29tcGxldGVkOiAwLFxuICAgICAgcHJvZ3Jlc3M6IHt9LFxuICAgICAgYWNoaWV2ZW1lbnRzOiBbXSxcbiAgICAgIGdhbWVBY2hpZXZlbWVudHM6IHt9LFxuICAgICAgcmVjZW50Q2hhbGxlbmdlczogW10sXG4gICAgICBcbiAgICAgIC8vIEJhc2ljIGdhbWUgYWN0aW9uc1xuICAgICAgYWRkUG9pbnRzOiAocG9pbnRzLCBnYW1lVHlwZSkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBnYW1lUHJvZ3Jlc3MgPSBzdGF0ZS5wcm9ncmVzc1tnYW1lVHlwZV07XG4gICAgICAgIGlmICghZ2FtZVByb2dyZXNzKSByZXR1cm4gc3RhdGU7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgW1hQIERlYnVnXSBBZGRpbmcgJHtwb2ludHN9IHBvaW50cyB0byAke2dhbWVUeXBlfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgW1hQIERlYnVnXSBDdXJyZW50IFhQOiAke2dhbWVQcm9ncmVzcy54cH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFByZXZlbnQgbmVnYXRpdmUgWFAgLSBjYWxjdWxhdGUgbmV3IFhQIGVuc3VyaW5nIGl0IGRvZXNuJ3QgZ28gYmVsb3cgMFxuICAgICAgICBjb25zdCBuZXdYUCA9IE1hdGgubWF4KDAsIGdhbWVQcm9ncmVzcy54cCArIHBvaW50cyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgWFAgZm9yIHRoZSBzcGVjaWZpYyBnYW1lIHR5cGVcbiAgICAgICAgY29uc3QgdXBkYXRlZEdhbWVQcm9ncmVzcyA9IHtcbiAgICAgICAgICAuLi5nYW1lUHJvZ3Jlc3MsXG4gICAgICAgICAgeHA6IG5ld1hQXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgW1hQIERlYnVnXSBOZXcgdG90YWwgWFA6ICR7dXBkYXRlZEdhbWVQcm9ncmVzcy54cH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBkYWlseSBxdWVzdCBwcm9ncmVzcyBmb3IgWFAgLSBESVJFQ1RMWSB1c2UgdGhlIGdhbWUncyB0b3RhbCBYUCB2YWx1ZSBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgY29uc3QgdXBkYXRlZFF1ZXN0cyA9IGdhbWVQcm9ncmVzcy5xdWVzdHM7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICBzY29yZTogc3RhdGUuc2NvcmUgKyBwb2ludHMsXG4gICAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnByb2dyZXNzLFxuICAgICAgICAgICAgW2dhbWVUeXBlXToge1xuICAgICAgICAgICAgICAuLi51cGRhdGVkR2FtZVByb2dyZXNzLFxuICAgICAgICAgICAgICBxdWVzdHM6IHVwZGF0ZWRRdWVzdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBTYXZlIHRvIEZpcmViYXNlIGFmdGVyIHVwZGF0aW5nIGxvY2FsIHN0YXRlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZ2V0KCkuc2F2ZVVzZXJQcm9ncmVzcygpLCAwKTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIGluY3JlYXNlU3RyZWFrOiAoKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gZ2V0VG9kYXlEYXRlU3RyaW5nKCk7XG4gICAgICAgIGxldCBuZXdTdHJlYWsgPSBzdGF0ZS5zdHJlYWs7XG4gICAgICAgIFxuICAgICAgICAvLyBDYXNlIDE6IEFscmVhZHkgbG9nZ2VkIHN0cmVhayB0b2RheSAtIGRvbid0IGluY3JlYXNlLCBqdXN0IG1ha2UgYWN0aXZlXG4gICAgICAgIGlmIChpc1NhbWVEYXkoc3RhdGUubGFzdFN0cmVha0RhdGUsIHRvZGF5KSkge1xuICAgICAgICAgIHJldHVybiB7IFxuICAgICAgICAgICAgLi4uc3RhdGUsIFxuICAgICAgICAgICAgc3RyZWFrU3RhdGU6ICdhY3RpdmUnIFxuICAgICAgICAgIH07IFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYXNlIDI6IEZpcnN0IHRpbWUgcGxheWluZyBvciBjb250aW51aW5nIHN0cmVhayBmcm9tIHllc3RlcmRheVxuICAgICAgICBpZiAoaXNDb25zZWN1dGl2ZURheShzdGF0ZS5sYXN0U3RyZWFrRGF0ZSwgdG9kYXkpIHx8ICFzdGF0ZS5sYXN0U3RyZWFrRGF0ZSkge1xuICAgICAgICAgIG5ld1N0cmVhayArPSAxO1xuICAgICAgICB9IFxuICAgICAgICAvLyBDYXNlIDM6IE1pc3NlZCBhIGRheSBvciBtb3JlLCByZXN0YXJ0IHN0cmVhayBmcm9tIDFcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbmV3U3RyZWFrID0gMTsgLy8gU3RhcnQgYSBuZXcgc3RyZWFrXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAgIHN0cmVhazogbmV3U3RyZWFrLFxuICAgICAgICAgIGxhc3RTdHJlYWtEYXRlOiB0b2RheSxcbiAgICAgICAgICBzdHJlYWtTdGF0ZTogJ2FjdGl2ZScgYXMgJ25vbmUnIHwgJ2luYWN0aXZlJyB8ICdhY3RpdmUnXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBTYXZlIHRvIEZpcmViYXNlIGFmdGVyIHVwZGF0aW5nIGxvY2FsIHN0YXRlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZ2V0KCkuc2F2ZVVzZXJQcm9ncmVzcygpLCAwKTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIHJlc2V0U3RyZWFrOiAoKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgICAgICAgIHN0cmVhazogMCxcbiAgICAgICAgICBsYXN0U3RyZWFrRGF0ZTogJycsXG4gICAgICAgICAgc3RyZWFrU3RhdGU6ICdub25lJyBhcyAnbm9uZScgfCAnaW5hY3RpdmUnIHwgJ2FjdGl2ZSdcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgdG8gRmlyZWJhc2UgYWZ0ZXIgdXBkYXRpbmcgbG9jYWwgc3RhdGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBnZXQoKS5zYXZlVXNlclByb2dyZXNzKCksIDApO1xuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9KSxcbiAgICAgIFxuICAgICAgLy8gUHJvZ3Jlc3MgdHJhY2tpbmdcbiAgICAgIGluaXRpYWxpemVHYW1lUHJvZ3Jlc3M6IChnYW1lVHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBwcm9ncmVzcyBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBnYW1lIHR5cGVcbiAgICAgICAgICBpZiAoc3RhdGUucHJvZ3Jlc3NbZ2FtZVR5cGVdICYmIHN0YXRlLnByb2dyZXNzW2dhbWVUeXBlXS5zZWN0aW9ucyAmJiBzdGF0ZS5wcm9ncmVzc1tnYW1lVHlwZV0uc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEdhbWUgcHJvZ3Jlc3MgZm9yICR7Z2FtZVR5cGV9IGFscmVhZHkgaW5pdGlhbGl6ZWQuYCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBJbml0aWFsaXppbmcgZ2FtZSBwcm9ncmVzcyBmb3IgJHtnYW1lVHlwZX1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZWZhdWx0IHNlY3Rpb25zIHdpdGggNSBzZWN0aW9ucyBhbmQgNSBsZXZlbHMgZWFjaFxuICAgICAgICAgIGNvbnN0IHNlY3Rpb25zID0gZ2VuZXJhdGVTZWN0aW9ucygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpcnN0IHNlY3Rpb24gYW5kIGZpcnN0IGxldmVsIGFyZSBhbHdheXMgdW5sb2NrZWRcbiAgICAgICAgICBpZiAoc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VjdGlvbnNbMF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNlY3Rpb25zWzBdLmxldmVscyAmJiBzZWN0aW9uc1swXS5sZXZlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWN0aW9uc1swXS5sZXZlbHNbMF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2VuZXJhdGUgZnJlc2ggZGFpbHkgcXVlc3RzIGlmIG5lZWRlZFxuICAgICAgICAgIGNvbnN0IHF1ZXN0cyA9IGdlbmVyYXRlRGFpbHlRdWVzdHMoKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgICAgLi4uc3RhdGUucHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIFtnYW1lVHlwZV06IHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucyxcbiAgICAgICAgICAgICAgICB4cDogMCxcbiAgICAgICAgICAgICAgICBxdWVzdHMsXG4gICAgICAgICAgICAgICAgY3VycmVudFNlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgY3VycmVudExldmVsOiAwLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlZExldmVsczogW11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgY29tcGxldGVMZXZlbDogKGdhbWVUeXBlOiBzdHJpbmcsIHNlY3Rpb25JZDogbnVtYmVyLCBsZXZlbElkOiBudW1iZXIsIHNjb3JlPzogbnVtYmVyKSA9PiB7XG4gICAgICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBnYW1lUHJvZ3Jlc3MgPSBzdGF0ZS5wcm9ncmVzc1tnYW1lVHlwZV07XG4gICAgICAgICAgaWYgKCFnYW1lUHJvZ3Jlc3MpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgYSBkZWVwIGNvcHkgb2Ygc2VjdGlvbnNcbiAgICAgICAgICBjb25zdCB1cGRhdGVkU2VjdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGdhbWVQcm9ncmVzcy5zZWN0aW9ucykpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgc2VjdGlvbiBhbmQgbGV2ZWxcbiAgICAgICAgICBjb25zdCBzZWN0aW9uID0gdXBkYXRlZFNlY3Rpb25zW3NlY3Rpb25JZF07XG4gICAgICAgICAgaWYgKCFzZWN0aW9uIHx8ICFzZWN0aW9uLmxldmVsc1tsZXZlbElkXSkgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBsZXZlbCBzdGF0cyAtIHRoaXMgaGFwcGVucyByZWdhcmRsZXNzIG9mIHNjb3JlXG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSBzZWN0aW9uLmxldmVsc1tsZXZlbElkXTtcbiAgICAgICAgICBsZXZlbC5hdHRlbXB0cyA9IChsZXZlbC5hdHRlbXB0cyB8fCAwKSArIDE7XG4gICAgICAgICAgbGV2ZWwubGFzdFBsYXllZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdG9yZSB0aGUgYmVzdCBzY29yZSBpZiBoaWdoZXIgdGhhbiBwcmV2aW91c1xuICAgICAgICAgIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkICYmIChsZXZlbC5iZXN0U2NvcmUgPT09IHVuZGVmaW5lZCB8fCBzY29yZSA+IGxldmVsLmJlc3RTY29yZSkpIHtcbiAgICAgICAgICAgIGxldmVsLmJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgYSB1bmlxdWUgSUQgZm9yIHRoaXMgbGV2ZWwgdG8gdHJhY2sgY29tcGxldGlvblxuICAgICAgICAgIGNvbnN0IGxldmVsS2V5ID0gYCR7c2VjdGlvbklkfS0ke2xldmVsSWR9YDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcmFjayBjb21wbGV0ZWQgbGV2ZWxzIGZvciBzdW1tYXJ5IHN0YXRzXG4gICAgICAgICAgbGV0IGNvbXBsZXRlZExldmVscyA9IFsuLi4oZ2FtZVByb2dyZXNzLmNvbXBsZXRlZExldmVscyB8fCBbXSldO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBhY2hpZXZlbWVudHMgYXJyYXlzXG4gICAgICAgICAgbGV0IGFjaGlldmVtZW50cyA9IFsuLi4oc3RhdGUuYWNoaWV2ZW1lbnRzIHx8IFtdKV07XG4gICAgICAgICAgbGV0IGdhbWVUeXBlQWNoaWV2ZW1lbnRzID0gWy4uLihzdGF0ZS5nYW1lQWNoaWV2ZW1lbnRzW2dhbWVUeXBlXSB8fCBbXSldO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyYWNrIHdoZXJlIHRoZSB1c2VyIHNob3VsZCBnbyBuZXh0IChjdXJyZW50IHBvc2l0aW9uKVxuICAgICAgICAgIGxldCBuZXh0U2VjdGlvbklkID0gc2VjdGlvbklkO1xuICAgICAgICAgIGxldCBuZXh0TGV2ZWxJZCA9IGxldmVsSWQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFyayBsZXZlbCBhcyBjb21wbGV0ZWQgaWYgc2NvcmUgaXMgYXQgbGVhc3QgODAlICh0aHJlc2hvbGQgZm9yIGNvbXBsZXRpbmcgYSBsZXZlbClcbiAgICAgICAgICBjb25zdCBpc0xldmVsQ29tcGxldGVkID0gc2NvcmUgIT09IHVuZGVmaW5lZCAmJiBzY29yZSA+PSA4MDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaXNMZXZlbENvbXBsZXRlZCkge1xuICAgICAgICAgICAgLy8gTWFyayB0aGUgbGV2ZWwgYXMgY29tcGxldGVkXG4gICAgICAgICAgICBsZXZlbC5pc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCB0byBjb21wbGV0ZWQgbGV2ZWxzIGFycmF5IGlmIG5vdCBhbHJlYWR5IHRoZXJlXG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRlZExldmVscy5pbmNsdWRlcyhsZXZlbEtleSkpIHtcbiAgICAgICAgICAgICAgY29tcGxldGVkTGV2ZWxzLnB1c2gobGV2ZWxLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgXCJQZXJmZWN0IFNjb3JlXCIgYWNoaWV2ZW1lbnQgLSBzY29yZSBtdXN0IGJlIGF0IGxlYXN0IDEwMCAoaW5jbHVkaW5nIGJvbnVzZXMpXG4gICAgICAgICAgICBpZiAoc2NvcmUgPj0gMTAwICYmICFnYW1lVHlwZUFjaGlldmVtZW50cy5pbmNsdWRlcygncGVyZmVjdC1zY29yZScpKSB7XG4gICAgICAgICAgICAgIC8vIEFkZCB0byBnYW1lLXNwZWNpZmljIGFjaGlldmVtZW50c1xuICAgICAgICAgICAgICBnYW1lVHlwZUFjaGlldmVtZW50cy5wdXNoKCdwZXJmZWN0LXNjb3JlJyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBbHNvIGFkZCB0byBnbG9iYWwgYWNoaWV2ZW1lbnRzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgIGlmICghYWNoaWV2ZW1lbnRzLmluY2x1ZGVzKCdwZXJmZWN0LXNjb3JlJykpIHtcbiAgICAgICAgICAgICAgICBhY2hpZXZlbWVudHMucHVzaCgncGVyZmVjdC1zY29yZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0FjaGlldmVtZW50XSBVbmxvY2tlZDogUGVyZmVjdCBTY29yZSBpbiAke2dhbWVUeXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5leHQgbGV2ZWwgSUQgLSBhZHZhbmNlIHRvIHRoZSBuZXh0IGxldmVsXG4gICAgICAgICAgICBpZiAobGV2ZWxJZCA8IHNlY3Rpb24ubGV2ZWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBsZXZlbCBpbiB0aGUgc2FtZSBzZWN0aW9uXG4gICAgICAgICAgICAgIG5leHRMZXZlbElkID0gbGV2ZWxJZCArIDE7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBVbmxvY2sgdGhlIG5leHQgbGV2ZWxcbiAgICAgICAgICAgICAgc2VjdGlvbi5sZXZlbHNbbmV4dExldmVsSWRdLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3QgbGV2ZWwgaW4gdGhlIHNlY3Rpb24sIG1vdmUgdG8gdGhlIG5leHQgc2VjdGlvblxuICAgICAgICAgICAgZWxzZSBpZiAobGV2ZWxJZCA9PT0gc2VjdGlvbi5sZXZlbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBzZWN0aW9uLmlzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciBcIlNlY3Rpb24gQ2hhbXBpb25cIiBhY2hpZXZlbWVudFxuICAgICAgICAgICAgICAvLyBBIHNlY3Rpb24gaXMgY29uc2lkZXJlZCBjb21wbGV0ZWQgd2hlbiBhbGwgaXRzIGxldmVscyBhcmUgY29tcGxldGVkXG4gICAgICAgICAgICAgIGNvbnN0IGlzU2VjdGlvbkNvbXBsZXRlZCA9IHNlY3Rpb24ubGV2ZWxzLmV2ZXJ5KChsdmw6IExldmVsKSA9PiBsdmwuaXNDb21wbGV0ZWQpO1xuICAgICAgICAgICAgICBpZiAoaXNTZWN0aW9uQ29tcGxldGVkICYmICFnYW1lVHlwZUFjaGlldmVtZW50cy5pbmNsdWRlcygnc2VjdGlvbi1jaGFtcGlvbicpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGdhbWUtc3BlY2lmaWMgYWNoaWV2ZW1lbnRzXG4gICAgICAgICAgICAgICAgZ2FtZVR5cGVBY2hpZXZlbWVudHMucHVzaCgnc2VjdGlvbi1jaGFtcGlvbicpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFsc28gYWRkIHRvIGdsb2JhbCBhY2hpZXZlbWVudHMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBpZiAoIWFjaGlldmVtZW50cy5pbmNsdWRlcygnc2VjdGlvbi1jaGFtcGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICBhY2hpZXZlbWVudHMucHVzaCgnc2VjdGlvbi1jaGFtcGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0FjaGlldmVtZW50XSBVbmxvY2tlZDogU2VjdGlvbiBDaGFtcGlvbiBpbiAke2dhbWVUeXBlfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHNlY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgIGlmIChzZWN0aW9uSWQgPCB1cGRhdGVkU2VjdGlvbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIG5leHRTZWN0aW9uSWQgPSBzZWN0aW9uSWQgKyAxO1xuICAgICAgICAgICAgICAgIG5leHRMZXZlbElkID0gMDsgLy8gU3RhcnQgYXQgdGhlIGZpcnN0IGxldmVsIG9mIHRoZSBuZXh0IHNlY3Rpb25cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBVbmxvY2sgdGhlIG5leHQgc2VjdGlvblxuICAgICAgICAgICAgICAgIHVwZGF0ZWRTZWN0aW9uc1tuZXh0U2VjdGlvbklkXS5pc0xvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVubG9jayB0aGUgZmlyc3QgbGV2ZWwgb2YgdGhlIG5leHQgc2VjdGlvblxuICAgICAgICAgICAgICAgIHVwZGF0ZWRTZWN0aW9uc1tuZXh0U2VjdGlvbklkXS5sZXZlbHNbMF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgcXVlc3QgcHJvZ3Jlc3MgZm9yIGdhbWUgY29tcGxldGlvblxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRRdWVzdHMgPSBnYW1lUHJvZ3Jlc3MucXVlc3RzLm1hcChxdWVzdCA9PiB7XG4gICAgICAgICAgICAvLyBGb3IgdGhlICdwZXJmZWN0LXNjb3JlJyBxdWVzdCwgY291bnQgZ2FtZXMgd2l0aCBhIHNjb3JlIG9mIGF0IGxlYXN0IDEwMCAoaW5jbHVkaW5nIGJvbnVzZXMpXG4gICAgICAgICAgICBpZiAocXVlc3QuaWQgPT09ICdwZXJmZWN0LXNjb3JlJyAmJiAhcXVlc3QuaXNDb21wbGV0ZWQgJiYgc2NvcmUgIT09IHVuZGVmaW5lZCAmJiBzY29yZSA+PSAxMDApIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3UHJvZ3Jlc3MgPSBNYXRoLm1pbihxdWVzdC5wcm9ncmVzcyArIDEsIHF1ZXN0LnRhcmdldCk7XG4gICAgICAgICAgICAgIGNvbnN0IGlzQ29tcGxldGVkID0gbmV3UHJvZ3Jlc3MgPj0gcXVlc3QudGFyZ2V0O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5xdWVzdCxcbiAgICAgICAgICAgICAgICBwcm9ncmVzczogbmV3UHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgaXNDb21wbGV0ZWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHF1ZXN0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBYUCBNYXN0ZXIgYWNoaWV2ZW1lbnRcbiAgICAgICAgICBpZiAoZ2FtZVByb2dyZXNzLnhwID49IDEwMDAgJiYgIWdhbWVUeXBlQWNoaWV2ZW1lbnRzLmluY2x1ZGVzKCd4cC1tYXN0ZXInKSkge1xuICAgICAgICAgICAgLy8gQWRkIHRvIGdhbWUtc3BlY2lmaWMgYWNoaWV2ZW1lbnRzXG4gICAgICAgICAgICBnYW1lVHlwZUFjaGlldmVtZW50cy5wdXNoKCd4cC1tYXN0ZXInKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWxzbyBhZGQgdG8gZ2xvYmFsIGFjaGlldmVtZW50cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgaWYgKCFhY2hpZXZlbWVudHMuaW5jbHVkZXMoJ3hwLW1hc3RlcicpKSB7XG4gICAgICAgICAgICAgIGFjaGlldmVtZW50cy5wdXNoKCd4cC1tYXN0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtBY2hpZXZlbWVudF0gVW5sb2NrZWQ6IFhQIE1hc3RlciBpbiAke2dhbWVUeXBlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcmVwYXJlIHVwZGF0ZWQgZ2FtZUFjaGlldmVtZW50cyBvYmplY3RcbiAgICAgICAgICBjb25zdCB1cGRhdGVkR2FtZUFjaGlldmVtZW50cyA9IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmdhbWVBY2hpZXZlbWVudHMsXG4gICAgICAgICAgICBbZ2FtZVR5cGVdOiBnYW1lVHlwZUFjaGlldmVtZW50c1xuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJlcGFyZSB1cGRhdGVkIHN0YXRlXG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBhY2hpZXZlbWVudHMsIC8vIFVwZGF0ZSBnbG9iYWwgYWNoaWV2ZW1lbnRzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBnYW1lQWNoaWV2ZW1lbnRzOiB1cGRhdGVkR2FtZUFjaGlldmVtZW50cywgLy8gVXBkYXRlIGdhbWUtc3BlY2lmaWMgYWNoaWV2ZW1lbnRzXG4gICAgICAgICAgICBwcm9ncmVzczoge1xuICAgICAgICAgICAgICAuLi5zdGF0ZS5wcm9ncmVzcyxcbiAgICAgICAgICAgICAgW2dhbWVUeXBlXToge1xuICAgICAgICAgICAgICAgIC4uLmdhbWVQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBzZWN0aW9uczogdXBkYXRlZFNlY3Rpb25zLFxuICAgICAgICAgICAgICAgIHF1ZXN0czogdXBkYXRlZFF1ZXN0cyxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRMZXZlbHMsIC8vIFVwZGF0ZSBjb21wbGV0ZWQgbGV2ZWxzIHRyYWNraW5nXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IHBvc2l0aW9uIHRvIHRoZSBuZXh0IGxldmVsXG4gICAgICAgICAgICAgICAgY3VycmVudFNlY3Rpb246IG5leHRTZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgY3VycmVudExldmVsOiBuZXh0TGV2ZWxJZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMb2cgdGhlIGxldmVsIHRyYW5zaXRpb25cbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1Byb2dyZXNzXSBBZHZhbmNlZCB0byBTZWN0aW9uICR7bmV4dFNlY3Rpb25JZH0sIExldmVsICR7bmV4dExldmVsSWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2F2ZSB0byBGaXJlYmFzZSBhZnRlciB1cGRhdGluZyBsb2NhbCBzdGF0ZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZ2V0KCkuc2F2ZVVzZXJQcm9ncmVzcygpLCAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgY2FuQWNjZXNzTGV2ZWw6IChnYW1lVHlwZTogc3RyaW5nLCBzZWN0aW9uSWQ6IG51bWJlciwgbGV2ZWxJZDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBnYW1lIHByb2dyZXNzIGV4aXN0c1xuICAgICAgICBpZiAoIXN0YXRlLnByb2dyZXNzIHx8ICFzdGF0ZS5wcm9ncmVzc1tnYW1lVHlwZV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGdhbWVQcm9ncmVzcyA9IHN0YXRlLnByb2dyZXNzW2dhbWVUeXBlXTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHNlY3Rpb25zIGFycmF5IGV4aXN0cyBhbmQgc2VjdGlvbklkIGlzIHZhbGlkXG4gICAgICAgIGlmICghZ2FtZVByb2dyZXNzLnNlY3Rpb25zIHx8ICFBcnJheS5pc0FycmF5KGdhbWVQcm9ncmVzcy5zZWN0aW9ucykgfHwgXG4gICAgICAgICAgICBzZWN0aW9uSWQgPCAwIHx8IHNlY3Rpb25JZCA+PSBnYW1lUHJvZ3Jlc3Muc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzZWN0aW9uID0gZ2FtZVByb2dyZXNzLnNlY3Rpb25zW3NlY3Rpb25JZF07XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBzZWN0aW9uIGlzIGxvY2tlZFxuICAgICAgICBpZiAoIXNlY3Rpb24gfHwgc2VjdGlvbi5pc0xvY2tlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgbGV2ZWxzIGFycmF5IGV4aXN0cyBhbmQgbGV2ZWxJZCBpcyB2YWxpZFxuICAgICAgICBpZiAoIXNlY3Rpb24ubGV2ZWxzIHx8ICFBcnJheS5pc0FycmF5KHNlY3Rpb24ubGV2ZWxzKSB8fCBcbiAgICAgICAgICAgIGxldmVsSWQgPCAwIHx8IGxldmVsSWQgPj0gc2VjdGlvbi5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsZXZlbCA9IHNlY3Rpb24ubGV2ZWxzW2xldmVsSWRdO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgbGV2ZWwgZXhpc3RzIGFuZCBpcyBub3QgbG9ja2VkXG4gICAgICAgIHJldHVybiBsZXZlbCAmJiAhbGV2ZWwuaXNMb2NrZWQ7XG4gICAgICB9LFxuICAgICAgXG4gICAgICB1bmxvY2tTZWN0aW9uOiAoZ2FtZVR5cGU6IHN0cmluZywgc2VjdGlvbklkOiBudW1iZXIpID0+IHtcbiAgICAgICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGdhbWVQcm9ncmVzcyA9IHN0YXRlLnByb2dyZXNzW2dhbWVUeXBlXTtcbiAgICAgICAgICBpZiAoIWdhbWVQcm9ncmVzcykgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTZWN0aW9ucyA9IFsuLi5nYW1lUHJvZ3Jlc3Muc2VjdGlvbnNdO1xuICAgICAgICAgIGlmICh1cGRhdGVkU2VjdGlvbnNbc2VjdGlvbklkXSkge1xuICAgICAgICAgICAgdXBkYXRlZFNlY3Rpb25zW3NlY3Rpb25JZF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEFsc28gdW5sb2NrIHRoZSBmaXJzdCBsZXZlbFxuICAgICAgICAgICAgaWYgKHVwZGF0ZWRTZWN0aW9uc1tzZWN0aW9uSWRdLmxldmVsc1swXSkge1xuICAgICAgICAgICAgICB1cGRhdGVkU2VjdGlvbnNbc2VjdGlvbklkXS5sZXZlbHNbMF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBwcm9ncmVzczoge1xuICAgICAgICAgICAgICAuLi5zdGF0ZS5wcm9ncmVzcyxcbiAgICAgICAgICAgICAgW2dhbWVUeXBlXToge1xuICAgICAgICAgICAgICAgIC4uLmdhbWVQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBzZWN0aW9uczogdXBkYXRlZFNlY3Rpb25zXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNhdmUgdG8gRmlyZWJhc2UgYWZ0ZXIgdXBkYXRpbmcgbG9jYWwgc3RhdGVcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGdldCgpLnNhdmVVc2VyUHJvZ3Jlc3MoKSwgMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIERhaWx5IHF1ZXN0c1xuICAgICAgYWRkUHJvZ3Jlc3NUb1F1ZXN0OiAoZ2FtZVR5cGU6IHN0cmluZywgcXVlc3RJZDogc3RyaW5nLCBhbW91bnQ6IG51bWJlcikgPT4ge1xuICAgICAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZ2FtZVByb2dyZXNzID0gc3RhdGUucHJvZ3Jlc3NbZ2FtZVR5cGVdO1xuICAgICAgICAgIGlmICghZ2FtZVByb2dyZXNzKSByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFF1ZXN0cyA9IGdhbWVQcm9ncmVzcy5xdWVzdHMubWFwKHF1ZXN0ID0+IHtcbiAgICAgICAgICAgIGlmIChxdWVzdC5pZCA9PT0gcXVlc3RJZCAmJiAhcXVlc3QuaXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3UHJvZ3Jlc3MgPSBNYXRoLm1pbihxdWVzdC5wcm9ncmVzcyArIGFtb3VudCwgcXVlc3QudGFyZ2V0KTtcbiAgICAgICAgICAgICAgY29uc3QgaXNDb21wbGV0ZWQgPSBuZXdQcm9ncmVzcyA+PSBxdWVzdC50YXJnZXQ7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoIXF1ZXN0LmlzQ29tcGxldGVkICYmIGlzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlWHBHcmFudCB9ID0gYXdhaXQgaW1wb3J0KCdAL3NlcnZpY2VzL3VzZXIveHBHcmFudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY3JlYXRlWHBHcmFudCh7XG4gICAgICAgICAgICAgICAgICAgICAgc291cmNlVHlwZTogJ3F1ZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VJZDogYCR7Z2FtZVR5cGV9OiR7cXVlc3QuaWR9YCxcbiAgICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHF1ZXN0LnJld2FyZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tYUF0gUXVlc3QgY29tcGxldGlvbiBncmFudCBwZXJzaXN0ZWQgZnJvbSBzdG9yZScsIHF1ZXN0LmlkKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbWFBdIEZhaWxlZCB0byBwZXJzaXN0IHF1ZXN0IGdyYW50IGZyb20gc3RvcmUgKHF1ZXVlZCBpZiBvZmZsaW5lKScsIGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucXVlc3QsXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IG5ld1Byb2dyZXNzLFxuICAgICAgICAgICAgICAgIGlzQ29tcGxldGVkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcXVlc3Q7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBwcm9ncmVzczoge1xuICAgICAgICAgICAgICAuLi5zdGF0ZS5wcm9ncmVzcyxcbiAgICAgICAgICAgICAgW2dhbWVUeXBlXToge1xuICAgICAgICAgICAgICAgIC4uLmdhbWVQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBxdWVzdHM6IHVwZGF0ZWRRdWVzdHNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2F2ZSB0byBGaXJlYmFzZSBhZnRlciB1cGRhdGluZyBsb2NhbCBzdGF0ZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZ2V0KCkuc2F2ZVVzZXJQcm9ncmVzcygpLCAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgY29tcGxldGVRdWVzdDogKGdhbWVUeXBlOiBzdHJpbmcsIHF1ZXN0SWQ6IHN0cmluZykgPT4ge1xuICAgICAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgLy8gU2tpcCBpZiBubyBwcm9ncmVzcyBkYXRhIGZvciB0aGlzIGdhbWUgdHlwZVxuICAgICAgICAgIGlmICghc3RhdGUucHJvZ3Jlc3MgfHwgIXN0YXRlLnByb2dyZXNzW2dhbWVUeXBlXSkgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgcXVlc3RzIGZvciB0aGlzIHNwZWNpZmljIGdhbWUgdHlwZVxuICAgICAgICAgIGNvbnN0IGdhbWVQcm9ncmVzcyA9IHN0YXRlLnByb2dyZXNzW2dhbWVUeXBlXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgb25seSB0aGUgc3RyZWFrLWJvbnVzIHF1ZXN0IGZvciB0aGlzIGdhbWUgdHlwZVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRRdWVzdHMgPSBnYW1lUHJvZ3Jlc3MucXVlc3RzLm1hcChxdWVzdCA9PiB7XG4gICAgICAgICAgICBpZiAocXVlc3QuaWQgPT09IHF1ZXN0SWQpIHtcbiAgICAgICAgICAgICAgaWYgKCFxdWVzdC5pc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNyZWF0ZVhwR3JhbnQgfSA9IGF3YWl0IGltcG9ydCgnQC9zZXJ2aWNlcy91c2VyL3hwR3JhbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNyZWF0ZVhwR3JhbnQoe1xuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6ICdxdWVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgc291cmNlSWQ6IGAke2dhbWVUeXBlfToke3F1ZXN0LmlkfWAsXG4gICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBxdWVzdC5yZXdhcmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbWFBdIFF1ZXN0IGNvbXBsZXRpb24gZ3JhbnQgcGVyc2lzdGVkIGZyb20gc3RvcmUgKG1hbnVhbCBjb21wbGV0ZSknLCBxdWVzdC5pZCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW1hQXSBGYWlsZWQgdG8gcGVyc2lzdCBxdWVzdCBncmFudCBmcm9tIHN0b3JlIChtYW51YWwgY29tcGxldGUpJywgZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4geyAuLi5xdWVzdCwgcHJvZ3Jlc3M6IHF1ZXN0LnRhcmdldCwgaXNDb21wbGV0ZWQ6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBxdWVzdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHVwZGF0ZWQgcHJvZ3Jlc3MgZm9yIGp1c3QgdGhpcyBnYW1lIHR5cGVcbiAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5wcm9ncmVzcyxcbiAgICAgICAgICAgIFtnYW1lVHlwZV06IHtcbiAgICAgICAgICAgICAgLi4uZ2FtZVByb2dyZXNzLFxuICAgICAgICAgICAgICBxdWVzdHM6IHVwZGF0ZWRRdWVzdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNhdmUgdG8gRmlyZWJhc2UgYWZ0ZXIgdXBkYXRpbmdcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGdldCgpLnNhdmVVc2VyUHJvZ3Jlc3MoKSwgMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHsgcHJvZ3Jlc3M6IHVwZGF0ZWRQcm9ncmVzcyB9O1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGNoZWNrQW5kUmVmcmVzaFF1ZXN0czogKGdhbWVUeXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGdhbWVQcm9ncmVzcyA9IHN0YXRlLnByb2dyZXNzW2dhbWVUeXBlXTtcbiAgICAgICAgICBpZiAoIWdhbWVQcm9ncmVzcykgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHRvZGF5ID0gZ2V0VG9kYXlEYXRlU3RyaW5nKCk7XG4gICAgICAgICAgbGV0IHF1ZXN0c05lZWRSZXNldCA9IGZhbHNlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGFueSBxdWVzdHMgaGF2ZSBleHBpcmVkXG4gICAgICAgICAgaWYgKGdhbWVQcm9ncmVzcy5xdWVzdHMgJiYgQXJyYXkuaXNBcnJheShnYW1lUHJvZ3Jlc3MucXVlc3RzKSkge1xuICAgICAgICAgICAgZ2FtZVByb2dyZXNzLnF1ZXN0cy5mb3JFYWNoKHF1ZXN0ID0+IHtcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkYXRlcyBpbiBZWVlZLU1NLUREIGZvcm1hdCAobG9jYWwgdGltZSlcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGV4cGlyYXRpb24gZGF0ZSBpcyB0b2RheSBvciBlYXJsaWVyLCB0aGUgcXVlc3QgaGFzIGV4cGlyZWRcbiAgICAgICAgICAgICAgaWYgKHF1ZXN0LmV4cGlyZXNBdCA8PSB0b2RheSkge1xuICAgICAgICAgICAgICAgIHF1ZXN0c05lZWRSZXNldCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBxdWVzdHMgYXJyYXkgZG9lc24ndCBleGlzdCBvciBpcyBub3QgYW4gYXJyYXksIHdlIG5lZWQgdG8gcmVzZXRcbiAgICAgICAgICAgIHF1ZXN0c05lZWRSZXNldCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIHF1ZXN0cyBuZWVkIHRvIGJlIHJlc2V0LCBnZW5lcmF0ZSBuZXcgb25lc1xuICAgICAgICAgIGlmIChxdWVzdHNOZWVkUmVzZXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZXNldHRpbmcgcXVlc3RzIGZvciAke2dhbWVUeXBlfSBhcyB0aGV5IGhhdmUgZXhwaXJlZGApO1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUucHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgW2dhbWVUeXBlXToge1xuICAgICAgICAgICAgICAgICAgLi4uZ2FtZVByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgcXVlc3RzOiBnZW5lcmF0ZURhaWx5UXVlc3RzKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNhdmUgdG8gRmlyZWJhc2UgYWZ0ZXIgdXBkYXRpbmcgbG9jYWwgc3RhdGVcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZ2V0KCkuc2F2ZVVzZXJQcm9ncmVzcygpLCAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgcmVzZXRRdWVzdHM6IChnYW1lVHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBnYW1lUHJvZ3Jlc3MgPSBzdGF0ZS5wcm9ncmVzc1tnYW1lVHlwZV07XG4gICAgICAgICAgaWYgKCFnYW1lUHJvZ3Jlc3MpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZW5lcmF0ZSBmcmVzaCBxdWVzdHNcbiAgICAgICAgICBjb25zdCBmcmVzaFF1ZXN0cyA9IGdlbmVyYXRlRGFpbHlRdWVzdHMoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAgICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLnByb2dyZXNzLFxuICAgICAgICAgICAgICBbZ2FtZVR5cGVdOiB7XG4gICAgICAgICAgICAgICAgLi4uZ2FtZVByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHF1ZXN0czogZnJlc2hRdWVzdHNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2F2ZSB0byBGaXJlYmFzZSBhZnRlciB1cGRhdGluZyBsb2NhbCBzdGF0ZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZ2V0KCkuc2F2ZVVzZXJQcm9ncmVzcygpLCAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFxuICAgICAgY29tcGxldGVTdHJlYWtCb251c1F1ZXN0OiAoZ2FtZVR5cGU6IHN0cmluZykgPT4ge1xuICAgICAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgLy8gU2tpcCBpZiBubyBwcm9ncmVzcyBkYXRhIGZvciB0aGlzIGdhbWUgdHlwZVxuICAgICAgICAgIGlmICghc3RhdGUucHJvZ3Jlc3MgfHwgIXN0YXRlLnByb2dyZXNzW2dhbWVUeXBlXSkgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgcXVlc3RzIGZvciB0aGlzIHNwZWNpZmljIGdhbWUgdHlwZVxuICAgICAgICAgIGNvbnN0IGdhbWVQcm9ncmVzcyA9IHN0YXRlLnByb2dyZXNzW2dhbWVUeXBlXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgb25seSB0aGUgc3RyZWFrLWJvbnVzIHF1ZXN0IGZvciB0aGlzIGdhbWUgdHlwZVxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRRdWVzdHMgPSBnYW1lUHJvZ3Jlc3MucXVlc3RzLm1hcChxdWVzdCA9PiB7XG4gICAgICAgICAgICBpZiAocXVlc3QuaWQgPT09ICdzdHJlYWstYm9udXMnICYmICFxdWVzdC5pc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnF1ZXN0LFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiAxLFxuICAgICAgICAgICAgICAgIGlzQ29tcGxldGVkOiB0cnVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcXVlc3Q7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSB1cGRhdGVkIHByb2dyZXNzIGZvciBqdXN0IHRoaXMgZ2FtZSB0eXBlXG4gICAgICAgICAgY29uc3QgdXBkYXRlZFByb2dyZXNzID0ge1xuICAgICAgICAgICAgLi4uc3RhdGUucHJvZ3Jlc3MsXG4gICAgICAgICAgICBbZ2FtZVR5cGVdOiB7XG4gICAgICAgICAgICAgIC4uLmdhbWVQcm9ncmVzcyxcbiAgICAgICAgICAgICAgcXVlc3RzOiB1cGRhdGVkUXVlc3RzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTYXZlIHRvIEZpcmViYXNlIGFmdGVyIHVwZGF0aW5nXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBnZXQoKS5zYXZlVXNlclByb2dyZXNzKCksIDApO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7IHByb2dyZXNzOiB1cGRhdGVkUHJvZ3Jlc3MgfTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBDaGFsbGVuZ2UgdHJhY2tpbmdcbiAgICAgIGFkZENoYWxsZW5nZVJlc3VsdDogKHJlc3VsdDogQ2hhbGxlbmdlUmVzdWx0KSA9PiB7XG4gICAgICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdDaGFsbGVuZ2VzID0gWy4uLnN0YXRlLnJlY2VudENoYWxsZW5nZXMsIHJlc3VsdF07XG4gICAgICAgICAgLy8gQ2FwIGF0IDUwIGNoYWxsZW5nZXMgdG8gcHJldmVudCBkb2N1bWVudCBzaXplIGlzc3Vlc1xuICAgICAgICAgIGNvbnN0IGNhcHBlZENoYWxsZW5nZXMgPSBuZXdDaGFsbGVuZ2VzLnNsaWNlKC01MCk7XG4gICAgICAgICAgcmV0dXJuIHsgcmVjZW50Q2hhbGxlbmdlczogY2FwcGVkQ2hhbGxlbmdlcyB9O1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHN0cmVhayBzaG91bGQgYmUgcmVzZXRcbiAgICAgIGNoZWNrU3RyZWFrUmVzZXQ6ICgpID0+IHtcbiAgICAgICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RyZWFrQ2hlY2tdIEN1cnJlbnQgc3RhdGU6JywgeyBcbiAgICAgICAgICAgIHN0cmVhazogc3RhdGUuc3RyZWFrLCBcbiAgICAgICAgICAgIGxhc3RTdHJlYWtEYXRlOiBzdGF0ZS5sYXN0U3RyZWFrRGF0ZSwgXG4gICAgICAgICAgICBzdHJlYWtTdGF0ZTogc3RhdGUuc3RyZWFrU3RhdGUgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBsYXN0IHN0cmVhayBkYXRlLCBubyBuZWVkIHRvIGNoZWNrXG4gICAgICAgICAgaWYgKCFzdGF0ZS5sYXN0U3RyZWFrRGF0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTdHJlYWtDaGVja10gTm8gbGFzdCBzdHJlYWsgZGF0ZSwgc2V0dGluZyB0byBub25lJyk7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgc3RyZWFrU3RhdGU6ICdub25lJyB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0b2RheSA9IGdldFRvZGF5RGF0ZVN0cmluZygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIHRoZXkgYWxyZWFkeSBwbGF5ZWQgdG9kYXksIHN0cmVhayBpcyBhY3RpdmVcbiAgICAgICAgICBpZiAoaXNTYW1lRGF5KHN0YXRlLmxhc3RTdHJlYWtEYXRlLCB0b2RheSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbU3RyZWFrQ2hlY2tdIFBsYXllZCB0b2RheSwga2VlcGluZyBzdHJlYWsgYWN0aXZlJyk7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgc3RyZWFrU3RhdGU6ICdhY3RpdmUnIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIHRoZXkgbGFzdCBwbGF5ZWQgeWVzdGVyZGF5LCBzdHJlYWsgaXMgdmFsaWQgYnV0IGluYWN0aXZlXG4gICAgICAgICAgaWYgKGlzQ29uc2VjdXRpdmVEYXkoc3RhdGUubGFzdFN0cmVha0RhdGUsIHRvZGF5KSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTdHJlYWtDaGVja10gUGxheWVkIHllc3RlcmRheSwgc3RyZWFrIGluYWN0aXZlIGJ1dCB2YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIHN0cmVha1N0YXRlOiAnaW5hY3RpdmUnIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIGl0J3MgYmVlbiBtb3JlIHRoYW4gYSBkYXkgc2luY2UgbGFzdCBwbGF5LCByZXNldCBzdHJlYWtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW1N0cmVha0NoZWNrXSBSZXNldHRpbmcgc3RyZWFrIGR1ZSB0byBpbmFjdGl2aXR5Jyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RyZWFrOiAwLFxuICAgICAgICAgICAgc3RyZWFrU3RhdGU6ICdub25lJyxcbiAgICAgICAgICAgIC8vIERvbid0IHVwZGF0ZSBsYXN0U3RyZWFrRGF0ZSBzbyB0aGV5IGNhbiBzdGlsbCBzdGFydCBhIG5ldyBzdHJlYWsgdG9kYXlcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGNoZWNrU3RyZWFrU3RhdHVzOiAoKSA9PiB7XG4gICAgICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCB0b2RheSA9IGdldFRvZGF5RGF0ZVN0cmluZygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIElmIG5vIHN0cmVhaywgc3RhdHVzIGlzIFwibm9uZVwiXG4gICAgICAgICAgaWYgKHN0YXRlLnN0cmVhayA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIHN0cmVha1N0YXRlOiAnbm9uZScgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSWYgcGxheWVkIHRvZGF5LCBzdHJlYWsgaXMgYWN0aXZlXG4gICAgICAgICAgaWYgKGlzU2FtZURheShzdGF0ZS5sYXN0U3RyZWFrRGF0ZSwgdG9kYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgc3RyZWFrU3RhdGU6ICdhY3RpdmUnIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgc3RyZWFrIGV4aXN0cyBidXQgaXMgaW5hY3RpdmVcbiAgICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSwgc3RyZWFrU3RhdGU6ICdpbmFjdGl2ZScgfTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBDb21wbGV0ZSBhIGdhbWUgYW5kIGhhbmRsZSBzdHJlYWsvWFAgdHJhY2tpbmdcbiAgICAgIGNvbXBsZXRlR2FtZTogKGdhbWVUeXBlLCBzY29yZSwgaXNDb3JyZWN0KSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGlmICghZ2FtZVR5cGUpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbR2FtZURCXSBDb21wbGV0aW5nIGdhbWU6ICR7Z2FtZVR5cGV9LCBTY29yZTogJHtzY29yZX0sIENvcnJlY3Q6ICR7aXNDb3JyZWN0fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IHBsYXllZCB0aW1lc3RhbXBcbiAgICAgICAgY29uc3QgZ2FtZVByb2dyZXNzID0gc3RhdGUucHJvZ3Jlc3NbZ2FtZVR5cGVdIHx8IHtcbiAgICAgICAgICBzZWN0aW9uczogZ2VuZXJhdGVTZWN0aW9ucygpLFxuICAgICAgICAgIHhwOiAwLFxuICAgICAgICAgIHF1ZXN0czogZ2VuZXJhdGVEYWlseVF1ZXN0cygpLFxuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uOiAwLFxuICAgICAgICAgIGN1cnJlbnRMZXZlbDogMCxcbiAgICAgICAgICBjb21wbGV0ZWRMZXZlbHM6IFtdLFxuICAgICAgICAgIGxhc3RQbGF5ZWRBdDogJydcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSB1cGRhdGVkIGdhbWUgcHJvZ3Jlc3Mgd2l0aCB0aW1lc3RhbXBcbiAgICAgICAgY29uc3QgdXBkYXRlZEdhbWVQcm9ncmVzcyA9IHtcbiAgICAgICAgICAuLi5nYW1lUHJvZ3Jlc3MsXG4gICAgICAgICAgbGFzdFBsYXllZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBzdHJlYWsgaGFuZGxpbmcgLSBJTVBPUlRBTlQ6IHN0cmVhayBpcyBub3QgcmVzZXQgb24gd3JvbmcgYW5zd2Vyc1xuICAgICAgICAvLyBJdCBvbmx5IHVwZGF0ZXMgKGluY3JlYXNlcykgd2hlbiBpdCdzIHRoZSBmaXJzdCBjb3JyZWN0IGFuc3dlciBvZiBhIG5ldyBkYXlcbiAgICAgICAgY29uc3QgdG9kYXkgPSBnZXRUb2RheURhdGVTdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgc3RyZWFrVXBkYXRlczogUGFydGlhbDxHYW1lU3RhdGU+ID0ge307XG4gICAgICAgIFxuICAgICAgICAvLyBPbmx5IGNvbnNpZGVyIHN0cmVhayB1cGRhdGVzIGZvciBjb3JyZWN0IGFuc3dlcnNcbiAgICAgICAgaWYgKGlzQ29ycmVjdCkge1xuICAgICAgICAgIGlmIChzdGF0ZS5sYXN0U3RyZWFrRGF0ZSAhPT0gdG9kYXkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGNvcnJlY3QgYW5zd2VyIG9mIGEgbmV3IGRheSAtIGluY3JlYXNlIHN0cmVha1xuICAgICAgICAgICAgc3RyZWFrVXBkYXRlcy5zdHJlYWsgPSBzdGF0ZS5zdHJlYWsgKyAxO1xuICAgICAgICAgICAgc3RyZWFrVXBkYXRlcy5sYXN0U3RyZWFrRGF0ZSA9IHRvZGF5O1xuICAgICAgICAgICAgc3RyZWFrVXBkYXRlcy5zdHJlYWtTdGF0ZSA9ICdhY3RpdmUnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW0dhbWVEQl0gSW5jcmVhc2luZyBzdHJlYWsgdG8gJHtzdHJlYWtVcGRhdGVzLnN0cmVha30gKGZpcnN0IGNvcnJlY3QgYW5zd2VyIHRvZGF5KWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IHBsYXllZCB0b2RheSBhbmQgZ290IHNvbWV0aGluZyBjb3JyZWN0IC0gc3RyZWFrIHJlbWFpbnMgYWN0aXZlXG4gICAgICAgICAgICBzdHJlYWtVcGRhdGVzLnN0cmVha1N0YXRlID0gJ2FjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgYWNoaWV2ZW1lbnRzIC0gdHJhY2sgZWFjaCBnYW1lIHR5cGUgc2VwYXJhdGVseVxuICAgICAgICBsZXQgYWNoaWV2ZW1lbnRzID0gWy4uLihzdGF0ZS5hY2hpZXZlbWVudHMgfHwgW10pXTtcbiAgICAgICAgbGV0IGdhbWVUeXBlQWNoaWV2ZW1lbnRzID0gWy4uLihzdGF0ZS5nYW1lQWNoaWV2ZW1lbnRzW2dhbWVUeXBlXSB8fCBbXSldO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIFwiRmlyc3QgU3RlcHNcIiBhY2hpZXZlbWVudCAtIGNvbXBsZXRpbmcgYW55IGdhbWVcbiAgICAgICAgaWYgKCFnYW1lVHlwZUFjaGlldmVtZW50cy5pbmNsdWRlcygnZmlyc3Qtc3RlcHMnKSkge1xuICAgICAgICAgIC8vIEFkZCB0byBnYW1lLXNwZWNpZmljIGFjaGlldmVtZW50c1xuICAgICAgICAgIGdhbWVUeXBlQWNoaWV2ZW1lbnRzLnB1c2goJ2ZpcnN0LXN0ZXBzJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxzbyBhZGQgdG8gZ2xvYmFsIGFjaGlldmVtZW50cyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgIGlmICghYWNoaWV2ZW1lbnRzLmluY2x1ZGVzKCdmaXJzdC1zdGVwcycpKSB7XG4gICAgICAgICAgICBhY2hpZXZlbWVudHMucHVzaCgnZmlyc3Qtc3RlcHMnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYFtBY2hpZXZlbWVudF0gVW5sb2NrZWQ6IEZpcnN0IFN0ZXBzIGluICR7Z2FtZVR5cGV9IC0gQ29tcGxldGVkIHlvdXIgZmlyc3QgZ2FtZSFgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIFwiUGVyZmVjdCBTY29yZVwiIGFjaGlldmVtZW50IC0gc2NvcmUgbXVzdCBiZSBhdCBsZWFzdCAxMDAgKGluY2x1ZGluZyBib251c2VzKVxuICAgICAgICBpZiAoc2NvcmUgPj0gMTAwICYmICFnYW1lVHlwZUFjaGlldmVtZW50cy5pbmNsdWRlcygncGVyZmVjdC1zY29yZScpKSB7XG4gICAgICAgICAgLy8gQWRkIHRvIGdhbWUtc3BlY2lmaWMgYWNoaWV2ZW1lbnRzXG4gICAgICAgICAgZ2FtZVR5cGVBY2hpZXZlbWVudHMucHVzaCgncGVyZmVjdC1zY29yZScpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFsc28gYWRkIHRvIGdsb2JhbCBhY2hpZXZlbWVudHMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICBpZiAoIWFjaGlldmVtZW50cy5pbmNsdWRlcygncGVyZmVjdC1zY29yZScpKSB7XG4gICAgICAgICAgICBhY2hpZXZlbWVudHMucHVzaCgncGVyZmVjdC1zY29yZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0FjaGlldmVtZW50XSBVbmxvY2tlZDogUGVyZmVjdCBTY29yZSBpbiAke2dhbWVUeXBlfSAtIFNjb3JlZCAxMDAlIG9yIGhpZ2hlciFgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIFwiU3RyZWFrIE1hc3RlclwiIGFjaGlldmVtZW50IC0gbWFpbnRhaW4gYSA3LWRheSBzdHJlYWtcbiAgICAgICAgLy8gTm90ZTogU3RyZWFrIE1hc3RlciBpcyBhIGdsb2JhbCBhY2hpZXZlbWVudCwgbm90IGdhbWUtc3BlY2lmaWNcbiAgICAgICAgaWYgKHN0cmVha1VwZGF0ZXMuc3RyZWFrICE9PSB1bmRlZmluZWQgJiYgc3RyZWFrVXBkYXRlcy5zdHJlYWsgPj0gNyAmJiAhYWNoaWV2ZW1lbnRzLmluY2x1ZGVzKCdzdHJlYWstbWFzdGVyJykpIHtcbiAgICAgICAgICAvLyBBZGQgZGlyZWN0bHkgdG8gZ2xvYmFsIGFjaGlldmVtZW50c1xuICAgICAgICAgIGFjaGlldmVtZW50cy5wdXNoKCdzdHJlYWstbWFzdGVyJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQnV0IGFsc28gYWRkIHRvIGdhbWUtc3BlY2lmaWMgYWNoaWV2ZW1lbnRzIGZvciB0aGUgY3VycmVudCBnYW1lIHR5cGVcbiAgICAgICAgICBpZiAoIWdhbWVUeXBlQWNoaWV2ZW1lbnRzLmluY2x1ZGVzKCdzdHJlYWstbWFzdGVyJykpIHtcbiAgICAgICAgICAgIGdhbWVUeXBlQWNoaWV2ZW1lbnRzLnB1c2goJ3N0cmVhay1tYXN0ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coJ1tBY2hpZXZlbWVudF0gVW5sb2NrZWQ6IFN0cmVhayBNYXN0ZXIgLSBNYWludGFpbmVkIGEgNy1kYXkgc3RyZWFrIScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQcmVwYXJlIHVwZGF0ZWQgZ2FtZUFjaGlldmVtZW50cyBvYmplY3RcbiAgICAgICAgY29uc3QgdXBkYXRlZEdhbWVBY2hpZXZlbWVudHMgPSB7XG4gICAgICAgICAgLi4uc3RhdGUuZ2FtZUFjaGlldmVtZW50cyxcbiAgICAgICAgICBbZ2FtZVR5cGVdOiBnYW1lVHlwZUFjaGlldmVtZW50c1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb2dyZXNzIHdpdGggdGhlIGdhbWUgcHJvZ3Jlc3NcbiAgICAgICAgY29uc3QgdXBkYXRlZFByb2dyZXNzID0ge1xuICAgICAgICAgIC4uLnN0YXRlLnByb2dyZXNzLFxuICAgICAgICAgIFtnYW1lVHlwZV06IHVwZGF0ZWRHYW1lUHJvZ3Jlc3NcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIGNoYWxsZW5nZSByZXN1bHQgcmVjb3JkXG4gICAgICAgIGNvbnN0IGNoYWxsZW5nZVJlc3VsdDogQ2hhbGxlbmdlUmVzdWx0ID0ge1xuICAgICAgICAgIGlkOiBgJHtnYW1lVHlwZX0tJHtEYXRlLm5vdygpfWAsXG4gICAgICAgICAgY2hhbGxlbmdlVHlwZTogZ2FtZVR5cGUgYXMgJ21ha2Utc2VudGVuY2UnIHwgJ211bHRpcGxlLWNob2ljZScgfCAnY29udmVyc2F0aW9uJyxcbiAgICAgICAgICBzY29yZSxcbiAgICAgICAgICBtYXhTY29yZTogMTAwLFxuICAgICAgICAgIGNvbXBsZXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZHVyYXRpb246IDAsIC8vIFRPRE86IFRyYWNrIGFjdHVhbCBkdXJhdGlvblxuICAgICAgICAgIGlzQ29ycmVjdCxcbiAgICAgICAgICBnYW1lVHlwZVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHRvIHJlY2VudCBjaGFsbGVuZ2VzXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRSZWNlbnRDaGFsbGVuZ2VzID0gWy4uLnN0YXRlLnJlY2VudENoYWxsZW5nZXMsIGNoYWxsZW5nZVJlc3VsdF07XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgdGhlIGZpbmFsIHN0YXRlIHVwZGF0ZXNcbiAgICAgICAgY29uc3QgZ2FtZVVwZGF0ZXMgPSB7XG4gICAgICAgICAgcHJvZ3Jlc3M6IHVwZGF0ZWRQcm9ncmVzcyxcbiAgICAgICAgICBhY2hpZXZlbWVudHMsIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgZ2FtZUFjaGlldmVtZW50czogdXBkYXRlZEdhbWVBY2hpZXZlbWVudHMsXG4gICAgICAgICAgdG90YWxDaGFsbGVuZ2VzQ29tcGxldGVkOiBzdGF0ZS50b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQgKyAxLFxuICAgICAgICAgIHJlY2VudENoYWxsZW5nZXM6IHVwZGF0ZWRSZWNlbnRDaGFsbGVuZ2VzLFxuICAgICAgICAgIC4uLnN0cmVha1VwZGF0ZXNcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgdG8gZGF0YWJhc2VcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBnZXQoKS5zYXZlVXNlclByb2dyZXNzKCksIDApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGdhbWVVcGRhdGVzO1xuICAgICAgfSksXG4gICAgICBcbiAgICAgIC8vIFNhdmUgdXNlciBwcm9ncmVzcyB0byBkYXRhYmFzZSB3aXRoIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICAgICAgc2F2ZVVzZXJQcm9ncmVzczogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW0RhdGFiYXNlXSBDYW5ub3Qgc2F2ZTogTm8gYXV0aGVudGljYXRlZCB1c2VyJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbRGF0YWJhc2VdIFNhdmluZyB1c2VyIHByb2dyZXNzIHRvIEZpcmVzdG9yZS4uLicpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgdXNlciBkb2N1bWVudCByZWZlcmVuY2VcbiAgICAgICAgICBjb25zdCB1c2VyUHJvZ3Jlc3NSZWYgPSBkb2MoZGIsIEdBTUVfUFJPR1JFU1NfQ09MTEVDVElPTiwgdXNlci51aWQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByZXBhcmUgZGF0YSB0byBzYXZlIC0gZW5zdXJlIGFsbCBmaWVsZHMgZXhpc3RcbiAgICAgICAgICBjb25zdCBkYXRhVG9TYXZlID0ge1xuICAgICAgICAgICAgLy8gVXNlciBwcm9maWxlXG4gICAgICAgICAgICBwcm9maWxlOiBnZXQoKS5wcm9maWxlLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBHYW1lIHN0YXRpc3RpY3NcbiAgICAgICAgICAgIHNjb3JlOiBnZXQoKS5zY29yZSB8fCAwLFxuICAgICAgICAgICAgc3RyZWFrOiBnZXQoKS5zdHJlYWsgfHwgMCxcbiAgICAgICAgICAgIGxhc3RTdHJlYWtEYXRlOiBnZXQoKS5sYXN0U3RyZWFrRGF0ZSB8fCAnJyxcbiAgICAgICAgICAgIHN0cmVha1N0YXRlOiBnZXQoKS5zdHJlYWtTdGF0ZSB8fCAnbm9uZScsXG4gICAgICAgICAgICB0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQ6IGdldCgpLnRvdGFsQ2hhbGxlbmdlc0NvbXBsZXRlZCB8fCAwLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBY2hpZXZlbWVudHNcbiAgICAgICAgICAgIGFjaGlldmVtZW50czogZ2V0KCkuYWNoaWV2ZW1lbnRzIHx8IFtdLFxuICAgICAgICAgICAgZ2FtZUFjaGlldmVtZW50czogZ2V0KCkuZ2FtZUFjaGlldmVtZW50cyB8fCB7fSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hhbGxlbmdlIGhpc3RvcnlcbiAgICAgICAgICAgIHJlY2VudENoYWxsZW5nZXM6IGdldCgpLnJlY2VudENoYWxsZW5nZXMgfHwgW10sXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEdhbWUgcHJvZ3Jlc3MgZGF0YVxuICAgICAgICAgICAgcHJvZ3Jlc3M6IGdldCgpLnByb2dyZXNzIHx8IHt9LFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNZXRhZGF0YVxuICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvZyBhIHN1bW1hcnkgb2Ygd2hhdCdzIGJlaW5nIHNhdmVkXG4gICAgICAgICAgY29uc29sZS5sb2coYFtEYXRhYmFzZV0gU2F2aW5nIC0gU2NvcmU6ICR7ZGF0YVRvU2F2ZS5zY29yZX0sIFN0cmVhazogJHtkYXRhVG9TYXZlLnN0cmVha30sIEFjaGlldmVtZW50czogJHtkYXRhVG9TYXZlLmFjaGlldmVtZW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGVlcCBjbG9uZSB0byBhdm9pZCBGaXJlYmFzZSB3YXJuaW5ncyBhYm91dCBvYmplY3RzIHdpdGggY3VzdG9tIHByb3RvdHlwZXNcbiAgICAgICAgICBjb25zdCBjbGVhbkRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGFUb1NhdmUpKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVc2UgbWVyZ2UgdG8gYXZvaWQgb3ZlcndyaXRpbmcgYW55IGZpZWxkcyBub3QgaW5jbHVkZWQgaW4gY3VycmVudCBzdGF0ZVxuICAgICAgICAgIGF3YWl0IHNldERvYyh1c2VyUHJvZ3Jlc3NSZWYsIGNsZWFuRGF0YSwgeyBtZXJnZTogdHJ1ZSB9KTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW0RhdGFiYXNlXSBTdWNjZXNzZnVsbHkgc2F2ZWQgdXNlciBwcm9ncmVzcyB0byBGaXJlc3RvcmUnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRGF0YWJhc2VdIEVycm9yIHNhdmluZyB1c2VyIHByb2dyZXNzOicsIGVycm9yKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gc2F2ZSBhZ2FpbiBhZnRlciBhIGRlbGF5XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0RhdGFiYXNlXSBSZXRyeWluZyBmYWlsZWQgc2F2ZSBvcGVyYXRpb24uLi4nKTtcbiAgICAgICAgICAgIGdldCgpLnNhdmVVc2VyUHJvZ3Jlc3MoKTtcbiAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gVXNlci1zcGVjaWZpYyBwcm9ncmVzc1xuICAgICAgbG9hZFVzZXJQcm9ncmVzczogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tBdXRoXSBObyBhdXRoZW50aWNhdGVkIHVzZXIgZm91bmQgd2hlbiB0cnlpbmcgdG8gbG9hZCBwcm9ncmVzcycpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0F1dGhdIExvYWRpbmcgcHJvZ3Jlc3MgZm9yIHVzZXI6ICR7dXNlci51aWR9YCk7XG4gICAgICAgICAgY29uc3QgdXNlclByb2dyZXNzUmVmID0gZG9jKGRiLCBHQU1FX1BST0dSRVNTX0NPTExFQ1RJT04sIHVzZXIudWlkKTtcbiAgICAgICAgICBjb25zdCB1c2VyUHJvZ3Jlc3NEb2MgPSBhd2FpdCBnZXREb2ModXNlclByb2dyZXNzUmVmKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodXNlclByb2dyZXNzRG9jLmV4aXN0cygpKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdXNlclByb2dyZXNzRG9jLmRhdGEoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBwcm9maWxlOiBkYXRhLnByb2ZpbGUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgc2NvcmU6IGRhdGEuc2NvcmUgfHwgMCxcbiAgICAgICAgICAgICAgc3RyZWFrOiBkYXRhLnN0cmVhayB8fCAwLFxuICAgICAgICAgICAgICBsYXN0U3RyZWFrRGF0ZTogZGF0YS5sYXN0U3RyZWFrRGF0ZSB8fCAnJyxcbiAgICAgICAgICAgICAgc3RyZWFrU3RhdGU6IGRhdGEuc3RyZWFrU3RhdGUgfHwgJ25vbmUnLFxuICAgICAgICAgICAgICB0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQ6IGRhdGEudG90YWxDaGFsbGVuZ2VzQ29tcGxldGVkIHx8IDAsXG4gICAgICAgICAgICAgIGFjaGlldmVtZW50czogZGF0YS5hY2hpZXZlbWVudHMgfHwgW10sXG4gICAgICAgICAgICAgIGdhbWVBY2hpZXZlbWVudHM6IGRhdGEuZ2FtZUFjaGlldmVtZW50cyB8fCB7fSxcbiAgICAgICAgICAgICAgcmVjZW50Q2hhbGxlbmdlczogZGF0YS5yZWNlbnRDaGFsbGVuZ2VzIHx8IFtdLFxuICAgICAgICAgICAgICBwcm9ncmVzczogZGF0YS5wcm9ncmVzcyB8fCB7fVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0F1dGhdIFN1Y2Nlc3NmdWxseSBsb2FkZWQgdXNlciBwcm9ncmVzcyBmcm9tIEZpcmVzdG9yZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0F1dGhdIE5vIHNhdmVkIHByb2dyZXNzIGZvdW5kIGZvciB1c2VyLiBJbml0aWFsaXppbmcgbmV3IHByb2dyZXNzLicpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgaW5pdGlhbCBnYW1lIHByb2dyZXNzIHN0cnVjdHVyZVxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFByb2dyZXNzID0ge1xuICAgICAgICAgICAgICAnbWFrZS1zZW50ZW5jZSc6IHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uczogZ2VuZXJhdGVTZWN0aW9ucygpLFxuICAgICAgICAgICAgICAgIHhwOiAwLFxuICAgICAgICAgICAgICAgIHF1ZXN0czogZ2VuZXJhdGVEYWlseVF1ZXN0cygpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uOiAwLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbDogMCxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRMZXZlbHM6IFtdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICdtdWx0aXBsZS1jaG9pY2UnOiB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnM6IGdlbmVyYXRlU2VjdGlvbnMoKSxcbiAgICAgICAgICAgICAgICB4cDogMCxcbiAgICAgICAgICAgICAgICBxdWVzdHM6IGdlbmVyYXRlRGFpbHlRdWVzdHMoKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbjogMCxcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgY29tcGxldGVkTGV2ZWxzOiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGaXJzdCwgdW5sb2NrIHRoZSBmaXJzdCBsZXZlbCBvZiBlYWNoIGdhbWUgdHlwZVxuICAgICAgICAgICAgZm9yIChjb25zdCBnYW1lVHlwZSBvZiBPYmplY3Qua2V5cyhpbml0aWFsUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgIGlmIChpbml0aWFsUHJvZ3Jlc3NbZ2FtZVR5cGVdLnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsUHJvZ3Jlc3NbZ2FtZVR5cGVdLnNlY3Rpb25zWzBdLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxQcm9ncmVzc1tnYW1lVHlwZV0uc2VjdGlvbnNbMF0ubGV2ZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGluaXRpYWxQcm9ncmVzc1tnYW1lVHlwZV0uc2VjdGlvbnNbMF0ubGV2ZWxzWzBdLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSBpbml0aWFsIHVzZXIgcHJvZmlsZVxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFByb2ZpbGU6IFVzZXJQcm9maWxlID0ge1xuICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogdXNlci5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgICAgICAgIHBob3RvVVJMOiB1c2VyLnBob3RvVVJMLFxuICAgICAgICAgICAgICBqb2luRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICBsYXN0QWN0aXZlRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICBncmFkZUxldmVsOiBudWxsLFxuICAgICAgICAgICAgICBwcmVmZXJlbmNlczoge1xuICAgICAgICAgICAgICAgIGVtYWlsTm90aWZpY2F0aW9uczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGFpbHlSZW1pbmRlcjogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgaW5pdGlhbCBzdGF0ZSB0byB1cGRhdGUgbG9jYWxseVxuICAgICAgICAgICAgY29uc3QgbmV3VXNlckRhdGEgPSB7XG4gICAgICAgICAgICAgIHByb2ZpbGU6IGluaXRpYWxQcm9maWxlLFxuICAgICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgICAgc3RyZWFrOiAwLFxuICAgICAgICAgICAgICBsYXN0U3RyZWFrRGF0ZTogJycsXG4gICAgICAgICAgICAgIHN0cmVha1N0YXRlOiAnbm9uZScsXG4gICAgICAgICAgICAgIHRvdGFsQ2hhbGxlbmdlc0NvbXBsZXRlZDogMCxcbiAgICAgICAgICAgICAgYWNoaWV2ZW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgZ2FtZUFjaGlldmVtZW50czoge30sXG4gICAgICAgICAgICAgIHJlY2VudENoYWxsZW5nZXM6IFtdLFxuICAgICAgICAgICAgICBwcm9ncmVzczogaW5pdGlhbFByb2dyZXNzLFxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgIHVzZXJJZDogdXNlci51aWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsb2NhbCBzdGF0ZVxuICAgICAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAuLi5uZXdVc2VyRGF0YVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IFNhdmUgdGhlIGluaXRpYWwgZGF0YSB0byBGaXJlc3RvcmUgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgdXNlciBoYXMgYSBnYW1lUHJvZ3Jlc3MgZG9jdW1lbnQgZnJvbSB0aGUgc3RhcnRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHNldERvYyh1c2VyUHJvZ3Jlc3NSZWYsIG5ld1VzZXJEYXRhKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tBdXRoXSBTdWNjZXNzZnVsbHkgY3JlYXRlZCBuZXcgdXNlciBwcm9ncmVzcyBkb2N1bWVudCBpbiBGaXJlc3RvcmUnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBdXRoXSBFcnJvciBjcmVhdGluZyBpbml0aWFsIHByb2dyZXNzIGRvY3VtZW50OicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgc3RyZWFrIHNob3VsZCBiZSByZXNldCBhZnRlciBsb2FkaW5nIGRhdGFcbiAgICAgICAgICBnZXQoKS5jaGVja1N0cmVha1Jlc2V0KCk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW0F1dGhdIEVycm9yIGxvYWRpbmcgdXNlciBwcm9ncmVzczonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSBnYW1lIHByb2dyZXNzIGV4aXN0cyBmb3IgYSBnaXZlbiBnYW1lIHR5cGVcbiAgICAgIGVuc3VyZUdhbWVQcm9ncmVzc0V4aXN0czogKGdhbWVUeXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgIGlmICghc3RhdGUucHJvZ3Jlc3NbZ2FtZVR5cGVdKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9ncmVzcyA9IHtcbiAgICAgICAgICAgICAgc2VjdGlvbnM6IGdlbmVyYXRlU2VjdGlvbnMoKSxcbiAgICAgICAgICAgICAgeHA6IDAsXG4gICAgICAgICAgICAgIHF1ZXN0czogZ2VuZXJhdGVEYWlseVF1ZXN0cygpLFxuICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbjogMCxcbiAgICAgICAgICAgICAgY3VycmVudExldmVsOiAwLFxuICAgICAgICAgICAgICBjb21wbGV0ZWRMZXZlbHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwcm9ncmVzczoge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLnByb2dyZXNzLFxuICAgICAgICAgICAgICAgIFtnYW1lVHlwZV06IG5ld1Byb2dyZXNzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICAvLyBQcm9maWxlIG1hbmFnZW1lbnRcbiAgICAgIHVwZGF0ZVVzZXJQcm9maWxlOiAodXBkYXRlczogUGFydGlhbDxVc2VyUHJvZmlsZT4pID0+IHtcbiAgICAgICAgc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgICBwcm9maWxlOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5wcm9maWxlLFxuICAgICAgICAgICAgLi4udXBkYXRlc1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICB9KSxcbiAgICB7XG4gICAgICBuYW1lOiAnZ2FtZS1zdG9yYWdlJyxcbiAgICAgIC8vIERvbid0IHBlcnNpc3QgdXNlciBwcm9ncmVzcyBmcm9tIGxvY2FsU3RvcmFnZSB0byBhdm9pZCBoeWRyYXRpb24gaXNzdWVzXG4gICAgICBwYXJ0aWFsaXplOiAoc3RhdGUpID0+ICh7fSksXG4gICAgICAvLyBPbmx5IGVuYWJsZSBzdG9yYWdlIG9uIHRoZSBjbGllbnQgc2lkZVxuICAgICAgc2tpcEh5ZHJhdGlvbjogdHJ1ZVxuICAgIH1cbiAgKVxuKTsiXSwibmFtZXMiOlsiY3JlYXRlIiwicGVyc2lzdCIsImRvYyIsImdldERvYyIsInNldERvYyIsImRiIiwiYXV0aCIsImdldFRvZGF5RGF0ZVN0cmluZyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImlzQ29uc2VjdXRpdmVEYXkiLCJwcmV2aW91c0RhdGUiLCJjdXJyZW50RGF0ZSIsInByZXYiLCJjdXJyIiwic2V0SG91cnMiLCJ0aW1lRGlmZiIsImdldFRpbWUiLCJkYXlzRGlmZiIsIk1hdGgiLCJyb3VuZCIsImlzU2FtZURheSIsImRhdGVTdHIxIiwiZGF0ZVN0cjIiLCJnZXRUb21vcnJvd0RhdGVTdHJpbmciLCJ0b21vcnJvdyIsInNldERhdGUiLCJnZXREYXRlIiwiZ2VuZXJhdGVTZWN0aW9ucyIsImNvdW50IiwibGV2ZWxzUGVyU2VjdGlvbiIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsIm1hcCIsIl8iLCJzZWN0aW9uSW5kZXgiLCJpZCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJpc0xvY2tlZCIsImlzQ29tcGxldGVkIiwibGV2ZWxzIiwibGV2ZWxJbmRleCIsImJlc3RTY29yZSIsImF0dGVtcHRzIiwibGFzdFBsYXllZCIsImdlbmVyYXRlRGFpbHlRdWVzdHMiLCJleHBpcmVzQXQiLCJyZXdhcmQiLCJwcm9ncmVzcyIsInRhcmdldCIsIkdBTUVfUFJPR1JFU1NfQ09MTEVDVElPTiIsInVzZUdhbWVTdG9yZSIsInNldCIsImdldCIsInByb2ZpbGUiLCJzY29yZSIsInN0cmVhayIsImxhc3RTdHJlYWtEYXRlIiwic3RyZWFrU3RhdGUiLCJ0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQiLCJhY2hpZXZlbWVudHMiLCJnYW1lQWNoaWV2ZW1lbnRzIiwicmVjZW50Q2hhbGxlbmdlcyIsImFkZFBvaW50cyIsInBvaW50cyIsImdhbWVUeXBlIiwic3RhdGUiLCJnYW1lUHJvZ3Jlc3MiLCJjb25zb2xlIiwibG9nIiwieHAiLCJuZXdYUCIsIm1heCIsInVwZGF0ZWRHYW1lUHJvZ3Jlc3MiLCJ1cGRhdGVkUXVlc3RzIiwicXVlc3RzIiwibmV3U3RhdGUiLCJzZXRUaW1lb3V0Iiwic2F2ZVVzZXJQcm9ncmVzcyIsImluY3JlYXNlU3RyZWFrIiwidG9kYXkiLCJuZXdTdHJlYWsiLCJyZXNldFN0cmVhayIsImluaXRpYWxpemVHYW1lUHJvZ3Jlc3MiLCJzZWN0aW9ucyIsImN1cnJlbnRTZWN0aW9uIiwiY3VycmVudExldmVsIiwiY29tcGxldGVkTGV2ZWxzIiwiY29tcGxldGVMZXZlbCIsInNlY3Rpb25JZCIsImxldmVsSWQiLCJ1cGRhdGVkU2VjdGlvbnMiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJzZWN0aW9uIiwibGV2ZWwiLCJ1bmRlZmluZWQiLCJsZXZlbEtleSIsImdhbWVUeXBlQWNoaWV2ZW1lbnRzIiwibmV4dFNlY3Rpb25JZCIsIm5leHRMZXZlbElkIiwiaXNMZXZlbENvbXBsZXRlZCIsImluY2x1ZGVzIiwicHVzaCIsImlzU2VjdGlvbkNvbXBsZXRlZCIsImV2ZXJ5IiwibHZsIiwicXVlc3QiLCJuZXdQcm9ncmVzcyIsIm1pbiIsInVwZGF0ZWRHYW1lQWNoaWV2ZW1lbnRzIiwiY2FuQWNjZXNzTGV2ZWwiLCJpc0FycmF5IiwidW5sb2NrU2VjdGlvbiIsImFkZFByb2dyZXNzVG9RdWVzdCIsInF1ZXN0SWQiLCJhbW91bnQiLCJjcmVhdGVYcEdyYW50Iiwic291cmNlVHlwZSIsInNvdXJjZUlkIiwiZSIsIndhcm4iLCJjb21wbGV0ZVF1ZXN0IiwidXBkYXRlZFByb2dyZXNzIiwiY2hlY2tBbmRSZWZyZXNoUXVlc3RzIiwicXVlc3RzTmVlZFJlc2V0IiwiZm9yRWFjaCIsInJlc2V0UXVlc3RzIiwiZnJlc2hRdWVzdHMiLCJjb21wbGV0ZVN0cmVha0JvbnVzUXVlc3QiLCJhZGRDaGFsbGVuZ2VSZXN1bHQiLCJyZXN1bHQiLCJuZXdDaGFsbGVuZ2VzIiwiY2FwcGVkQ2hhbGxlbmdlcyIsInNsaWNlIiwiY2hlY2tTdHJlYWtSZXNldCIsImNoZWNrU3RyZWFrU3RhdHVzIiwiY29tcGxldGVHYW1lIiwiaXNDb3JyZWN0IiwibGFzdFBsYXllZEF0Iiwic3RyZWFrVXBkYXRlcyIsImNoYWxsZW5nZVJlc3VsdCIsIm5vdyIsImNoYWxsZW5nZVR5cGUiLCJtYXhTY29yZSIsImNvbXBsZXRlZEF0IiwiZHVyYXRpb24iLCJ1cGRhdGVkUmVjZW50Q2hhbGxlbmdlcyIsImdhbWVVcGRhdGVzIiwidXNlciIsImN1cnJlbnRVc2VyIiwiZXJyb3IiLCJ1c2VyUHJvZ3Jlc3NSZWYiLCJ1aWQiLCJkYXRhVG9TYXZlIiwidXBkYXRlZEF0IiwiY2xlYW5EYXRhIiwibWVyZ2UiLCJsb2FkVXNlclByb2dyZXNzIiwidXNlclByb2dyZXNzRG9jIiwiZXhpc3RzIiwiZGF0YSIsImluaXRpYWxQcm9ncmVzcyIsIk9iamVjdCIsImtleXMiLCJpbml0aWFsUHJvZmlsZSIsImRpc3BsYXlOYW1lIiwiZW1haWwiLCJwaG90b1VSTCIsImpvaW5EYXRlIiwibGFzdEFjdGl2ZURhdGUiLCJncmFkZUxldmVsIiwicHJlZmVyZW5jZXMiLCJlbWFpbE5vdGlmaWNhdGlvbnMiLCJkYWlseVJlbWluZGVyIiwibmV3VXNlckRhdGEiLCJjcmVhdGVkQXQiLCJ1c2VySWQiLCJlbnN1cmVHYW1lUHJvZ3Jlc3NFeGlzdHMiLCJ1cGRhdGVVc2VyUHJvZmlsZSIsInVwZGF0ZXMiLCJuYW1lIiwicGFydGlhbGl6ZSIsInNraXBIeWRyYXRpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/gameStore.ts\n"));

/***/ })

});