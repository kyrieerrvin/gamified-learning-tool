"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/challenges/make-sentence/page",{

/***/ "(app-pages-browser)/./src/services/nlp/index.ts":
/*!***********************************!*\
  !*** ./src/services/nlp/index.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeSentence: () => (/* binding */ analyzeSentence),\n/* harmony export */   checkNlpHealth: () => (/* binding */ checkNlpHealth),\n/* harmony export */   createCustomGame: () => (/* binding */ createCustomGame),\n/* harmony export */   fetchNlpGameData: () => (/* binding */ fetchNlpGameData),\n/* harmony export */   fetchSentenceWords: () => (/* binding */ fetchSentenceWords),\n/* harmony export */   verifyAnswer: () => (/* binding */ verifyAnswer),\n/* harmony export */   verifySentence: () => (/* binding */ verifySentence)\n/* harmony export */ });\n/* harmony import */ var _lib_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/config */ \"(app-pages-browser)/./src/lib/config.ts\");\n/* harmony import */ var _utils_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/utils/api */ \"(app-pages-browser)/./src/utils/api.ts\");\n/* harmony import */ var _data_mock_posData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/mock/posData */ \"(app-pages-browser)/./src/data/mock/posData.ts\");\n// src/services/nlp/index.ts\n/* \n * NLP service integration for Tagalog language analysis\n */ \n\n\n// Helper function to get the NLP API URL\nfunction getNlpApiUrl() {\n    return _lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.API_BASE_URL;\n}\n/**\n * Fetches game data from the NLP service\n * @param customSentence Optional custom sentence to use\n * @returns Promise with game data\n */ async function fetchNlpGameData(customSentence, difficulty) {\n    try {\n        // Create the URL with query parameters\n        let urlParams = new URLSearchParams();\n        if (customSentence) {\n            urlParams.append('sentence', customSentence);\n        }\n        if (difficulty) {\n            urlParams.append('difficulty', difficulty);\n        }\n        // Try using the Next.js API proxy endpoint first\n        const proxyUrl = \"\".concat(_lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.POS_GAME_PROXY).concat(urlParams.toString() ? \"?\".concat(urlParams.toString()) : '');\n        try {\n            console.log(\"Attempting to fetch game data via Next.js proxy: \".concat(proxyUrl));\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiGet)(proxyUrl);\n        } catch (proxyError) {\n            console.warn(\"Next.js proxy route failed, trying direct API:\", proxyError);\n            // Fall back to direct API connection\n            const directUrl = \"\".concat(_lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.CALAMANCY_API).concat(urlParams.toString() ? \"?\".concat(urlParams.toString()) : '');\n            console.log(\"Fetching NLP game data directly from: \".concat(directUrl));\n            try {\n                return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiGet)(directUrl);\n            } catch (directError) {\n                console.warn(\"Direct API connection failed:\", directError);\n                throw directError; // Re-throw to trigger mock data fallback\n            }\n        }\n    } catch (error) {\n        console.error(\"Error fetching game data from both sources, using mock data:\", error);\n        // Final fallback to mock data\n        console.log(\"Using mock POS game data as ultimate fallback\");\n        return _data_mock_posData__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n    }\n}\n/**\n * Submit a custom sentence to create a game\n * @param sentence The custom Tagalog sentence to use\n * @returns Promise with game data\n */ async function createCustomGame(sentence) {\n    try {\n        // Try proxy endpoint first\n        const proxyUrl = \"\".concat(_lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.POS_GAME_PROXY);\n        console.log('Creating custom game with sentence: \"'.concat(sentence, '\" via proxy'));\n        try {\n            // Use our centralized API service\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiPost)(proxyUrl, {\n                sentence\n            });\n        } catch (proxyError) {\n            console.warn(\"Next.js proxy route failed for custom game, trying direct API:\", proxyError);\n            // Fall back to direct API connection\n            const directUrl = \"\".concat(_lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.CALAMANCY_API);\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiPost)(directUrl, {\n                sentence\n            });\n        }\n    } catch (error) {\n        console.error(\"Error creating custom game from both sources:\", error);\n        // Fallback to basic mock data with the custom sentence\n        const mockData = {\n            ..._data_mock_posData__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n        };\n        mockData.sentence = sentence;\n        return mockData;\n    }\n}\n/**\n * Analyze a Tagalog sentence to get POS tags for each word\n * @param sentence The Tagalog sentence to analyze\n * @returns Promise with analysis results\n */ async function analyzeSentence(sentence) {\n    try {\n        // Try proxy endpoint first\n        const proxyUrl = _lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.NLP_TEST_PROXY;\n        console.log('Analyzing sentence via Next.js API route: \"'.concat(sentence, '\"'));\n        try {\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiPost)(proxyUrl, {\n                sentence\n            });\n        } catch (proxyError) {\n            console.warn(\"Next.js proxy route failed for sentence analysis, trying direct API:\", proxyError);\n            // Fall back to direct API connection\n            const directUrl = _lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.ANALYZE_ENDPOINT;\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiPost)(directUrl, {\n                sentence\n            });\n        }\n    } catch (error) {\n        console.error(\"Error analyzing sentence from both sources:\", error);\n        // Basic fallback response\n        return {\n            sentence,\n            tokens: sentence.split(' ').map((word)=>({\n                    text: word,\n                    pos: 'UNK',\n                    description: 'Unknown word type'\n                })),\n            method: 'fallback'\n        };\n    }\n}\n/**\n * Verify an answer to a POS question\n * @param word The word being asked about\n * @param sentence The sentence containing the word\n * @param selectedAnswer The answer selected by the user\n * @returns Promise with verification result\n */ async function verifyAnswer(word, sentence, selectedAnswer) {\n    try {\n        // Use the Next.js API route for proxying the request\n        const url = '/api/verify';\n        // Use our centralized API service\n        return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiPost)(url, {\n            word,\n            sentence,\n            selected: selectedAnswer\n        });\n    } catch (error) {\n        console.error(\"Error verifying answer:\", error);\n        throw error;\n    }\n}\n/**\n * Check the health of the NLP API\n * @returns Promise with health information\n */ async function checkNlpHealth() {\n    try {\n        // Try to check health via our centralized API utilities\n        const healthEndpoint = _lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.HEALTH_ENDPOINT;\n        console.log(\"Checking NLP API health at: \".concat(healthEndpoint));\n        try {\n            // Use our centralized apiGet function instead of direct fetch\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiGet)(healthEndpoint);\n        } catch (error) {\n            console.warn('Failed to check health with apiGet, trying direct fetch as fallback');\n            // Fallback to simple fetch with timeout\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 3000); // 3s timeout\n            try {\n                const response = await fetch(healthEndpoint, {\n                    method: 'GET',\n                    headers: {\n                        'Accept': 'application/json'\n                    },\n                    signal: controller.signal\n                });\n                clearTimeout(timeoutId);\n                if (!response.ok) {\n                    throw new Error(\"Health endpoint returned \".concat(response.status));\n                }\n                return await response.json();\n            } catch (fetchError) {\n                console.error('Direct fetch for health check failed:', fetchError);\n                throw fetchError;\n            } finally{\n                clearTimeout(timeoutId);\n            }\n        }\n    } catch (error) {\n        console.error(\"Error checking NLP health:\", error);\n        // Fallback response\n        return {\n            status: 'offline',\n            model: 'unavailable',\n            model_status: 'offline',\n            pos_tags_available: []\n        };\n    }\n}\n/**\n * Fetches words for the Make a Sentence game\n * @returns Promise with an array of words with descriptions\n */ async function fetchSentenceWords(grade) {\n    try {\n        // Try proxy endpoint first\n        const proxyUrl = grade ? \"\".concat(_lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.MAKE_SENTENCE_WORDS_PROXY, \"?grade=\").concat(grade) : _lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.MAKE_SENTENCE_WORDS_PROXY;\n        console.log(\"Fetching sentence words via Next.js API route\");\n        try {\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiGet)(proxyUrl);\n        } catch (proxyError) {\n            console.warn(\"Next.js proxy route failed for sentence words, trying direct API:\", proxyError);\n            // Fall back to direct API connection\n            const directUrl = grade ? \"\".concat(_lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.MAKE_SENTENCE_WORDS_ENDPOINT, \"?grade=\").concat(grade) : _lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.MAKE_SENTENCE_WORDS_ENDPOINT;\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiGet)(directUrl);\n        }\n    } catch (error) {\n        console.error(\"Error fetching sentence words from both sources:\", error);\n        // Fallback words\n        return [\n            {\n                word: 'ako',\n                description: 'I or me (pronoun)'\n            },\n            {\n                word: 'kumain',\n                description: 'to eat (verb)'\n            },\n            {\n                word: 'ng',\n                description: 'of (particle)'\n            },\n            {\n                word: 'kanin',\n                description: 'rice (noun)'\n            }\n        ];\n    }\n}\n/**\n * Verify a sentence created by the user\n * @param word The word that should be used in the sentence\n * @param sentence The sentence created by the user\n * @returns Promise with verification result\n */ async function verifySentence(word, sentence) {\n    try {\n        const data = {\n            word,\n            sentence\n        };\n        // Try proxy endpoint first\n        const proxyUrl = _lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.MAKE_SENTENCE_VERIFY_PROXY;\n        console.log(\"Verifying sentence via Next.js API route\");\n        try {\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiPost)(proxyUrl, data);\n        } catch (proxyError) {\n            console.warn(\"Next.js proxy route failed for sentence verification, trying direct API:\", proxyError);\n            // Fall back to direct API connection\n            const directUrl = _lib_config__WEBPACK_IMPORTED_MODULE_0__.API_ENDPOINTS.MAKE_SENTENCE_VERIFY_ENDPOINT;\n            return await (0,_utils_api__WEBPACK_IMPORTED_MODULE_1__.apiPost)(directUrl, data);\n        }\n    } catch (error) {\n        console.error(\"Error verifying sentence from both sources:\", error);\n        // Simple fallback validation (just checks if word is in sentence)\n        const isCorrect = sentence.toLowerCase().includes(word.toLowerCase());\n        return {\n            isCorrect,\n            feedback: isCorrect ? 'Sentence accepted (fallback validation)' : 'Your sentence must include the word \"'.concat(word, '\"'),\n            word,\n            sentence\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9ubHAvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLDRCQUE0QjtBQUM1Qjs7Q0FFQyxHQVM0QztBQUNDO0FBQ0k7QUFXbEQseUNBQXlDO0FBQ3pDLFNBQVNJO0lBQ1AsT0FBT0osc0RBQWFBLENBQUNLLFlBQVk7QUFDbkM7QUFFQTs7OztDQUlDLEdBQ00sZUFBZUMsaUJBQ3BCQyxjQUF1QixFQUN2QkMsVUFBbUI7SUFFbkIsSUFBSTtRQUNGLHVDQUF1QztRQUN2QyxJQUFJQyxZQUFZLElBQUlDO1FBRXBCLElBQUlILGdCQUFnQjtZQUNsQkUsVUFBVUUsTUFBTSxDQUFDLFlBQVlKO1FBQy9CO1FBRUEsSUFBSUMsWUFBWTtZQUNkQyxVQUFVRSxNQUFNLENBQUMsY0FBY0g7UUFDakM7UUFFQSxpREFBaUQ7UUFDakQsTUFBTUksV0FBVyxHQUFrQ0gsT0FBL0JULHNEQUFhQSxDQUFDYSxjQUFjLEVBQTBELE9BQXZESixVQUFVSyxRQUFRLEtBQUssSUFBeUIsT0FBckJMLFVBQVVLLFFBQVEsTUFBTztRQUV2RyxJQUFJO1lBQ0ZDLFFBQVFDLEdBQUcsQ0FBQyxvREFBNkQsT0FBVEo7WUFDaEUsT0FBTyxNQUFNWCxrREFBTUEsQ0FBY1c7UUFDbkMsRUFBRSxPQUFPSyxZQUFZO1lBQ25CRixRQUFRRyxJQUFJLENBQUMsa0RBQWtERDtZQUUvRCxxQ0FBcUM7WUFDckMsTUFBTUUsWUFBWSxHQUFpQ1YsT0FBOUJULHNEQUFhQSxDQUFDb0IsYUFBYSxFQUEwRCxPQUF2RFgsVUFBVUssUUFBUSxLQUFLLElBQXlCLE9BQXJCTCxVQUFVSyxRQUFRLE1BQU87WUFDdkdDLFFBQVFDLEdBQUcsQ0FBQyx5Q0FBbUQsT0FBVkc7WUFFckQsSUFBSTtnQkFDRixPQUFPLE1BQU1sQixrREFBTUEsQ0FBY2tCO1lBQ25DLEVBQUUsT0FBT0UsYUFBYTtnQkFDcEJOLFFBQVFHLElBQUksQ0FBQyxpQ0FBaUNHO2dCQUM5QyxNQUFNQSxhQUFhLHlDQUF5QztZQUM5RDtRQUNGO0lBQ0YsRUFBRSxPQUFPQyxPQUFPO1FBQ2RQLFFBQVFPLEtBQUssQ0FBQyxnRUFBZ0VBO1FBRTlFLDhCQUE4QjtRQUM5QlAsUUFBUUMsR0FBRyxDQUFDO1FBQ1osT0FBT2IsMERBQVdBO0lBQ3BCO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sZUFBZW9CLGlCQUFpQkMsUUFBZ0I7SUFDckQsSUFBSTtRQUNGLDJCQUEyQjtRQUMzQixNQUFNWixXQUFXLEdBQWdDLE9BQTdCWixzREFBYUEsQ0FBQ2EsY0FBYztRQUNoREUsUUFBUUMsR0FBRyxDQUFDLHdDQUFpRCxPQUFUUSxVQUFTO1FBRTdELElBQUk7WUFDRixrQ0FBa0M7WUFDbEMsT0FBTyxNQUFNdEIsbURBQU9BLENBQW9DVSxVQUFVO2dCQUFFWTtZQUFTO1FBQy9FLEVBQUUsT0FBT1AsWUFBWTtZQUNuQkYsUUFBUUcsSUFBSSxDQUFDLGtFQUFrRUQ7WUFFL0UscUNBQXFDO1lBQ3JDLE1BQU1FLFlBQVksR0FBK0IsT0FBNUJuQixzREFBYUEsQ0FBQ29CLGFBQWE7WUFDaEQsT0FBTyxNQUFNbEIsbURBQU9BLENBQW9DaUIsV0FBVztnQkFBRUs7WUFBUztRQUNoRjtJQUNGLEVBQUUsT0FBT0YsT0FBTztRQUNkUCxRQUFRTyxLQUFLLENBQUMsaURBQWlEQTtRQUUvRCx1REFBdUQ7UUFDdkQsTUFBTUcsV0FBVztZQUFDLEdBQUd0QiwwREFBVztRQUFBO1FBQ2hDc0IsU0FBU0QsUUFBUSxHQUFHQTtRQUNwQixPQUFPQztJQUNUO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sZUFBZUMsZ0JBQWdCRixRQUFnQjtJQUtwRCxJQUFJO1FBQ0YsMkJBQTJCO1FBQzNCLE1BQU1aLFdBQVdaLHNEQUFhQSxDQUFDMkIsY0FBYztRQUM3Q1osUUFBUUMsR0FBRyxDQUFDLDhDQUF1RCxPQUFUUSxVQUFTO1FBRW5FLElBQUk7WUFDRixPQUFPLE1BQU10QixtREFBT0EsQ0FJS1UsVUFBVTtnQkFBRVk7WUFBUztRQUNoRCxFQUFFLE9BQU9QLFlBQVk7WUFDbkJGLFFBQVFHLElBQUksQ0FBQyx3RUFBd0VEO1lBRXJGLHFDQUFxQztZQUNyQyxNQUFNRSxZQUFZbkIsc0RBQWFBLENBQUM0QixnQkFBZ0I7WUFDaEQsT0FBTyxNQUFNMUIsbURBQU9BLENBSUtpQixXQUFXO2dCQUFFSztZQUFTO1FBQ2pEO0lBQ0YsRUFBRSxPQUFPRixPQUFPO1FBQ2RQLFFBQVFPLEtBQUssQ0FBQywrQ0FBK0NBO1FBRTdELDBCQUEwQjtRQUMxQixPQUFPO1lBQ0xFO1lBQ0FLLFFBQVFMLFNBQVNNLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUNDLENBQUFBLE9BQVM7b0JBQ3ZDQyxNQUFNRDtvQkFDTkUsS0FBSztvQkFDTEMsYUFBYTtnQkFDZjtZQUNBQyxRQUFRO1FBQ1Y7SUFDRjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ00sZUFBZUMsYUFDcEJMLElBQVksRUFDWlIsUUFBZ0IsRUFDaEJjLGNBQXNCO0lBRXRCLElBQUk7UUFDRixxREFBcUQ7UUFDckQsTUFBTUMsTUFBTTtRQUVaLGtDQUFrQztRQUNsQyxPQUFPLE1BQU1yQyxtREFBT0EsQ0FJakJxQyxLQUFLO1lBQ05QO1lBQ0FSO1lBQ0FnQixVQUFVRjtRQUNaO0lBQ0YsRUFBRSxPQUFPaEIsT0FBTztRQUNkUCxRQUFRTyxLQUFLLENBQUMsMkJBQTJCQTtRQUN6QyxNQUFNQTtJQUNSO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxlQUFlbUI7SUFNcEIsSUFBSTtRQUNGLHdEQUF3RDtRQUN4RCxNQUFNQyxpQkFBaUIxQyxzREFBYUEsQ0FBQzJDLGVBQWU7UUFDcEQ1QixRQUFRQyxHQUFHLENBQUMsK0JBQThDLE9BQWYwQjtRQUUzQyxJQUFJO1lBQ0YsOERBQThEO1lBQzlELE9BQU8sTUFBTXpDLGtEQUFNQSxDQUFDeUM7UUFDdEIsRUFBRSxPQUFPcEIsT0FBTztZQUNkUCxRQUFRRyxJQUFJLENBQUM7WUFFYix3Q0FBd0M7WUFDeEMsTUFBTTBCLGFBQWEsSUFBSUM7WUFDdkIsTUFBTUMsWUFBWUMsV0FBVyxJQUFNSCxXQUFXSSxLQUFLLElBQUksT0FBTyxhQUFhO1lBRTNFLElBQUk7Z0JBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNUixnQkFBZ0I7b0JBQzNDTixRQUFRO29CQUNSZSxTQUFTO3dCQUFFLFVBQVU7b0JBQW1CO29CQUN4Q0MsUUFBUVIsV0FBV1EsTUFBTTtnQkFDM0I7Z0JBRUFDLGFBQWFQO2dCQUViLElBQUksQ0FBQ0csU0FBU0ssRUFBRSxFQUFFO29CQUNoQixNQUFNLElBQUlDLE1BQU0sNEJBQTRDLE9BQWhCTixTQUFTTyxNQUFNO2dCQUM3RDtnQkFFQSxPQUFPLE1BQU1QLFNBQVNRLElBQUk7WUFDNUIsRUFBRSxPQUFPQyxZQUFZO2dCQUNuQjNDLFFBQVFPLEtBQUssQ0FBQyx5Q0FBeUNvQztnQkFDdkQsTUFBTUE7WUFDUixTQUFVO2dCQUNSTCxhQUFhUDtZQUNmO1FBQ0Y7SUFDRixFQUFFLE9BQU94QixPQUFPO1FBQ2RQLFFBQVFPLEtBQUssQ0FBQyw4QkFBOEJBO1FBRTVDLG9CQUFvQjtRQUNwQixPQUFPO1lBQ0xrQyxRQUFRO1lBQ1JHLE9BQU87WUFDUEMsY0FBYztZQUNkQyxvQkFBb0IsRUFBRTtRQUN4QjtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDTSxlQUFlQyxtQkFBbUJDLEtBQWdDO0lBQ3ZFLElBQUk7UUFDRiwyQkFBMkI7UUFDM0IsTUFBTW5ELFdBQVdtRCxRQUNiLEdBQW9EQSxPQUFqRC9ELHNEQUFhQSxDQUFDZ0UseUJBQXlCLEVBQUMsV0FBZSxPQUFORCxTQUNwRC9ELHNEQUFhQSxDQUFDZ0UseUJBQXlCO1FBQzNDakQsUUFBUUMsR0FBRyxDQUFFO1FBRWIsSUFBSTtZQUNGLE9BQU8sTUFBTWYsa0RBQU1BLENBQWlCVztRQUN0QyxFQUFFLE9BQU9LLFlBQVk7WUFDbkJGLFFBQVFHLElBQUksQ0FBQyxxRUFBcUVEO1lBRWxGLHFDQUFxQztZQUNyQyxNQUFNRSxZQUFZNEMsUUFDZCxHQUF1REEsT0FBcEQvRCxzREFBYUEsQ0FBQ2lFLDRCQUE0QixFQUFDLFdBQWUsT0FBTkYsU0FDdkQvRCxzREFBYUEsQ0FBQ2lFLDRCQUE0QjtZQUM5QyxPQUFPLE1BQU1oRSxrREFBTUEsQ0FBaUJrQjtRQUN0QztJQUNGLEVBQUUsT0FBT0csT0FBTztRQUNkUCxRQUFRTyxLQUFLLENBQUMsb0RBQW9EQTtRQUVsRSxpQkFBaUI7UUFDakIsT0FBTztZQUNMO2dCQUFFVSxNQUFNO2dCQUFPRyxhQUFhO1lBQW9CO1lBQ2hEO2dCQUFFSCxNQUFNO2dCQUFVRyxhQUFhO1lBQWdCO1lBQy9DO2dCQUFFSCxNQUFNO2dCQUFNRyxhQUFhO1lBQWdCO1lBQzNDO2dCQUFFSCxNQUFNO2dCQUFTRyxhQUFhO1lBQWM7U0FDN0M7SUFDSDtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDTSxlQUFlK0IsZUFDcEJsQyxJQUFZLEVBQ1pSLFFBQWdCO0lBRWhCLElBQUk7UUFDRixNQUFNMkMsT0FBTztZQUFFbkM7WUFBTVI7UUFBUztRQUU5QiwyQkFBMkI7UUFDM0IsTUFBTVosV0FBV1osc0RBQWFBLENBQUNvRSwwQkFBMEI7UUFDekRyRCxRQUFRQyxHQUFHLENBQUU7UUFFYixJQUFJO1lBQ0YsT0FBTyxNQUFNZCxtREFBT0EsQ0FBMENVLFVBQVV1RDtRQUMxRSxFQUFFLE9BQU9sRCxZQUFZO1lBQ25CRixRQUFRRyxJQUFJLENBQUMsNEVBQTRFRDtZQUV6RixxQ0FBcUM7WUFDckMsTUFBTUUsWUFBWW5CLHNEQUFhQSxDQUFDcUUsNkJBQTZCO1lBQzdELE9BQU8sTUFBTW5FLG1EQUFPQSxDQUEwQ2lCLFdBQVdnRDtRQUMzRTtJQUNGLEVBQUUsT0FBTzdDLE9BQU87UUFDZFAsUUFBUU8sS0FBSyxDQUFDLCtDQUErQ0E7UUFFN0Qsa0VBQWtFO1FBQ2xFLE1BQU1nRCxZQUFZOUMsU0FBUytDLFdBQVcsR0FBR0MsUUFBUSxDQUFDeEMsS0FBS3VDLFdBQVc7UUFFbEUsT0FBTztZQUNMRDtZQUNBRyxVQUFVSCxZQUNOLDRDQUNBLHdDQUE2QyxPQUFMdEMsTUFBSztZQUNqREE7WUFDQVI7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lcnZpbnJhcGhhZWxhbGJhL0Rlc2t0b3AvWDQyMC9zcmMvc2VydmljZXMvbmxwL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9zZXJ2aWNlcy9ubHAvaW5kZXgudHNcbi8qIFxuICogTkxQIHNlcnZpY2UgaW50ZWdyYXRpb24gZm9yIFRhZ2Fsb2cgbGFuZ3VhZ2UgYW5hbHlzaXNcbiAqL1xuaW1wb3J0IHsgXG4gIFBPU1Rva2VuLCBcbiAgUE9TUXVlc3Rpb24sIFxuICBQT1NHYW1lRGF0YSxcbiAgUE9TQW5zd2VyVmVyaWZpY2F0aW9uLFxuICBTZW50ZW5jZVdvcmQsXG4gIFNlbnRlbmNlVmVyaWZpY2F0aW9uUmVzdWx0XG59IGZyb20gJ0AvdHlwZXMvZ2FtZS9pbmRleCc7XG5pbXBvcnQgeyBBUElfRU5EUE9JTlRTIH0gZnJvbSAnQC9saWIvY29uZmlnJztcbmltcG9ydCB7IGFwaUdldCwgYXBpUG9zdCB9IGZyb20gJ0AvdXRpbHMvYXBpJztcbmltcG9ydCBtb2NrUG9zRGF0YSBmcm9tICcuLi8uLi9kYXRhL21vY2svcG9zRGF0YSc7XG5cbi8vIFJlLWV4cG9ydCB0eXBlcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZXhwb3J0IHR5cGUgeyBcbiAgUE9TVG9rZW4sXG4gIFBPU0dhbWVEYXRhIGFzIEdhbWVEYXRhLFxuICBQT1NBbnN3ZXJWZXJpZmljYXRpb24gYXMgQW5zd2VyVmVyaWZpY2F0aW9uLFxuICBTZW50ZW5jZVdvcmQsXG4gIFNlbnRlbmNlVmVyaWZpY2F0aW9uUmVzdWx0XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBOTFAgQVBJIFVSTFxuZnVuY3Rpb24gZ2V0TmxwQXBpVXJsKCk6IHN0cmluZyB7XG4gIHJldHVybiBBUElfRU5EUE9JTlRTLkFQSV9CQVNFX1VSTDtcbn1cblxuLyoqXG4gKiBGZXRjaGVzIGdhbWUgZGF0YSBmcm9tIHRoZSBOTFAgc2VydmljZVxuICogQHBhcmFtIGN1c3RvbVNlbnRlbmNlIE9wdGlvbmFsIGN1c3RvbSBzZW50ZW5jZSB0byB1c2VcbiAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBnYW1lIGRhdGFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTmxwR2FtZURhdGEoXG4gIGN1c3RvbVNlbnRlbmNlPzogc3RyaW5nLFxuICBkaWZmaWN1bHR5Pzogc3RyaW5nXG4pOiBQcm9taXNlPFBPU0dhbWVEYXRhPiB7XG4gIHRyeSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBVUkwgd2l0aCBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgbGV0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBcbiAgICBpZiAoY3VzdG9tU2VudGVuY2UpIHtcbiAgICAgIHVybFBhcmFtcy5hcHBlbmQoJ3NlbnRlbmNlJywgY3VzdG9tU2VudGVuY2UpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZGlmZmljdWx0eSkge1xuICAgICAgdXJsUGFyYW1zLmFwcGVuZCgnZGlmZmljdWx0eScsIGRpZmZpY3VsdHkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgdXNpbmcgdGhlIE5leHQuanMgQVBJIHByb3h5IGVuZHBvaW50IGZpcnN0XG4gICAgY29uc3QgcHJveHlVcmwgPSBgJHtBUElfRU5EUE9JTlRTLlBPU19HQU1FX1BST1hZfSR7dXJsUGFyYW1zLnRvU3RyaW5nKCkgPyBgPyR7dXJsUGFyYW1zLnRvU3RyaW5nKCl9YCA6ICcnfWA7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIGZldGNoIGdhbWUgZGF0YSB2aWEgTmV4dC5qcyBwcm94eTogJHtwcm94eVVybH1gKTtcbiAgICAgIHJldHVybiBhd2FpdCBhcGlHZXQ8UE9TR2FtZURhdGE+KHByb3h5VXJsKTtcbiAgICB9IGNhdGNoIChwcm94eUVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJOZXh0LmpzIHByb3h5IHJvdXRlIGZhaWxlZCwgdHJ5aW5nIGRpcmVjdCBBUEk6XCIsIHByb3h5RXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBGYWxsIGJhY2sgdG8gZGlyZWN0IEFQSSBjb25uZWN0aW9uXG4gICAgICBjb25zdCBkaXJlY3RVcmwgPSBgJHtBUElfRU5EUE9JTlRTLkNBTEFNQU5DWV9BUEl9JHt1cmxQYXJhbXMudG9TdHJpbmcoKSA/IGA/JHt1cmxQYXJhbXMudG9TdHJpbmcoKX1gIDogJyd9YDtcbiAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBOTFAgZ2FtZSBkYXRhIGRpcmVjdGx5IGZyb206ICR7ZGlyZWN0VXJsfWApO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpR2V0PFBPU0dhbWVEYXRhPihkaXJlY3RVcmwpO1xuICAgICAgfSBjYXRjaCAoZGlyZWN0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRGlyZWN0IEFQSSBjb25uZWN0aW9uIGZhaWxlZDpcIiwgZGlyZWN0RXJyb3IpO1xuICAgICAgICB0aHJvdyBkaXJlY3RFcnJvcjsgLy8gUmUtdGhyb3cgdG8gdHJpZ2dlciBtb2NrIGRhdGEgZmFsbGJhY2tcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGdhbWUgZGF0YSBmcm9tIGJvdGggc291cmNlcywgdXNpbmcgbW9jayBkYXRhOlwiLCBlcnJvcik7XG4gICAgXG4gICAgLy8gRmluYWwgZmFsbGJhY2sgdG8gbW9jayBkYXRhXG4gICAgY29uc29sZS5sb2coXCJVc2luZyBtb2NrIFBPUyBnYW1lIGRhdGEgYXMgdWx0aW1hdGUgZmFsbGJhY2tcIik7XG4gICAgcmV0dXJuIG1vY2tQb3NEYXRhO1xuICB9XG59XG5cbi8qKlxuICogU3VibWl0IGEgY3VzdG9tIHNlbnRlbmNlIHRvIGNyZWF0ZSBhIGdhbWVcbiAqIEBwYXJhbSBzZW50ZW5jZSBUaGUgY3VzdG9tIFRhZ2Fsb2cgc2VudGVuY2UgdG8gdXNlXG4gKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZ2FtZSBkYXRhXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDdXN0b21HYW1lKHNlbnRlbmNlOiBzdHJpbmcpOiBQcm9taXNlPFBPU0dhbWVEYXRhPiB7XG4gIHRyeSB7XG4gICAgLy8gVHJ5IHByb3h5IGVuZHBvaW50IGZpcnN0XG4gICAgY29uc3QgcHJveHlVcmwgPSBgJHtBUElfRU5EUE9JTlRTLlBPU19HQU1FX1BST1hZfWA7XG4gICAgY29uc29sZS5sb2coYENyZWF0aW5nIGN1c3RvbSBnYW1lIHdpdGggc2VudGVuY2U6IFwiJHtzZW50ZW5jZX1cIiB2aWEgcHJveHlgKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIG91ciBjZW50cmFsaXplZCBBUEkgc2VydmljZVxuICAgICAgcmV0dXJuIGF3YWl0IGFwaVBvc3Q8UE9TR2FtZURhdGEsIHsgc2VudGVuY2U6IHN0cmluZyB9Pihwcm94eVVybCwgeyBzZW50ZW5jZSB9KTtcbiAgICB9IGNhdGNoIChwcm94eUVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJOZXh0LmpzIHByb3h5IHJvdXRlIGZhaWxlZCBmb3IgY3VzdG9tIGdhbWUsIHRyeWluZyBkaXJlY3QgQVBJOlwiLCBwcm94eUVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbCBiYWNrIHRvIGRpcmVjdCBBUEkgY29ubmVjdGlvblxuICAgICAgY29uc3QgZGlyZWN0VXJsID0gYCR7QVBJX0VORFBPSU5UUy5DQUxBTUFOQ1lfQVBJfWA7XG4gICAgICByZXR1cm4gYXdhaXQgYXBpUG9zdDxQT1NHYW1lRGF0YSwgeyBzZW50ZW5jZTogc3RyaW5nIH0+KGRpcmVjdFVybCwgeyBzZW50ZW5jZSB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIGN1c3RvbSBnYW1lIGZyb20gYm90aCBzb3VyY2VzOlwiLCBlcnJvcik7XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gYmFzaWMgbW9jayBkYXRhIHdpdGggdGhlIGN1c3RvbSBzZW50ZW5jZVxuICAgIGNvbnN0IG1vY2tEYXRhID0gey4uLm1vY2tQb3NEYXRhfTtcbiAgICBtb2NrRGF0YS5zZW50ZW5jZSA9IHNlbnRlbmNlO1xuICAgIHJldHVybiBtb2NrRGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIEFuYWx5emUgYSBUYWdhbG9nIHNlbnRlbmNlIHRvIGdldCBQT1MgdGFncyBmb3IgZWFjaCB3b3JkXG4gKiBAcGFyYW0gc2VudGVuY2UgVGhlIFRhZ2Fsb2cgc2VudGVuY2UgdG8gYW5hbHl6ZVxuICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGFuYWx5c2lzIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFuYWx5emVTZW50ZW5jZShzZW50ZW5jZTogc3RyaW5nKTogUHJvbWlzZTx7XG4gIHNlbnRlbmNlOiBzdHJpbmc7XG4gIHRva2VuczogUE9TVG9rZW5bXTtcbiAgbWV0aG9kOiBzdHJpbmc7XG59PiB7XG4gIHRyeSB7XG4gICAgLy8gVHJ5IHByb3h5IGVuZHBvaW50IGZpcnN0XG4gICAgY29uc3QgcHJveHlVcmwgPSBBUElfRU5EUE9JTlRTLk5MUF9URVNUX1BST1hZO1xuICAgIGNvbnNvbGUubG9nKGBBbmFseXppbmcgc2VudGVuY2UgdmlhIE5leHQuanMgQVBJIHJvdXRlOiBcIiR7c2VudGVuY2V9XCJgKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGFwaVBvc3Q8e1xuICAgICAgICBzZW50ZW5jZTogc3RyaW5nO1xuICAgICAgICB0b2tlbnM6IFBPU1Rva2VuW107XG4gICAgICAgIG1ldGhvZDogc3RyaW5nO1xuICAgICAgfSwgeyBzZW50ZW5jZTogc3RyaW5nIH0+KHByb3h5VXJsLCB7IHNlbnRlbmNlIH0pO1xuICAgIH0gY2F0Y2ggKHByb3h5RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5leHQuanMgcHJveHkgcm91dGUgZmFpbGVkIGZvciBzZW50ZW5jZSBhbmFseXNpcywgdHJ5aW5nIGRpcmVjdCBBUEk6XCIsIHByb3h5RXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBGYWxsIGJhY2sgdG8gZGlyZWN0IEFQSSBjb25uZWN0aW9uXG4gICAgICBjb25zdCBkaXJlY3RVcmwgPSBBUElfRU5EUE9JTlRTLkFOQUxZWkVfRU5EUE9JTlQ7XG4gICAgICByZXR1cm4gYXdhaXQgYXBpUG9zdDx7XG4gICAgICAgIHNlbnRlbmNlOiBzdHJpbmc7XG4gICAgICAgIHRva2VuczogUE9TVG9rZW5bXTtcbiAgICAgICAgbWV0aG9kOiBzdHJpbmc7XG4gICAgICB9LCB7IHNlbnRlbmNlOiBzdHJpbmcgfT4oZGlyZWN0VXJsLCB7IHNlbnRlbmNlIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYW5hbHl6aW5nIHNlbnRlbmNlIGZyb20gYm90aCBzb3VyY2VzOlwiLCBlcnJvcik7XG4gICAgXG4gICAgLy8gQmFzaWMgZmFsbGJhY2sgcmVzcG9uc2VcbiAgICByZXR1cm4ge1xuICAgICAgc2VudGVuY2UsXG4gICAgICB0b2tlbnM6IHNlbnRlbmNlLnNwbGl0KCcgJykubWFwKHdvcmQgPT4gKHtcbiAgICAgICAgdGV4dDogd29yZCxcbiAgICAgICAgcG9zOiAnVU5LJywgLy8gVW5rbm93biBwYXJ0IG9mIHNwZWVjaFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1Vua25vd24gd29yZCB0eXBlJ1xuICAgICAgfSkpLFxuICAgICAgbWV0aG9kOiAnZmFsbGJhY2snXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcmlmeSBhbiBhbnN3ZXIgdG8gYSBQT1MgcXVlc3Rpb25cbiAqIEBwYXJhbSB3b3JkIFRoZSB3b3JkIGJlaW5nIGFza2VkIGFib3V0XG4gKiBAcGFyYW0gc2VudGVuY2UgVGhlIHNlbnRlbmNlIGNvbnRhaW5pbmcgdGhlIHdvcmRcbiAqIEBwYXJhbSBzZWxlY3RlZEFuc3dlciBUaGUgYW5zd2VyIHNlbGVjdGVkIGJ5IHRoZSB1c2VyXG4gKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdmVyaWZpY2F0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QW5zd2VyKFxuICB3b3JkOiBzdHJpbmcsXG4gIHNlbnRlbmNlOiBzdHJpbmcsXG4gIHNlbGVjdGVkQW5zd2VyOiBzdHJpbmdcbik6IFByb21pc2U8UE9TQW5zd2VyVmVyaWZpY2F0aW9uPiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIHRoZSBOZXh0LmpzIEFQSSByb3V0ZSBmb3IgcHJveHlpbmcgdGhlIHJlcXVlc3RcbiAgICBjb25zdCB1cmwgPSAnL2FwaS92ZXJpZnknO1xuICAgIFxuICAgIC8vIFVzZSBvdXIgY2VudHJhbGl6ZWQgQVBJIHNlcnZpY2VcbiAgICByZXR1cm4gYXdhaXQgYXBpUG9zdDxQT1NBbnN3ZXJWZXJpZmljYXRpb24sIHtcbiAgICAgIHdvcmQ6IHN0cmluZztcbiAgICAgIHNlbnRlbmNlOiBzdHJpbmc7XG4gICAgICBzZWxlY3RlZDogc3RyaW5nO1xuICAgIH0+KHVybCwge1xuICAgICAgd29yZCxcbiAgICAgIHNlbnRlbmNlLFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkQW5zd2VyXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHZlcmlmeWluZyBhbnN3ZXI6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHRoZSBoZWFsdGggb2YgdGhlIE5MUCBBUElcbiAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBoZWFsdGggaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrTmxwSGVhbHRoKCk6IFByb21pc2U8e1xuICBzdGF0dXM6IHN0cmluZztcbiAgbW9kZWw6IHN0cmluZztcbiAgbW9kZWxfc3RhdHVzOiBzdHJpbmc7XG4gIHBvc190YWdzX2F2YWlsYWJsZTogc3RyaW5nW107XG59PiB7XG4gIHRyeSB7XG4gICAgLy8gVHJ5IHRvIGNoZWNrIGhlYWx0aCB2aWEgb3VyIGNlbnRyYWxpemVkIEFQSSB1dGlsaXRpZXNcbiAgICBjb25zdCBoZWFsdGhFbmRwb2ludCA9IEFQSV9FTkRQT0lOVFMuSEVBTFRIX0VORFBPSU5UO1xuICAgIGNvbnNvbGUubG9nKGBDaGVja2luZyBOTFAgQVBJIGhlYWx0aCBhdDogJHtoZWFsdGhFbmRwb2ludH1gKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIG91ciBjZW50cmFsaXplZCBhcGlHZXQgZnVuY3Rpb24gaW5zdGVhZCBvZiBkaXJlY3QgZmV0Y2hcbiAgICAgIHJldHVybiBhd2FpdCBhcGlHZXQoaGVhbHRoRW5kcG9pbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBjaGVjayBoZWFsdGggd2l0aCBhcGlHZXQsIHRyeWluZyBkaXJlY3QgZmV0Y2ggYXMgZmFsbGJhY2snKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgdG8gc2ltcGxlIGZldGNoIHdpdGggdGltZW91dFxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAzMDAwKTsgLy8gM3MgdGltZW91dFxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGhlYWx0aEVuZHBvaW50LCB7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIZWFsdGggZW5kcG9pbnQgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICB9IGNhdGNoIChmZXRjaEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RpcmVjdCBmZXRjaCBmb3IgaGVhbHRoIGNoZWNrIGZhaWxlZDonLCBmZXRjaEVycm9yKTtcbiAgICAgICAgdGhyb3cgZmV0Y2hFcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2hlY2tpbmcgTkxQIGhlYWx0aDpcIiwgZXJyb3IpO1xuICAgIFxuICAgIC8vIEZhbGxiYWNrIHJlc3BvbnNlXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogJ29mZmxpbmUnLFxuICAgICAgbW9kZWw6ICd1bmF2YWlsYWJsZScsXG4gICAgICBtb2RlbF9zdGF0dXM6ICdvZmZsaW5lJyxcbiAgICAgIHBvc190YWdzX2F2YWlsYWJsZTogW11cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2hlcyB3b3JkcyBmb3IgdGhlIE1ha2UgYSBTZW50ZW5jZSBnYW1lXG4gKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYW4gYXJyYXkgb2Ygd29yZHMgd2l0aCBkZXNjcmlwdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoU2VudGVuY2VXb3JkcyhncmFkZT86ICdHMV8yJyB8ICdHM180JyB8ICdHNV82Jyk6IFByb21pc2U8U2VudGVuY2VXb3JkW10+IHtcbiAgdHJ5IHtcbiAgICAvLyBUcnkgcHJveHkgZW5kcG9pbnQgZmlyc3RcbiAgICBjb25zdCBwcm94eVVybCA9IGdyYWRlXG4gICAgICA/IGAke0FQSV9FTkRQT0lOVFMuTUFLRV9TRU5URU5DRV9XT1JEU19QUk9YWX0/Z3JhZGU9JHtncmFkZX1gXG4gICAgICA6IEFQSV9FTkRQT0lOVFMuTUFLRV9TRU5URU5DRV9XT1JEU19QUk9YWTtcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgc2VudGVuY2Ugd29yZHMgdmlhIE5leHQuanMgQVBJIHJvdXRlYCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhcGlHZXQ8U2VudGVuY2VXb3JkW10+KHByb3h5VXJsKTtcbiAgICB9IGNhdGNoIChwcm94eUVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJOZXh0LmpzIHByb3h5IHJvdXRlIGZhaWxlZCBmb3Igc2VudGVuY2Ugd29yZHMsIHRyeWluZyBkaXJlY3QgQVBJOlwiLCBwcm94eUVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbCBiYWNrIHRvIGRpcmVjdCBBUEkgY29ubmVjdGlvblxuICAgICAgY29uc3QgZGlyZWN0VXJsID0gZ3JhZGVcbiAgICAgICAgPyBgJHtBUElfRU5EUE9JTlRTLk1BS0VfU0VOVEVOQ0VfV09SRFNfRU5EUE9JTlR9P2dyYWRlPSR7Z3JhZGV9YFxuICAgICAgICA6IEFQSV9FTkRQT0lOVFMuTUFLRV9TRU5URU5DRV9XT1JEU19FTkRQT0lOVDtcbiAgICAgIHJldHVybiBhd2FpdCBhcGlHZXQ8U2VudGVuY2VXb3JkW10+KGRpcmVjdFVybCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBzZW50ZW5jZSB3b3JkcyBmcm9tIGJvdGggc291cmNlczpcIiwgZXJyb3IpO1xuICAgIFxuICAgIC8vIEZhbGxiYWNrIHdvcmRzXG4gICAgcmV0dXJuIFtcbiAgICAgIHsgd29yZDogJ2FrbycsIGRlc2NyaXB0aW9uOiAnSSBvciBtZSAocHJvbm91biknIH0sXG4gICAgICB7IHdvcmQ6ICdrdW1haW4nLCBkZXNjcmlwdGlvbjogJ3RvIGVhdCAodmVyYiknIH0sXG4gICAgICB7IHdvcmQ6ICduZycsIGRlc2NyaXB0aW9uOiAnb2YgKHBhcnRpY2xlKScgfSxcbiAgICAgIHsgd29yZDogJ2thbmluJywgZGVzY3JpcHRpb246ICdyaWNlIChub3VuKScgfVxuICAgIF07XG4gIH1cbn1cblxuLyoqXG4gKiBWZXJpZnkgYSBzZW50ZW5jZSBjcmVhdGVkIGJ5IHRoZSB1c2VyXG4gKiBAcGFyYW0gd29yZCBUaGUgd29yZCB0aGF0IHNob3VsZCBiZSB1c2VkIGluIHRoZSBzZW50ZW5jZVxuICogQHBhcmFtIHNlbnRlbmNlIFRoZSBzZW50ZW5jZSBjcmVhdGVkIGJ5IHRoZSB1c2VyXG4gKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdmVyaWZpY2F0aW9uIHJlc3VsdFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5U2VudGVuY2UoXG4gIHdvcmQ6IHN0cmluZyxcbiAgc2VudGVuY2U6IHN0cmluZ1xuKTogUHJvbWlzZTxTZW50ZW5jZVZlcmlmaWNhdGlvblJlc3VsdD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSB7IHdvcmQsIHNlbnRlbmNlIH07XG4gICAgXG4gICAgLy8gVHJ5IHByb3h5IGVuZHBvaW50IGZpcnN0XG4gICAgY29uc3QgcHJveHlVcmwgPSBBUElfRU5EUE9JTlRTLk1BS0VfU0VOVEVOQ0VfVkVSSUZZX1BST1hZO1xuICAgIGNvbnNvbGUubG9nKGBWZXJpZnlpbmcgc2VudGVuY2UgdmlhIE5leHQuanMgQVBJIHJvdXRlYCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBhcGlQb3N0PFNlbnRlbmNlVmVyaWZpY2F0aW9uUmVzdWx0LCB0eXBlb2YgZGF0YT4ocHJveHlVcmwsIGRhdGEpO1xuICAgIH0gY2F0Y2ggKHByb3h5RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5leHQuanMgcHJveHkgcm91dGUgZmFpbGVkIGZvciBzZW50ZW5jZSB2ZXJpZmljYXRpb24sIHRyeWluZyBkaXJlY3QgQVBJOlwiLCBwcm94eUVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbCBiYWNrIHRvIGRpcmVjdCBBUEkgY29ubmVjdGlvblxuICAgICAgY29uc3QgZGlyZWN0VXJsID0gQVBJX0VORFBPSU5UUy5NQUtFX1NFTlRFTkNFX1ZFUklGWV9FTkRQT0lOVDtcbiAgICAgIHJldHVybiBhd2FpdCBhcGlQb3N0PFNlbnRlbmNlVmVyaWZpY2F0aW9uUmVzdWx0LCB0eXBlb2YgZGF0YT4oZGlyZWN0VXJsLCBkYXRhKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIHZlcmlmeWluZyBzZW50ZW5jZSBmcm9tIGJvdGggc291cmNlczpcIiwgZXJyb3IpO1xuICAgIFxuICAgIC8vIFNpbXBsZSBmYWxsYmFjayB2YWxpZGF0aW9uIChqdXN0IGNoZWNrcyBpZiB3b3JkIGlzIGluIHNlbnRlbmNlKVxuICAgIGNvbnN0IGlzQ29ycmVjdCA9IHNlbnRlbmNlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMod29yZC50b0xvd2VyQ2FzZSgpKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb3JyZWN0LFxuICAgICAgZmVlZGJhY2s6IGlzQ29ycmVjdCBcbiAgICAgICAgPyAnU2VudGVuY2UgYWNjZXB0ZWQgKGZhbGxiYWNrIHZhbGlkYXRpb24pJyBcbiAgICAgICAgOiBgWW91ciBzZW50ZW5jZSBtdXN0IGluY2x1ZGUgdGhlIHdvcmQgXCIke3dvcmR9XCJgLFxuICAgICAgd29yZCxcbiAgICAgIHNlbnRlbmNlXG4gICAgfTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkFQSV9FTkRQT0lOVFMiLCJhcGlHZXQiLCJhcGlQb3N0IiwibW9ja1Bvc0RhdGEiLCJnZXRObHBBcGlVcmwiLCJBUElfQkFTRV9VUkwiLCJmZXRjaE5scEdhbWVEYXRhIiwiY3VzdG9tU2VudGVuY2UiLCJkaWZmaWN1bHR5IiwidXJsUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwicHJveHlVcmwiLCJQT1NfR0FNRV9QUk9YWSIsInRvU3RyaW5nIiwiY29uc29sZSIsImxvZyIsInByb3h5RXJyb3IiLCJ3YXJuIiwiZGlyZWN0VXJsIiwiQ0FMQU1BTkNZX0FQSSIsImRpcmVjdEVycm9yIiwiZXJyb3IiLCJjcmVhdGVDdXN0b21HYW1lIiwic2VudGVuY2UiLCJtb2NrRGF0YSIsImFuYWx5emVTZW50ZW5jZSIsIk5MUF9URVNUX1BST1hZIiwiQU5BTFlaRV9FTkRQT0lOVCIsInRva2VucyIsInNwbGl0IiwibWFwIiwid29yZCIsInRleHQiLCJwb3MiLCJkZXNjcmlwdGlvbiIsIm1ldGhvZCIsInZlcmlmeUFuc3dlciIsInNlbGVjdGVkQW5zd2VyIiwidXJsIiwic2VsZWN0ZWQiLCJjaGVja05scEhlYWx0aCIsImhlYWx0aEVuZHBvaW50IiwiSEVBTFRIX0VORFBPSU5UIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJFcnJvciIsInN0YXR1cyIsImpzb24iLCJmZXRjaEVycm9yIiwibW9kZWwiLCJtb2RlbF9zdGF0dXMiLCJwb3NfdGFnc19hdmFpbGFibGUiLCJmZXRjaFNlbnRlbmNlV29yZHMiLCJncmFkZSIsIk1BS0VfU0VOVEVOQ0VfV09SRFNfUFJPWFkiLCJNQUtFX1NFTlRFTkNFX1dPUkRTX0VORFBPSU5UIiwidmVyaWZ5U2VudGVuY2UiLCJkYXRhIiwiTUFLRV9TRU5URU5DRV9WRVJJRllfUFJPWFkiLCJNQUtFX1NFTlRFTkNFX1ZFUklGWV9FTkRQT0lOVCIsImlzQ29ycmVjdCIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJmZWVkYmFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/nlp/index.ts\n"));

/***/ })

});