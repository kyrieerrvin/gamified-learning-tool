"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/challenges/make-sentence/play/page",{

/***/ "(app-pages-browser)/./src/hooks/useGameProgress.ts":
/*!**************************************!*\
  !*** ./src/hooks/useGameProgress.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameProgress: () => (/* binding */ useGameProgress)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var _context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/context/AuthContext */ \"(app-pages-browser)/./src/context/AuthContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ useGameProgress auto */ \n\n\n\n// Helper functions\nconst getTodayDateString = ()=>{\n    const today = new Date();\n    const year = today.getFullYear();\n    const month = String(today.getMonth() + 1).padStart(2, '0');\n    const day = String(today.getDate()).padStart(2, '0');\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n};\nconst isSameDay = (dateStr1, dateStr2)=>{\n    if (!dateStr1 || !dateStr2) return false;\n    return dateStr1 === dateStr2;\n};\nconst isConsecutiveDay = (lastDateStr, todayStr)=>{\n    if (!lastDateStr || !todayStr) return false;\n    const lastDate = new Date(lastDateStr);\n    const today = new Date(todayStr);\n    const timeDiff = today.getTime() - lastDate.getTime();\n    const daysDiff = timeDiff / (1000 * 3600 * 24);\n    return Math.round(daysDiff) === 1;\n};\n// Generate 3 Levels (Easy, Difficult, Hard) each with 10 challenges\nconst generateSections = ()=>{\n    const sections = [];\n    const levelNames = [\n        'Easy',\n        'Difficult',\n        'Hard'\n    ];\n    for(let sectionId = 0; sectionId < 3; sectionId++){\n        const levels = [];\n        for(let levelId = 0; levelId < 10; levelId++){\n            levels.push({\n                id: levelId,\n                title: \"Challenge \".concat(levelId + 1),\n                isLocked: !(sectionId === 0 && levelId === 0),\n                isCompleted: false,\n                bestScore: 0,\n                attempts: 0,\n                lastPlayed: null\n            });\n        }\n        sections.push({\n            id: sectionId,\n            title: \"Level \".concat(sectionId + 1, \": \").concat(levelNames[sectionId] || '').trim(),\n            description: \"Complete all challenges in \".concat(levelNames[sectionId] || \"Level \".concat(sectionId + 1)),\n            isLocked: sectionId !== 0,\n            isCompleted: false,\n            levels\n        });\n    }\n    return sections;\n};\n// Generate daily quests\nconst generateDailyQuests = ()=>{\n    const today = getTodayDateString();\n    const expiresAt = today; // Expires at end of today\n    return [\n        {\n            id: 'daily-xp',\n            title: 'Daily XP',\n            description: 'Earn 50 XP today',\n            reward: 10,\n            progress: 0,\n            target: 50,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'streak-bonus',\n            title: 'Get 3 Correct in a Row',\n            description: 'Answer three questions correctly in a row',\n            reward: 10,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'complete-games',\n            title: 'Complete 3 Games',\n            description: 'Complete any 3 games today (any score)',\n            reward: 15,\n            progress: 0,\n            target: 3,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'perfect-score',\n            title: 'Perfect Score',\n            description: 'Complete a level with a perfect score',\n            reward: 20,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        }\n    ];\n};\n// Default initial data\nconst getInitialData = (user)=>{\n    return {\n        profile: {\n            displayName: (user === null || user === void 0 ? void 0 : user.displayName) || null,\n            email: (user === null || user === void 0 ? void 0 : user.email) || null,\n            photoURL: (user === null || user === void 0 ? void 0 : user.photoURL) || null,\n            joinDate: new Date().toISOString(),\n            lastActiveDate: new Date().toISOString(),\n            gradeLevel: null,\n            preferences: {\n                emailNotifications: false,\n                dailyReminder: true\n            }\n        },\n        score: 0,\n        streak: 0,\n        lastStreakDate: '',\n        streakState: 'none',\n        totalChallengesCompleted: 0,\n        progress: {\n            'make-sentence': {\n                currentLevel: 0,\n                currentSection: 0,\n                sections: generateSections(),\n                xp: 0,\n                quests: generateDailyQuests(),\n                completedLevels: []\n            },\n            'multiple-choice': {\n                currentLevel: 0,\n                currentSection: 0,\n                sections: generateSections(),\n                xp: 0,\n                quests: generateDailyQuests(),\n                completedLevels: []\n            }\n        },\n        achievements: [],\n        gameAchievements: {},\n        recentChallenges: [],\n        updatedAt: new Date().toISOString()\n    };\n};\nconst useGameProgress = ()=>{\n    const { user } = (0,_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Real-time listener\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useGameProgress.useEffect\": ()=>{\n            if (!(user === null || user === void 0 ? void 0 : user.uid)) {\n                setLoading(false);\n                return;\n            }\n            console.log('[GameProgress] Setting up real-time listener for user:', user.uid);\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            const unsubscribe = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)(userDocRef, {\n                \"useGameProgress.useEffect.unsubscribe\": async (doc)=>{\n                    try {\n                        if (doc.exists()) {\n                            const docData = doc.data();\n                            console.log('[GameProgress] Real-time data received:', docData);\n                            // Migration: ensure 3 Levels with 10 challenges each for both games\n                            const needsMigration = {\n                                \"useGameProgress.useEffect.unsubscribe.needsMigration\": (progress)=>{\n                                    if (!progress || !progress.sections) return true;\n                                    if (progress.sections.length !== 3) return true;\n                                    for (const s of progress.sections){\n                                        if (!s.levels || s.levels.length !== 10) return true;\n                                    }\n                                    return false;\n                                }\n                            }[\"useGameProgress.useEffect.unsubscribe.needsMigration\"];\n                            const updatedProgress = {\n                                ...docData.progress\n                            };\n                            let didMigrate = false;\n                            for (const gameType of [\n                                'make-sentence',\n                                'multiple-choice'\n                            ]){\n                                var _docData_progress;\n                                const gp = (_docData_progress = docData.progress) === null || _docData_progress === void 0 ? void 0 : _docData_progress[gameType];\n                                if (!gp || needsMigration(gp)) {\n                                    didMigrate = true;\n                                    const sections = generateSections();\n                                    // Unlock first level and first challenge\n                                    if (sections.length > 0) {\n                                        sections[0].isLocked = false;\n                                        if (sections[0].levels.length > 0) sections[0].levels[0].isLocked = false;\n                                    }\n                                    updatedProgress[gameType] = {\n                                        sections,\n                                        xp: (gp === null || gp === void 0 ? void 0 : gp.xp) || 0,\n                                        quests: (gp === null || gp === void 0 ? void 0 : gp.quests) || [],\n                                        currentSection: 0,\n                                        currentLevel: 0,\n                                        completedLevels: []\n                                    };\n                                }\n                            }\n                            // Reset streak if a day was missed (device local date)\n                            try {\n                                const today = getTodayDateString();\n                                const missedDay = !!docData.lastStreakDate && !isSameDay(docData.lastStreakDate, today) && !isConsecutiveDay(docData.lastStreakDate, today) && (docData.streak || 0) > 0;\n                                if (missedDay) {\n                                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                                        streak: 0,\n                                        streakState: 'none',\n                                        updatedAt: new Date().toISOString()\n                                    });\n                                    docData.streak = 0;\n                                    docData.streakState = 'none';\n                                }\n                            } catch (e) {\n                                console.warn('[GameProgress] Streak reset check failed:', e);\n                            }\n                            if (didMigrate) {\n                                console.log('[GameProgress] Migrating progress to 3 levels × 10 challenges structure');\n                                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                                    progress: updatedProgress,\n                                    updatedAt: new Date().toISOString()\n                                });\n                                setData({\n                                    ...docData,\n                                    progress: updatedProgress\n                                });\n                            } else {\n                                setData(docData);\n                            }\n                        } else {\n                            // Create initial data if document doesn't exist\n                            console.log('[GameProgress] No document found, creating initial data');\n                            const initialData = getInitialData(user);\n                            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(userDocRef, initialData);\n                            setData(initialData);\n                        }\n                        setLoading(false);\n                        setError(null);\n                    } catch (err) {\n                        console.error('[GameProgress] Error processing real-time data:', err);\n                        setError(err instanceof Error ? err.message : 'Unknown error');\n                        setLoading(false);\n                    }\n                }\n            }[\"useGameProgress.useEffect.unsubscribe\"], {\n                \"useGameProgress.useEffect.unsubscribe\": (err)=>{\n                    console.error('[GameProgress] Real-time listener error:', err);\n                    setError(err.message);\n                    setLoading(false);\n                }\n            }[\"useGameProgress.useEffect.unsubscribe\"]);\n            return ({\n                \"useGameProgress.useEffect\": ()=>{\n                    console.log('[GameProgress] Cleaning up real-time listener');\n                    unsubscribe();\n                }\n            })[\"useGameProgress.useEffect\"];\n        }\n    }[\"useGameProgress.useEffect\"], [\n        user === null || user === void 0 ? void 0 : user.uid\n    ]);\n    // Action functions\n    const updateData = async (updates)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid)) return;\n        try {\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                ...updates,\n                updatedAt: new Date().toISOString()\n            });\n        } catch (err) {\n            console.error('[GameProgress] Error updating data:', err);\n            throw err;\n        }\n    };\n    const addPoints = async (points, gameType)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid)) return;\n        try {\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                [\"progress.\".concat(gameType, \".xp\")]: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.increment)(points),\n                score: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.increment)(points),\n                updatedAt: new Date().toISOString()\n            });\n        } catch (err) {\n            console.error('[GameProgress] Error incrementing XP:', err);\n            throw err;\n        }\n    };\n    const setQuests = async (gameType, quests)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid)) return;\n        try {\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                [\"progress.\".concat(gameType, \".quests\")]: quests,\n                updatedAt: new Date().toISOString()\n            });\n        } catch (err) {\n            console.error('[GameProgress] Error updating quests:', err);\n            throw err;\n        }\n    };\n    const increaseStreak = async ()=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const today = getTodayDateString();\n        let newStreak = data.streak;\n        // Don't increase if already played today\n        if (isSameDay(data.lastStreakDate, today)) {\n            return;\n        }\n        // Increase streak if consecutive day or starting new\n        if (isConsecutiveDay(data.lastStreakDate, today) || !data.lastStreakDate) {\n            newStreak += 1;\n        } else {\n            newStreak = 1; // Reset to 1 if missed days\n        }\n        await updateData({\n            streak: newStreak,\n            lastStreakDate: today,\n            streakState: 'active'\n        });\n    };\n    const completeLevel = async (gameType, sectionId, levelId, score)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress) return;\n        const updatedSections = [\n            ...gameProgress.sections\n        ];\n        const section = updatedSections[sectionId];\n        if (!section || !section.levels[levelId]) return;\n        const level = section.levels[levelId];\n        level.attempts = (level.attempts || 0) + 1;\n        level.lastPlayed = new Date().toISOString();\n        if (score !== undefined && (level.bestScore === undefined || score > level.bestScore)) {\n            level.bestScore = score;\n        }\n        // Treat invocation of completeLevel as \"finished the level\"\n        // Always mark as completed and advance unlocking\n        let nextSectionId = sectionId;\n        let nextLevelId = levelId;\n        level.isCompleted = true;\n        // Unlock next level or section\n        if (levelId < section.levels.length - 1) {\n            nextLevelId = levelId + 1;\n            section.levels[nextLevelId].isLocked = false;\n        } else {\n            // Completed section, unlock next section\n            section.isCompleted = true;\n            if (sectionId < updatedSections.length - 1) {\n                nextSectionId = sectionId + 1;\n                nextLevelId = 0;\n                updatedSections[nextSectionId].isLocked = false;\n                updatedSections[nextSectionId].levels[0].isLocked = false;\n            }\n        }\n        // Prepare achievements updates (simple MVP)\n        const updatedGameAchievements = {\n            ...data.gameAchievements || {}\n        };\n        const gameTypeAchievements = new Set(updatedGameAchievements[gameType] || []);\n        const updatedAchievements = new Set(data.achievements || []);\n        // First Steps: completing a first game\n        if (!gameTypeAchievements.has('first-steps')) {\n            gameTypeAchievements.add('first-steps');\n            updatedAchievements.add('first-steps');\n        }\n        // Perfect Score: score 100\n        if (score !== undefined && score >= 100 && !gameTypeAchievements.has('perfect-score')) {\n            gameTypeAchievements.add('perfect-score');\n            updatedAchievements.add('perfect-score');\n        }\n        // Section Champion: entire section completed\n        const sectionCompleted = section.levels.every((l)=>l.isCompleted);\n        if (sectionCompleted && !gameTypeAchievements.has('section-champion')) {\n            gameTypeAchievements.add('section-champion');\n            updatedAchievements.add('section-champion');\n        }\n        updatedGameAchievements[gameType] = Array.from(gameTypeAchievements);\n        // Streak logic (local time):\n        // - Start at 1 on first completion\n        // - If same day: keep streak, set active\n        // - If consecutive day: +1\n        // - If missed days: reset to 1\n        const todayStr = getTodayDateString();\n        let newStreak = data.streak || 0;\n        let newLastStreakDate = data.lastStreakDate || '';\n        let newStreakState = 'active';\n        if (!data.lastStreakDate) {\n            newStreak = 1;\n            newLastStreakDate = todayStr;\n        } else if (isSameDay(data.lastStreakDate, todayStr)) {\n            // already counted today; keep state active\n            newStreak = data.streak;\n            newLastStreakDate = data.lastStreakDate;\n        } else if (isConsecutiveDay(data.lastStreakDate, todayStr)) {\n            newStreak = (data.streak || 0) + 1;\n            newLastStreakDate = todayStr;\n        } else {\n            // Missed a day, restart at 1\n            newStreak = 1;\n            newLastStreakDate = todayStr;\n        }\n        await updateData({\n            progress: {\n                ...data.progress,\n                [gameType]: {\n                    ...gameProgress,\n                    sections: updatedSections,\n                    currentSection: nextSectionId,\n                    currentLevel: nextLevelId\n                }\n            },\n            achievements: Array.from(updatedAchievements),\n            gameAchievements: updatedGameAchievements,\n            streak: newStreak,\n            lastStreakDate: newLastStreakDate,\n            streakState: newStreak > 0 ? 'active' : 'none'\n        });\n    };\n    const canAccessLevel = (gameType, sectionId, levelId)=>{\n        if (!data || !data.progress[gameType]) return false;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress.sections || sectionId < 0 || sectionId >= gameProgress.sections.length) {\n            return false;\n        }\n        const section = gameProgress.sections[sectionId];\n        if (!section || section.isLocked) return false;\n        if (!section.levels || levelId < 0 || levelId >= section.levels.length) {\n            return false;\n        }\n        const level = section.levels[levelId];\n        return level && !level.isLocked;\n    };\n    return {\n        data,\n        loading,\n        error,\n        // Actions\n        updateData,\n        addPoints,\n        setQuests,\n        increaseStreak,\n        completeLevel,\n        canAccessLevel,\n        // Convenience getters\n        profile: (data === null || data === void 0 ? void 0 : data.profile) || null,\n        score: (data === null || data === void 0 ? void 0 : data.score) || 0,\n        streak: (data === null || data === void 0 ? void 0 : data.streak) || 0,\n        streakState: (data === null || data === void 0 ? void 0 : data.streakState) || 'none',\n        progress: (data === null || data === void 0 ? void 0 : data.progress) || {},\n        achievements: (data === null || data === void 0 ? void 0 : data.achievements) || [],\n        gameAchievements: (data === null || data === void 0 ? void 0 : data.gameAchievements) || {},\n        recentChallenges: (data === null || data === void 0 ? void 0 : data.recentChallenges) || []\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VHYW1lUHJvZ3Jlc3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FFQUU0QztBQUNtRDtBQUMzRDtBQUNZO0FBOEZoRCxtQkFBbUI7QUFDbkIsTUFBTVMscUJBQXFCO0lBQ3pCLE1BQU1DLFFBQVEsSUFBSUM7SUFDbEIsTUFBTUMsT0FBT0YsTUFBTUcsV0FBVztJQUM5QixNQUFNQyxRQUFRQyxPQUFPTCxNQUFNTSxRQUFRLEtBQUssR0FBR0MsUUFBUSxDQUFDLEdBQUc7SUFDdkQsTUFBTUMsTUFBTUgsT0FBT0wsTUFBTVMsT0FBTyxJQUFJRixRQUFRLENBQUMsR0FBRztJQUNoRCxPQUFPLEdBQVdILE9BQVJGLE1BQUssS0FBWU0sT0FBVEosT0FBTSxLQUFPLE9BQUpJO0FBQzdCO0FBRUEsTUFBTUUsWUFBWSxDQUFDQyxVQUFrQkM7SUFDbkMsSUFBSSxDQUFDRCxZQUFZLENBQUNDLFVBQVUsT0FBTztJQUNuQyxPQUFPRCxhQUFhQztBQUN0QjtBQUVBLE1BQU1DLG1CQUFtQixDQUFDQyxhQUFxQkM7SUFDN0MsSUFBSSxDQUFDRCxlQUFlLENBQUNDLFVBQVUsT0FBTztJQUV0QyxNQUFNQyxXQUFXLElBQUlmLEtBQUthO0lBQzFCLE1BQU1kLFFBQVEsSUFBSUMsS0FBS2M7SUFFdkIsTUFBTUUsV0FBV2pCLE1BQU1rQixPQUFPLEtBQUtGLFNBQVNFLE9BQU87SUFDbkQsTUFBTUMsV0FBV0YsV0FBWSxRQUFPLE9BQU8sRUFBQztJQUU1QyxPQUFPRyxLQUFLQyxLQUFLLENBQUNGLGNBQWM7QUFDbEM7QUFFQSxvRUFBb0U7QUFDcEUsTUFBTUcsbUJBQW1CO0lBQ3ZCLE1BQU1DLFdBQXNCLEVBQUU7SUFDOUIsTUFBTUMsYUFBYTtRQUFDO1FBQVE7UUFBYTtLQUFPO0lBRWhELElBQUssSUFBSUMsWUFBWSxHQUFHQSxZQUFZLEdBQUdBLFlBQWE7UUFDbEQsTUFBTUMsU0FBa0IsRUFBRTtRQUUxQixJQUFLLElBQUlD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QkUsYUFBYVksQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNWixXQUFXLEtBQUk7UUFDbENsQixVQUFVOEIsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNOUIsUUFBUSxLQUFJLENBQUM7UUFDN0J5QixjQUFjSyxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1MLFlBQVksS0FBSSxFQUFFO1FBQ3RDQyxrQkFBa0JJLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTUosZ0JBQWdCLEtBQUksQ0FBQztRQUM3Q0Msa0JBQWtCRyxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1ILGdCQUFnQixLQUFJLEVBQUU7SUFDaEQ7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvZXJ2aW5yYXBoYWVsYWxiYS9EZXNrdG9wL1g0MjAvc3JjL2hvb2tzL3VzZUdhbWVQcm9ncmVzcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBvblNuYXBzaG90LCBkb2MsIHVwZGF0ZURvYywgc2V0RG9jLCBpbmNyZW1lbnQsIGFycmF5VW5pb24gfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuaW1wb3J0IHsgZGIgfSBmcm9tICdAL2xpYi9maXJlYmFzZSc7XG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSAnQC9jb250ZXh0L0F1dGhDb250ZXh0JztcblxuLy8gVHlwZXMgZnJvbSBleGlzdGluZyBnYW1lU3RvcmVcbmV4cG9ydCB0eXBlIFNlY3Rpb24gPSB7XG4gIGlkOiBudW1iZXI7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGlzTG9ja2VkOiBib29sZWFuO1xuICBpc0NvbXBsZXRlZDogYm9vbGVhbjtcbiAgbGV2ZWxzOiBMZXZlbFtdO1xufTtcblxuZXhwb3J0IHR5cGUgTGV2ZWwgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGlzTG9ja2VkOiBib29sZWFuO1xuICBpc0NvbXBsZXRlZDogYm9vbGVhbjtcbiAgYmVzdFNjb3JlOiBudW1iZXI7XG4gIGF0dGVtcHRzOiBudW1iZXI7XG4gIGxhc3RQbGF5ZWQ6IHN0cmluZyB8IG51bGw7XG59O1xuXG5leHBvcnQgdHlwZSBEYWlseVF1ZXN0ID0ge1xuICBpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICByZXdhcmQ6IG51bWJlcjtcbiAgcHJvZ3Jlc3M6IG51bWJlcjtcbiAgdGFyZ2V0OiBudW1iZXI7XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBleHBpcmVzQXQ6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIFVzZXJQcm9maWxlID0ge1xuICBkaXNwbGF5TmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgZW1haWw6IHN0cmluZyB8IG51bGw7XG4gIHBob3RvVVJMOiBzdHJpbmcgfCBudWxsO1xuICBqb2luRGF0ZTogc3RyaW5nO1xuICBsYXN0QWN0aXZlRGF0ZTogc3RyaW5nO1xuICBncmFkZUxldmVsPzogJ0cxXzInIHwgJ0czXzQnIHwgJ0c1XzYnIHwgbnVsbDtcbiAgcHJlZmVyZW5jZXM6IHtcbiAgICBlbWFpbE5vdGlmaWNhdGlvbnM6IGJvb2xlYW47XG4gICAgZGFpbHlSZW1pbmRlcjogYm9vbGVhbjtcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIENoYWxsZW5nZVJlc3VsdCA9IHtcbiAgaWQ6IHN0cmluZztcbiAgY2hhbGxlbmdlVHlwZTogJ21ha2Utc2VudGVuY2UnIHwgJ211bHRpcGxlLWNob2ljZScgfCAnY29udmVyc2F0aW9uJztcbiAgc2NvcmU6IG51bWJlcjtcbiAgbWF4U2NvcmU6IG51bWJlcjtcbiAgY29tcGxldGVkQXQ6IHN0cmluZztcbiAgZHVyYXRpb246IG51bWJlcjtcbiAgaXNDb3JyZWN0OiBib29sZWFuO1xuICBnYW1lVHlwZTogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgR2FtZVByb2dyZXNzRGF0YSA9IHtcbiAgLy8gVXNlciBwcm9maWxlXG4gIHByb2ZpbGU6IFVzZXJQcm9maWxlIHwgbnVsbDtcbiAgXG4gIC8vIEdhbWUgc3RhdGlzdGljc1xuICBzY29yZTogbnVtYmVyO1xuICBzdHJlYWs6IG51bWJlcjtcbiAgbGFzdFN0cmVha0RhdGU6IHN0cmluZztcbiAgc3RyZWFrU3RhdGU6IFwibm9uZVwiIHwgXCJpbmFjdGl2ZVwiIHwgXCJhY3RpdmVcIjtcbiAgdG90YWxDaGFsbGVuZ2VzQ29tcGxldGVkOiBudW1iZXI7XG4gIFxuICAvLyBHYW1lIHByb2dyZXNzXG4gIHByb2dyZXNzOiB7XG4gICAgW2dhbWVUeXBlOiBzdHJpbmddOiB7XG4gICAgICBjdXJyZW50TGV2ZWw6IG51bWJlcjtcbiAgICAgIGN1cnJlbnRTZWN0aW9uOiBudW1iZXI7XG4gICAgICBzZWN0aW9uczogU2VjdGlvbltdO1xuICAgICAgeHA6IG51bWJlcjtcbiAgICAgIHF1ZXN0czogRGFpbHlRdWVzdFtdO1xuICAgICAgY29tcGxldGVkTGV2ZWxzOiBzdHJpbmdbXTtcbiAgICAgIGxhc3RQbGF5ZWRBdD86IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBcbiAgLy8gQWNoaWV2ZW1lbnRzXG4gIGFjaGlldmVtZW50czogc3RyaW5nW107XG4gIGdhbWVBY2hpZXZlbWVudHM6IHtcbiAgICBbZ2FtZVR5cGU6IHN0cmluZ106IHN0cmluZ1tdO1xuICB9O1xuICBcbiAgLy8gQ2hhbGxlbmdlIGhpc3RvcnlcbiAgcmVjZW50Q2hhbGxlbmdlczogQ2hhbGxlbmdlUmVzdWx0W107XG4gIFxuICAvLyBNZXRhZGF0YVxuICB1cGRhdGVkQXQ6IHN0cmluZztcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbmNvbnN0IGdldFRvZGF5RGF0ZVN0cmluZyA9ICgpOiBzdHJpbmcgPT4ge1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IHllYXIgPSB0b2RheS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBtb250aCA9IFN0cmluZyh0b2RheS5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgY29uc3QgZGF5ID0gU3RyaW5nKHRvZGF5LmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKTtcbiAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fWA7XG59O1xuXG5jb25zdCBpc1NhbWVEYXkgPSAoZGF0ZVN0cjE6IHN0cmluZywgZGF0ZVN0cjI6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICBpZiAoIWRhdGVTdHIxIHx8ICFkYXRlU3RyMikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZGF0ZVN0cjEgPT09IGRhdGVTdHIyO1xufTtcblxuY29uc3QgaXNDb25zZWN1dGl2ZURheSA9IChsYXN0RGF0ZVN0cjogc3RyaW5nLCB0b2RheVN0cjogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIGlmICghbGFzdERhdGVTdHIgfHwgIXRvZGF5U3RyKSByZXR1cm4gZmFsc2U7XG4gIFxuICBjb25zdCBsYXN0RGF0ZSA9IG5ldyBEYXRlKGxhc3REYXRlU3RyKTtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSh0b2RheVN0cik7XG4gIFxuICBjb25zdCB0aW1lRGlmZiA9IHRvZGF5LmdldFRpbWUoKSAtIGxhc3REYXRlLmdldFRpbWUoKTtcbiAgY29uc3QgZGF5c0RpZmYgPSB0aW1lRGlmZiAvICgxMDAwICogMzYwMCAqIDI0KTtcbiAgXG4gIHJldHVybiBNYXRoLnJvdW5kKGRheXNEaWZmKSA9PT0gMTtcbn07XG5cbi8vIEdlbmVyYXRlIDMgTGV2ZWxzIChFYXN5LCBEaWZmaWN1bHQsIEhhcmQpIGVhY2ggd2l0aCAxMCBjaGFsbGVuZ2VzXG5jb25zdCBnZW5lcmF0ZVNlY3Rpb25zID0gKCk6IFNlY3Rpb25bXSA9PiB7XG4gIGNvbnN0IHNlY3Rpb25zOiBTZWN0aW9uW10gPSBbXTtcbiAgY29uc3QgbGV2ZWxOYW1lcyA9IFsnRWFzeScsICdEaWZmaWN1bHQnLCAnSGFyZCddO1xuICBcbiAgZm9yIChsZXQgc2VjdGlvbklkID0gMDsgc2VjdGlvbklkIDwgMzsgc2VjdGlvbklkKyspIHtcbiAgICBjb25zdCBsZXZlbHM6IExldmVsW10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGxldCBsZXZlbElkID0gMDsgbGV2ZWxJZCA8IDEwOyBsZXZlbElkKyspIHtcbiAgICAgIGxldmVscy5wdXNoKHtcbiAgICAgICAgaWQ6IGxldmVsSWQsXG4gICAgICAgIHRpdGxlOiBgQ2hhbGxlbmdlICR7bGV2ZWxJZCArIDF9YCxcbiAgICAgICAgaXNMb2NrZWQ6ICEoc2VjdGlvbklkID09PSAwICYmIGxldmVsSWQgPT09IDApLCAvLyBPbmx5IGZpcnN0IGNoYWxsZW5nZSB1bmxvY2tlZFxuICAgICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICAgIGJlc3RTY29yZTogMCxcbiAgICAgICAgYXR0ZW1wdHM6IDAsXG4gICAgICAgIGxhc3RQbGF5ZWQ6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgIGlkOiBzZWN0aW9uSWQsXG4gICAgICB0aXRsZTogYExldmVsICR7c2VjdGlvbklkICsgMX06ICR7bGV2ZWxOYW1lc1tzZWN0aW9uSWRdIHx8ICcnfWAudHJpbSgpLFxuICAgICAgZGVzY3JpcHRpb246IGBDb21wbGV0ZSBhbGwgY2hhbGxlbmdlcyBpbiAke2xldmVsTmFtZXNbc2VjdGlvbklkXSB8fCBgTGV2ZWwgJHtzZWN0aW9uSWQgKyAxfWB9YCxcbiAgICAgIGlzTG9ja2VkOiBzZWN0aW9uSWQgIT09IDAsIC8vIE9ubHkgZmlyc3QgbGV2ZWwgdW5sb2NrZWRcbiAgICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcbiAgICAgIGxldmVsc1xuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gc2VjdGlvbnM7XG59O1xuXG4vLyBHZW5lcmF0ZSBkYWlseSBxdWVzdHNcbmNvbnN0IGdlbmVyYXRlRGFpbHlRdWVzdHMgPSAoKTogRGFpbHlRdWVzdFtdID0+IHtcbiAgY29uc3QgdG9kYXkgPSBnZXRUb2RheURhdGVTdHJpbmcoKTtcbiAgY29uc3QgZXhwaXJlc0F0ID0gdG9kYXk7IC8vIEV4cGlyZXMgYXQgZW5kIG9mIHRvZGF5XG4gIFxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGlkOiAnZGFpbHkteHAnLFxuICAgICAgdGl0bGU6ICdEYWlseSBYUCcsXG4gICAgICBkZXNjcmlwdGlvbjogJ0Vhcm4gNTAgWFAgdG9kYXknLFxuICAgICAgcmV3YXJkOiAxMCxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgdGFyZ2V0OiA1MCxcbiAgICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcbiAgICAgIGV4cGlyZXNBdFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6ICdzdHJlYWstYm9udXMnLFxuICAgICAgdGl0bGU6ICdHZXQgMyBDb3JyZWN0IGluIGEgUm93JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQW5zd2VyIHRocmVlIHF1ZXN0aW9ucyBjb3JyZWN0bHkgaW4gYSByb3cnLFxuICAgICAgcmV3YXJkOiAxMCxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgdGFyZ2V0OiAxLFxuICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgZXhwaXJlc0F0XG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ2NvbXBsZXRlLWdhbWVzJyxcbiAgICAgIHRpdGxlOiAnQ29tcGxldGUgMyBHYW1lcycsXG4gICAgICBkZXNjcmlwdGlvbjogJ0NvbXBsZXRlIGFueSAzIGdhbWVzIHRvZGF5IChhbnkgc2NvcmUpJyxcbiAgICAgIHJld2FyZDogMTUsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHRhcmdldDogMyxcbiAgICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcbiAgICAgIGV4cGlyZXNBdFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6ICdwZXJmZWN0LXNjb3JlJyxcbiAgICAgIHRpdGxlOiAnUGVyZmVjdCBTY29yZScsXG4gICAgICBkZXNjcmlwdGlvbjogJ0NvbXBsZXRlIGEgbGV2ZWwgd2l0aCBhIHBlcmZlY3Qgc2NvcmUnLFxuICAgICAgcmV3YXJkOiAyMCxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgdGFyZ2V0OiAxLFxuICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgZXhwaXJlc0F0XG4gICAgfVxuICBdO1xufTtcblxuLy8gRGVmYXVsdCBpbml0aWFsIGRhdGFcbmNvbnN0IGdldEluaXRpYWxEYXRhID0gKHVzZXI6IGFueSk6IEdhbWVQcm9ncmVzc0RhdGEgPT4ge1xuICByZXR1cm4ge1xuICAgIHByb2ZpbGU6IHtcbiAgICAgIGRpc3BsYXlOYW1lOiB1c2VyPy5kaXNwbGF5TmFtZSB8fCBudWxsLFxuICAgICAgZW1haWw6IHVzZXI/LmVtYWlsIHx8IG51bGwsXG4gICAgICBwaG90b1VSTDogdXNlcj8ucGhvdG9VUkwgfHwgbnVsbCxcbiAgICAgIGpvaW5EYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBsYXN0QWN0aXZlRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZ3JhZGVMZXZlbDogbnVsbCxcbiAgICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGVtYWlsTm90aWZpY2F0aW9uczogZmFsc2UsXG4gICAgICAgIGRhaWx5UmVtaW5kZXI6IHRydWUsXG4gICAgICB9XG4gICAgfSxcbiAgICBzY29yZTogMCxcbiAgICBzdHJlYWs6IDAsXG4gICAgbGFzdFN0cmVha0RhdGU6ICcnLFxuICAgIHN0cmVha1N0YXRlOiAnbm9uZScsXG4gICAgdG90YWxDaGFsbGVuZ2VzQ29tcGxldGVkOiAwLFxuICAgIHByb2dyZXNzOiB7XG4gICAgICAnbWFrZS1zZW50ZW5jZSc6IHtcbiAgICAgICAgY3VycmVudExldmVsOiAwLFxuICAgICAgICBjdXJyZW50U2VjdGlvbjogMCxcbiAgICAgICAgc2VjdGlvbnM6IGdlbmVyYXRlU2VjdGlvbnMoKSxcbiAgICAgICAgeHA6IDAsXG4gICAgICAgIHF1ZXN0czogZ2VuZXJhdGVEYWlseVF1ZXN0cygpLFxuICAgICAgICBjb21wbGV0ZWRMZXZlbHM6IFtdLFxuICAgICAgfSxcbiAgICAgICdtdWx0aXBsZS1jaG9pY2UnOiB7XG4gICAgICAgIGN1cnJlbnRMZXZlbDogMCxcbiAgICAgICAgY3VycmVudFNlY3Rpb246IDAsXG4gICAgICAgIHNlY3Rpb25zOiBnZW5lcmF0ZVNlY3Rpb25zKCksXG4gICAgICAgIHhwOiAwLFxuICAgICAgICBxdWVzdHM6IGdlbmVyYXRlRGFpbHlRdWVzdHMoKSxcbiAgICAgICAgY29tcGxldGVkTGV2ZWxzOiBbXSxcbiAgICAgIH1cbiAgICB9LFxuICAgIGFjaGlldmVtZW50czogW10sXG4gICAgZ2FtZUFjaGlldmVtZW50czoge30sXG4gICAgcmVjZW50Q2hhbGxlbmdlczogW10sXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VHYW1lUHJvZ3Jlc3MgPSAoKSA9PiB7XG4gIGNvbnN0IHsgdXNlciB9ID0gdXNlQXV0aCgpO1xuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSB1c2VTdGF0ZTxHYW1lUHJvZ3Jlc3NEYXRhIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBcbiAgLy8gUmVhbC10aW1lIGxpc3RlbmVyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1c2VyPy51aWQpIHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnW0dhbWVQcm9ncmVzc10gU2V0dGluZyB1cCByZWFsLXRpbWUgbGlzdGVuZXIgZm9yIHVzZXI6JywgdXNlci51aWQpO1xuICAgIFxuICAgIGNvbnN0IHVzZXJEb2NSZWYgPSBkb2MoZGIsICdnYW1lUHJvZ3Jlc3MnLCB1c2VyLnVpZCk7XG4gICAgXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBvblNuYXBzaG90KFxuICAgICAgdXNlckRvY1JlZixcbiAgICAgIGFzeW5jIChkb2MpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoZG9jLmV4aXN0cygpKSB7XG4gICAgICAgICAgICBjb25zdCBkb2NEYXRhID0gZG9jLmRhdGEoKSBhcyBHYW1lUHJvZ3Jlc3NEYXRhO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tHYW1lUHJvZ3Jlc3NdIFJlYWwtdGltZSBkYXRhIHJlY2VpdmVkOicsIGRvY0RhdGEpO1xuXG4gICAgICAgICAgICAvLyBNaWdyYXRpb246IGVuc3VyZSAzIExldmVscyB3aXRoIDEwIGNoYWxsZW5nZXMgZWFjaCBmb3IgYm90aCBnYW1lc1xuICAgICAgICAgICAgY29uc3QgbmVlZHNNaWdyYXRpb24gPSAocHJvZ3Jlc3M6IGFueSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgICBpZiAoIXByb2dyZXNzIHx8ICFwcm9ncmVzcy5zZWN0aW9ucykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIGlmIChwcm9ncmVzcy5zZWN0aW9ucy5sZW5ndGggIT09IDMpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcHJvZ3Jlc3Muc2VjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXMubGV2ZWxzIHx8IHMubGV2ZWxzLmxlbmd0aCAhPT0gMTApIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcm9ncmVzczogYW55ID0geyAuLi5kb2NEYXRhLnByb2dyZXNzIH07XG4gICAgICAgICAgICBsZXQgZGlkTWlncmF0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdhbWVUeXBlIG9mIFsnbWFrZS1zZW50ZW5jZScsICdtdWx0aXBsZS1jaG9pY2UnXSkge1xuICAgICAgICAgICAgICBjb25zdCBncCA9IGRvY0RhdGEucHJvZ3Jlc3M/LltnYW1lVHlwZV07XG4gICAgICAgICAgICAgIGlmICghZ3AgfHwgbmVlZHNNaWdyYXRpb24oZ3ApKSB7XG4gICAgICAgICAgICAgICAgZGlkTWlncmF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBnZW5lcmF0ZVNlY3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgLy8gVW5sb2NrIGZpcnN0IGxldmVsIGFuZCBmaXJzdCBjaGFsbGVuZ2VcbiAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgc2VjdGlvbnNbMF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uc1swXS5sZXZlbHMubGVuZ3RoID4gMCkgc2VjdGlvbnNbMF0ubGV2ZWxzWzBdLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZWRQcm9ncmVzc1tnYW1lVHlwZV0gPSB7XG4gICAgICAgICAgICAgICAgICBzZWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgIHhwOiBncD8ueHAgfHwgMCxcbiAgICAgICAgICAgICAgICAgIHF1ZXN0czogZ3A/LnF1ZXN0cyB8fCBbXSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZWN0aW9uOiAwLFxuICAgICAgICAgICAgICAgICAgY3VycmVudExldmVsOiAwLFxuICAgICAgICAgICAgICAgICAgY29tcGxldGVkTGV2ZWxzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzZXQgc3RyZWFrIGlmIGEgZGF5IHdhcyBtaXNzZWQgKGRldmljZSBsb2NhbCBkYXRlKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9kYXkgPSBnZXRUb2RheURhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgY29uc3QgbWlzc2VkRGF5ID0gISFkb2NEYXRhLmxhc3RTdHJlYWtEYXRlICYmXG4gICAgICAgICAgICAgICAgIWlzU2FtZURheShkb2NEYXRhLmxhc3RTdHJlYWtEYXRlLCB0b2RheSkgJiZcbiAgICAgICAgICAgICAgICAhaXNDb25zZWN1dGl2ZURheShkb2NEYXRhLmxhc3RTdHJlYWtEYXRlLCB0b2RheSkgJiZcbiAgICAgICAgICAgICAgICAoZG9jRGF0YS5zdHJlYWsgfHwgMCkgPiAwO1xuICAgICAgICAgICAgICBpZiAobWlzc2VkRGF5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKHVzZXJEb2NSZWYsIHtcbiAgICAgICAgICAgICAgICAgIHN0cmVhazogMCxcbiAgICAgICAgICAgICAgICAgIHN0cmVha1N0YXRlOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRvY0RhdGEuc3RyZWFrID0gMDtcbiAgICAgICAgICAgICAgICBkb2NEYXRhLnN0cmVha1N0YXRlID0gJ25vbmUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0dhbWVQcm9ncmVzc10gU3RyZWFrIHJlc2V0IGNoZWNrIGZhaWxlZDonLCBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpZE1pZ3JhdGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tHYW1lUHJvZ3Jlc3NdIE1pZ3JhdGluZyBwcm9ncmVzcyB0byAzIGxldmVscyDDlyAxMCBjaGFsbGVuZ2VzIHN0cnVjdHVyZScpO1xuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVEb2ModXNlckRvY1JlZiwge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzOiB1cGRhdGVkUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNldERhdGEoeyAuLi5kb2NEYXRhLCBwcm9ncmVzczogdXBkYXRlZFByb2dyZXNzIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0RGF0YShkb2NEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGluaXRpYWwgZGF0YSBpZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0dhbWVQcm9ncmVzc10gTm8gZG9jdW1lbnQgZm91bmQsIGNyZWF0aW5nIGluaXRpYWwgZGF0YScpO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbERhdGEgPSBnZXRJbml0aWFsRGF0YSh1c2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHNldERvYyh1c2VyRG9jUmVmLCBpbml0aWFsRGF0YSk7XG4gICAgICAgICAgICBzZXREYXRhKGluaXRpYWxEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tHYW1lUHJvZ3Jlc3NdIEVycm9yIHByb2Nlc3NpbmcgcmVhbC10aW1lIGRhdGE6JywgZXJyKTtcbiAgICAgICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKTtcbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW0dhbWVQcm9ncmVzc10gUmVhbC10aW1lIGxpc3RlbmVyIGVycm9yOicsIGVycik7XG4gICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1tHYW1lUHJvZ3Jlc3NdIENsZWFuaW5nIHVwIHJlYWwtdGltZSBsaXN0ZW5lcicpO1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9LCBbdXNlcj8udWlkXSk7XG4gIFxuICAvLyBBY3Rpb24gZnVuY3Rpb25zXG4gIGNvbnN0IHVwZGF0ZURhdGEgPSBhc3luYyAodXBkYXRlczogUGFydGlhbDxHYW1lUHJvZ3Jlc3NEYXRhPikgPT4ge1xuICAgIGlmICghdXNlcj8udWlkKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXJEb2NSZWYgPSBkb2MoZGIsICdnYW1lUHJvZ3Jlc3MnLCB1c2VyLnVpZCk7XG4gICAgICBhd2FpdCB1cGRhdGVEb2ModXNlckRvY1JlZiwge1xuICAgICAgICAuLi51cGRhdGVzLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbR2FtZVByb2dyZXNzXSBFcnJvciB1cGRhdGluZyBkYXRhOicsIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgYWRkUG9pbnRzID0gYXN5bmMgKHBvaW50czogbnVtYmVyLCBnYW1lVHlwZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyPy51aWQpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlckRvY1JlZiA9IGRvYyhkYiwgJ2dhbWVQcm9ncmVzcycsIHVzZXIudWlkKTtcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyh1c2VyRG9jUmVmLCB7XG4gICAgICAgIFtgcHJvZ3Jlc3MuJHtnYW1lVHlwZX0ueHBgXTogaW5jcmVtZW50KHBvaW50cyksXG4gICAgICAgIHNjb3JlOiBpbmNyZW1lbnQocG9pbnRzKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignW0dhbWVQcm9ncmVzc10gRXJyb3IgaW5jcmVtZW50aW5nIFhQOicsIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNldFF1ZXN0cyA9IGFzeW5jIChnYW1lVHlwZTogc3RyaW5nLCBxdWVzdHM6IERhaWx5UXVlc3RbXSkgPT4ge1xuICAgIGlmICghdXNlcj8udWlkKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXJEb2NSZWYgPSBkb2MoZGIsICdnYW1lUHJvZ3Jlc3MnLCB1c2VyLnVpZCk7XG4gICAgICBhd2FpdCB1cGRhdGVEb2ModXNlckRvY1JlZiwge1xuICAgICAgICBbYHByb2dyZXNzLiR7Z2FtZVR5cGV9LnF1ZXN0c2BdOiBxdWVzdHMsXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tHYW1lUHJvZ3Jlc3NdIEVycm9yIHVwZGF0aW5nIHF1ZXN0czonLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGluY3JlYXNlU3RyZWFrID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcj8udWlkIHx8ICFkYXRhKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdG9kYXkgPSBnZXRUb2RheURhdGVTdHJpbmcoKTtcbiAgICBsZXQgbmV3U3RyZWFrID0gZGF0YS5zdHJlYWs7XG4gICAgXG4gICAgLy8gRG9uJ3QgaW5jcmVhc2UgaWYgYWxyZWFkeSBwbGF5ZWQgdG9kYXlcbiAgICBpZiAoaXNTYW1lRGF5KGRhdGEubGFzdFN0cmVha0RhdGUsIHRvZGF5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBJbmNyZWFzZSBzdHJlYWsgaWYgY29uc2VjdXRpdmUgZGF5IG9yIHN0YXJ0aW5nIG5ld1xuICAgIGlmIChpc0NvbnNlY3V0aXZlRGF5KGRhdGEubGFzdFN0cmVha0RhdGUsIHRvZGF5KSB8fCAhZGF0YS5sYXN0U3RyZWFrRGF0ZSkge1xuICAgICAgbmV3U3RyZWFrICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0cmVhayA9IDE7IC8vIFJlc2V0IHRvIDEgaWYgbWlzc2VkIGRheXNcbiAgICB9XG4gICAgXG4gICAgYXdhaXQgdXBkYXRlRGF0YSh7XG4gICAgICBzdHJlYWs6IG5ld1N0cmVhayxcbiAgICAgIGxhc3RTdHJlYWtEYXRlOiB0b2RheSxcbiAgICAgIHN0cmVha1N0YXRlOiAnYWN0aXZlJ1xuICAgIH0pO1xuICB9O1xuICBcbiAgY29uc3QgY29tcGxldGVMZXZlbCA9IGFzeW5jIChnYW1lVHlwZTogc3RyaW5nLCBzZWN0aW9uSWQ6IG51bWJlciwgbGV2ZWxJZDogbnVtYmVyLCBzY29yZT86IG51bWJlcikgPT4ge1xuICAgIGlmICghdXNlcj8udWlkIHx8ICFkYXRhKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZ2FtZVByb2dyZXNzID0gZGF0YS5wcm9ncmVzc1tnYW1lVHlwZV07XG4gICAgaWYgKCFnYW1lUHJvZ3Jlc3MpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB1cGRhdGVkU2VjdGlvbnMgPSBbLi4uZ2FtZVByb2dyZXNzLnNlY3Rpb25zXTtcbiAgICBjb25zdCBzZWN0aW9uID0gdXBkYXRlZFNlY3Rpb25zW3NlY3Rpb25JZF07XG4gICAgaWYgKCFzZWN0aW9uIHx8ICFzZWN0aW9uLmxldmVsc1tsZXZlbElkXSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGxldmVsID0gc2VjdGlvbi5sZXZlbHNbbGV2ZWxJZF07XG4gICAgbGV2ZWwuYXR0ZW1wdHMgPSAobGV2ZWwuYXR0ZW1wdHMgfHwgMCkgKyAxO1xuICAgIGxldmVsLmxhc3RQbGF5ZWQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgXG4gICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQgJiYgKGxldmVsLmJlc3RTY29yZSA9PT0gdW5kZWZpbmVkIHx8IHNjb3JlID4gbGV2ZWwuYmVzdFNjb3JlKSkge1xuICAgICAgbGV2ZWwuYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyZWF0IGludm9jYXRpb24gb2YgY29tcGxldGVMZXZlbCBhcyBcImZpbmlzaGVkIHRoZSBsZXZlbFwiXG4gICAgLy8gQWx3YXlzIG1hcmsgYXMgY29tcGxldGVkIGFuZCBhZHZhbmNlIHVubG9ja2luZ1xuICAgIGxldCBuZXh0U2VjdGlvbklkID0gc2VjdGlvbklkO1xuICAgIGxldCBuZXh0TGV2ZWxJZCA9IGxldmVsSWQ7XG4gICAgXG4gICAgbGV2ZWwuaXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgIFxuICAgIC8vIFVubG9jayBuZXh0IGxldmVsIG9yIHNlY3Rpb25cbiAgICBpZiAobGV2ZWxJZCA8IHNlY3Rpb24ubGV2ZWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgIG5leHRMZXZlbElkID0gbGV2ZWxJZCArIDE7XG4gICAgICBzZWN0aW9uLmxldmVsc1tuZXh0TGV2ZWxJZF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29tcGxldGVkIHNlY3Rpb24sIHVubG9jayBuZXh0IHNlY3Rpb25cbiAgICAgIHNlY3Rpb24uaXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgaWYgKHNlY3Rpb25JZCA8IHVwZGF0ZWRTZWN0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5leHRTZWN0aW9uSWQgPSBzZWN0aW9uSWQgKyAxO1xuICAgICAgICBuZXh0TGV2ZWxJZCA9IDA7XG4gICAgICAgIHVwZGF0ZWRTZWN0aW9uc1tuZXh0U2VjdGlvbklkXS5pc0xvY2tlZCA9IGZhbHNlO1xuICAgICAgICB1cGRhdGVkU2VjdGlvbnNbbmV4dFNlY3Rpb25JZF0ubGV2ZWxzWzBdLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSBhY2hpZXZlbWVudHMgdXBkYXRlcyAoc2ltcGxlIE1WUClcbiAgICBjb25zdCB1cGRhdGVkR2FtZUFjaGlldmVtZW50cyA9IHsgLi4uKGRhdGEuZ2FtZUFjaGlldmVtZW50cyB8fCB7fSkgfSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT47XG4gICAgY29uc3QgZ2FtZVR5cGVBY2hpZXZlbWVudHMgPSBuZXcgU2V0PHN0cmluZz4odXBkYXRlZEdhbWVBY2hpZXZlbWVudHNbZ2FtZVR5cGVdIHx8IFtdKTtcbiAgICBjb25zdCB1cGRhdGVkQWNoaWV2ZW1lbnRzID0gbmV3IFNldDxzdHJpbmc+KGRhdGEuYWNoaWV2ZW1lbnRzIHx8IFtdKTtcblxuICAgIC8vIEZpcnN0IFN0ZXBzOiBjb21wbGV0aW5nIGEgZmlyc3QgZ2FtZVxuICAgIGlmICghZ2FtZVR5cGVBY2hpZXZlbWVudHMuaGFzKCdmaXJzdC1zdGVwcycpKSB7XG4gICAgICBnYW1lVHlwZUFjaGlldmVtZW50cy5hZGQoJ2ZpcnN0LXN0ZXBzJyk7XG4gICAgICB1cGRhdGVkQWNoaWV2ZW1lbnRzLmFkZCgnZmlyc3Qtc3RlcHMnKTtcbiAgICB9XG4gICAgLy8gUGVyZmVjdCBTY29yZTogc2NvcmUgMTAwXG4gICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQgJiYgc2NvcmUgPj0gMTAwICYmICFnYW1lVHlwZUFjaGlldmVtZW50cy5oYXMoJ3BlcmZlY3Qtc2NvcmUnKSkge1xuICAgICAgZ2FtZVR5cGVBY2hpZXZlbWVudHMuYWRkKCdwZXJmZWN0LXNjb3JlJyk7XG4gICAgICB1cGRhdGVkQWNoaWV2ZW1lbnRzLmFkZCgncGVyZmVjdC1zY29yZScpO1xuICAgIH1cbiAgICAvLyBTZWN0aW9uIENoYW1waW9uOiBlbnRpcmUgc2VjdGlvbiBjb21wbGV0ZWRcbiAgICBjb25zdCBzZWN0aW9uQ29tcGxldGVkID0gc2VjdGlvbi5sZXZlbHMuZXZlcnkobCA9PiBsLmlzQ29tcGxldGVkKTtcbiAgICBpZiAoc2VjdGlvbkNvbXBsZXRlZCAmJiAhZ2FtZVR5cGVBY2hpZXZlbWVudHMuaGFzKCdzZWN0aW9uLWNoYW1waW9uJykpIHtcbiAgICAgIGdhbWVUeXBlQWNoaWV2ZW1lbnRzLmFkZCgnc2VjdGlvbi1jaGFtcGlvbicpO1xuICAgICAgdXBkYXRlZEFjaGlldmVtZW50cy5hZGQoJ3NlY3Rpb24tY2hhbXBpb24nKTtcbiAgICB9XG4gICAgdXBkYXRlZEdhbWVBY2hpZXZlbWVudHNbZ2FtZVR5cGVdID0gQXJyYXkuZnJvbShnYW1lVHlwZUFjaGlldmVtZW50cyk7XG4gICAgXG4gICAgLy8gU3RyZWFrIGxvZ2ljIChsb2NhbCB0aW1lKTpcbiAgICAvLyAtIFN0YXJ0IGF0IDEgb24gZmlyc3QgY29tcGxldGlvblxuICAgIC8vIC0gSWYgc2FtZSBkYXk6IGtlZXAgc3RyZWFrLCBzZXQgYWN0aXZlXG4gICAgLy8gLSBJZiBjb25zZWN1dGl2ZSBkYXk6ICsxXG4gICAgLy8gLSBJZiBtaXNzZWQgZGF5czogcmVzZXQgdG8gMVxuICAgIGNvbnN0IHRvZGF5U3RyID0gZ2V0VG9kYXlEYXRlU3RyaW5nKCk7XG4gICAgbGV0IG5ld1N0cmVhayA9IGRhdGEuc3RyZWFrIHx8IDA7XG4gICAgbGV0IG5ld0xhc3RTdHJlYWtEYXRlID0gZGF0YS5sYXN0U3RyZWFrRGF0ZSB8fCAnJztcbiAgICBsZXQgbmV3U3RyZWFrU3RhdGU6ICdub25lJyB8ICdpbmFjdGl2ZScgfCAnYWN0aXZlJyA9ICdhY3RpdmUnO1xuICAgIGlmICghZGF0YS5sYXN0U3RyZWFrRGF0ZSkge1xuICAgICAgbmV3U3RyZWFrID0gMTtcbiAgICAgIG5ld0xhc3RTdHJlYWtEYXRlID0gdG9kYXlTdHI7XG4gICAgfSBlbHNlIGlmIChpc1NhbWVEYXkoZGF0YS5sYXN0U3RyZWFrRGF0ZSwgdG9kYXlTdHIpKSB7XG4gICAgICAvLyBhbHJlYWR5IGNvdW50ZWQgdG9kYXk7IGtlZXAgc3RhdGUgYWN0aXZlXG4gICAgICBuZXdTdHJlYWsgPSBkYXRhLnN0cmVhaztcbiAgICAgIG5ld0xhc3RTdHJlYWtEYXRlID0gZGF0YS5sYXN0U3RyZWFrRGF0ZTtcbiAgICB9IGVsc2UgaWYgKGlzQ29uc2VjdXRpdmVEYXkoZGF0YS5sYXN0U3RyZWFrRGF0ZSwgdG9kYXlTdHIpKSB7XG4gICAgICBuZXdTdHJlYWsgPSAoZGF0YS5zdHJlYWsgfHwgMCkgKyAxO1xuICAgICAgbmV3TGFzdFN0cmVha0RhdGUgPSB0b2RheVN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWlzc2VkIGEgZGF5LCByZXN0YXJ0IGF0IDFcbiAgICAgIG5ld1N0cmVhayA9IDE7XG4gICAgICBuZXdMYXN0U3RyZWFrRGF0ZSA9IHRvZGF5U3RyO1xuICAgIH1cblxuICAgIGF3YWl0IHVwZGF0ZURhdGEoe1xuICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgLi4uZGF0YS5wcm9ncmVzcyxcbiAgICAgICAgW2dhbWVUeXBlXToge1xuICAgICAgICAgIC4uLmdhbWVQcm9ncmVzcyxcbiAgICAgICAgICBzZWN0aW9uczogdXBkYXRlZFNlY3Rpb25zLFxuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uOiBuZXh0U2VjdGlvbklkLFxuICAgICAgICAgIGN1cnJlbnRMZXZlbDogbmV4dExldmVsSWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFjaGlldmVtZW50czogQXJyYXkuZnJvbSh1cGRhdGVkQWNoaWV2ZW1lbnRzKSxcbiAgICAgIGdhbWVBY2hpZXZlbWVudHM6IHVwZGF0ZWRHYW1lQWNoaWV2ZW1lbnRzLFxuICAgICAgc3RyZWFrOiBuZXdTdHJlYWssXG4gICAgICBsYXN0U3RyZWFrRGF0ZTogbmV3TGFzdFN0cmVha0RhdGUsXG4gICAgICBzdHJlYWtTdGF0ZTogbmV3U3RyZWFrID4gMCA/ICdhY3RpdmUnIDogJ25vbmUnXG4gICAgfSk7XG4gIH07XG4gIFxuICBjb25zdCBjYW5BY2Nlc3NMZXZlbCA9IChnYW1lVHlwZTogc3RyaW5nLCBzZWN0aW9uSWQ6IG51bWJlciwgbGV2ZWxJZDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLnByb2dyZXNzW2dhbWVUeXBlXSkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIGNvbnN0IGdhbWVQcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3NbZ2FtZVR5cGVdO1xuICAgIGlmICghZ2FtZVByb2dyZXNzLnNlY3Rpb25zIHx8IHNlY3Rpb25JZCA8IDAgfHwgc2VjdGlvbklkID49IGdhbWVQcm9ncmVzcy5zZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2VjdGlvbiA9IGdhbWVQcm9ncmVzcy5zZWN0aW9uc1tzZWN0aW9uSWRdO1xuICAgIGlmICghc2VjdGlvbiB8fCBzZWN0aW9uLmlzTG9ja2VkKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgaWYgKCFzZWN0aW9uLmxldmVscyB8fCBsZXZlbElkIDwgMCB8fCBsZXZlbElkID49IHNlY3Rpb24ubGV2ZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBsZXZlbCA9IHNlY3Rpb24ubGV2ZWxzW2xldmVsSWRdO1xuICAgIHJldHVybiBsZXZlbCAmJiAhbGV2ZWwuaXNMb2NrZWQ7XG4gIH07XG4gIFxuICByZXR1cm4ge1xuICAgIGRhdGEsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICAvLyBBY3Rpb25zXG4gICAgdXBkYXRlRGF0YSxcbiAgICBhZGRQb2ludHMsXG4gICAgc2V0UXVlc3RzLFxuICAgIGluY3JlYXNlU3RyZWFrLFxuICAgIGNvbXBsZXRlTGV2ZWwsXG4gICAgY2FuQWNjZXNzTGV2ZWwsXG4gICAgLy8gQ29udmVuaWVuY2UgZ2V0dGVyc1xuICAgIHByb2ZpbGU6IGRhdGE/LnByb2ZpbGUgfHwgbnVsbCxcbiAgICBzY29yZTogZGF0YT8uc2NvcmUgfHwgMCxcbiAgICBzdHJlYWs6IGRhdGE/LnN0cmVhayB8fCAwLFxuICAgIHN0cmVha1N0YXRlOiBkYXRhPy5zdHJlYWtTdGF0ZSB8fCAnbm9uZScsXG4gICAgcHJvZ3Jlc3M6IGRhdGE/LnByb2dyZXNzIHx8IHt9LFxuICAgIGFjaGlldmVtZW50czogZGF0YT8uYWNoaWV2ZW1lbnRzIHx8IFtdLFxuICAgIGdhbWVBY2hpZXZlbWVudHM6IGRhdGE/LmdhbWVBY2hpZXZlbWVudHMgfHwge30sXG4gICAgcmVjZW50Q2hhbGxlbmdlczogZGF0YT8ucmVjZW50Q2hhbGxlbmdlcyB8fCBbXVxuICB9O1xufTsgIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwib25TbmFwc2hvdCIsImRvYyIsInVwZGF0ZURvYyIsInNldERvYyIsImluY3JlbWVudCIsImRiIiwidXNlQXV0aCIsImdldFRvZGF5RGF0ZVN0cmluZyIsInRvZGF5IiwiRGF0ZSIsInllYXIiLCJnZXRGdWxsWWVhciIsIm1vbnRoIiwiU3RyaW5nIiwiZ2V0TW9udGgiLCJwYWRTdGFydCIsImRheSIsImdldERhdGUiLCJpc1NhbWVEYXkiLCJkYXRlU3RyMSIsImRhdGVTdHIyIiwiaXNDb25zZWN1dGl2ZURheSIsImxhc3REYXRlU3RyIiwidG9kYXlTdHIiLCJsYXN0RGF0ZSIsInRpbWVEaWZmIiwiZ2V0VGltZSIsImRheXNEaWZmIiwiTWF0aCIsInJvdW5kIiwiZ2VuZXJhdGVTZWN0aW9ucyIsInNlY3Rpb25zIiwibGV2ZWxOYW1lcyIsInNlY3Rpb25JZCIsImxldmVscyIsImxldmVsSWQiLCJwdXNoIiwiaWQiLCJ0aXRsZSIsImlzTG9ja2VkIiwiaXNDb21wbGV0ZWQiLCJiZXN0U2NvcmUiLCJhdHRlbXB0cyIsImxhc3RQbGF5ZWQiLCJ0cmltIiwiZGVzY3JpcHRpb24iLCJnZW5lcmF0ZURhaWx5UXVlc3RzIiwiZXhwaXJlc0F0IiwicmV3YXJkIiwicHJvZ3Jlc3MiLCJ0YXJnZXQiLCJnZXRJbml0aWFsRGF0YSIsInVzZXIiLCJwcm9maWxlIiwiZGlzcGxheU5hbWUiLCJlbWFpbCIsInBob3RvVVJMIiwiam9pbkRhdGUiLCJ0b0lTT1N0cmluZyIsImxhc3RBY3RpdmVEYXRlIiwiZ3JhZGVMZXZlbCIsInByZWZlcmVuY2VzIiwiZW1haWxOb3RpZmljYXRpb25zIiwiZGFpbHlSZW1pbmRlciIsInNjb3JlIiwic3RyZWFrIiwibGFzdFN0cmVha0RhdGUiLCJzdHJlYWtTdGF0ZSIsInRvdGFsQ2hhbGxlbmdlc0NvbXBsZXRlZCIsImN1cnJlbnRMZXZlbCIsImN1cnJlbnRTZWN0aW9uIiwieHAiLCJxdWVzdHMiLCJjb21wbGV0ZWRMZXZlbHMiLCJhY2hpZXZlbWVudHMiLCJnYW1lQWNoaWV2ZW1lbnRzIiwicmVjZW50Q2hhbGxlbmdlcyIsInVwZGF0ZWRBdCIsInVzZUdhbWVQcm9ncmVzcyIsImRhdGEiLCJzZXREYXRhIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwidWlkIiwiY29uc29sZSIsImxvZyIsInVzZXJEb2NSZWYiLCJ1bnN1YnNjcmliZSIsImV4aXN0cyIsImRvY0RhdGEiLCJuZWVkc01pZ3JhdGlvbiIsImxlbmd0aCIsInMiLCJ1cGRhdGVkUHJvZ3Jlc3MiLCJkaWRNaWdyYXRlIiwiZ2FtZVR5cGUiLCJncCIsIm1pc3NlZERheSIsImUiLCJ3YXJuIiwiaW5pdGlhbERhdGEiLCJlcnIiLCJFcnJvciIsIm1lc3NhZ2UiLCJ1cGRhdGVEYXRhIiwidXBkYXRlcyIsImFkZFBvaW50cyIsInBvaW50cyIsInNldFF1ZXN0cyIsImluY3JlYXNlU3RyZWFrIiwibmV3U3RyZWFrIiwiY29tcGxldGVMZXZlbCIsImdhbWVQcm9ncmVzcyIsInVwZGF0ZWRTZWN0aW9ucyIsInNlY3Rpb24iLCJsZXZlbCIsInVuZGVmaW5lZCIsIm5leHRTZWN0aW9uSWQiLCJuZXh0TGV2ZWxJZCIsInVwZGF0ZWRHYW1lQWNoaWV2ZW1lbnRzIiwiZ2FtZVR5cGVBY2hpZXZlbWVudHMiLCJTZXQiLCJ1cGRhdGVkQWNoaWV2ZW1lbnRzIiwiaGFzIiwiYWRkIiwic2VjdGlvbkNvbXBsZXRlZCIsImV2ZXJ5IiwibCIsIkFycmF5IiwiZnJvbSIsIm5ld0xhc3RTdHJlYWtEYXRlIiwibmV3U3RyZWFrU3RhdGUiLCJjYW5BY2Nlc3NMZXZlbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useGameProgress.ts\n"));

/***/ })

});