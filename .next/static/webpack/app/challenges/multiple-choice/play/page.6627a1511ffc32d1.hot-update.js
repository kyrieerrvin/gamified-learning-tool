"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/challenges/multiple-choice/play/page",{

/***/ "(app-pages-browser)/./src/hooks/useGameProgress.ts":
/*!**************************************!*\
  !*** ./src/hooks/useGameProgress.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameProgress: () => (/* binding */ useGameProgress)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var _context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/context/AuthContext */ \"(app-pages-browser)/./src/context/AuthContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ useGameProgress auto */ \n\n\n\n// Helper functions\nconst getTodayDateString = ()=>{\n    const today = new Date();\n    const year = today.getFullYear();\n    const month = String(today.getMonth() + 1).padStart(2, '0');\n    const day = String(today.getDate()).padStart(2, '0');\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n};\nconst isSameDay = (dateStr1, dateStr2)=>{\n    if (!dateStr1 || !dateStr2) return false;\n    return dateStr1 === dateStr2;\n};\nconst isConsecutiveDay = (lastDateStr, todayStr)=>{\n    if (!lastDateStr || !todayStr) return false;\n    const lastDate = new Date(lastDateStr);\n    const today = new Date(todayStr);\n    const timeDiff = today.getTime() - lastDate.getTime();\n    const daysDiff = timeDiff / (1000 * 3600 * 24);\n    return Math.round(daysDiff) === 1;\n};\n// Generate 3 Levels (Easy, Difficult, Hard) each with 10 challenges\nconst generateSections = ()=>{\n    const sections = [];\n    const levelNames = [\n        'Easy',\n        'Difficult',\n        'Hard'\n    ];\n    for(let sectionId = 0; sectionId < 3; sectionId++){\n        const levels = [];\n        for(let levelId = 0; levelId < 10; levelId++){\n            levels.push({\n                id: levelId,\n                title: \"Challenge \".concat(levelId + 1),\n                isLocked: !(sectionId === 0 && levelId === 0),\n                isCompleted: false,\n                bestScore: 0,\n                attempts: 0,\n                lastPlayed: null\n            });\n        }\n        sections.push({\n            id: sectionId,\n            title: \"Level \".concat(sectionId + 1, \": \").concat(levelNames[sectionId] || '').trim(),\n            description: \"Complete all challenges in \".concat(levelNames[sectionId] || \"Level \".concat(sectionId + 1)),\n            isLocked: sectionId !== 0,\n            isCompleted: false,\n            levels\n        });\n    }\n    return sections;\n};\n// Generate daily quests\nconst generateDailyQuests = ()=>{\n    const today = getTodayDateString();\n    const expiresAt = today; // Expires at end of today\n    return [\n        {\n            id: 'daily-xp',\n            title: 'Daily XP',\n            description: 'Earn 50 XP today',\n            reward: 10,\n            progress: 0,\n            target: 50,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'streak-bonus',\n            title: 'Get 3 Correct in a Row',\n            description: 'Answer three questions correctly in a row',\n            reward: 10,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'complete-games',\n            title: 'Complete 3 Games',\n            description: 'Complete any 3 games today (any score)',\n            reward: 15,\n            progress: 0,\n            target: 3,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'perfect-score',\n            title: 'Perfect Score',\n            description: 'Complete a level with a perfect score',\n            reward: 20,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        }\n    ];\n};\n// Default initial data\nconst getInitialData = (user)=>{\n    return {\n        profile: {\n            displayName: (user === null || user === void 0 ? void 0 : user.displayName) || null,\n            email: (user === null || user === void 0 ? void 0 : user.email) || null,\n            photoURL: (user === null || user === void 0 ? void 0 : user.photoURL) || null,\n            joinDate: new Date().toISOString(),\n            lastActiveDate: new Date().toISOString(),\n            gradeLevel: null,\n            preferences: {\n                emailNotifications: false,\n                dailyReminder: true\n            }\n        },\n        score: 0,\n        streak: 0,\n        lastStreakDate: '',\n        streakState: 'none',\n        totalChallengesCompleted: 0,\n        progress: {\n            'make-sentence': {\n                currentLevel: 0,\n                currentSection: 0,\n                sections: generateSections(),\n                xp: 0,\n                quests: generateDailyQuests(),\n                completedLevels: []\n            },\n            'multiple-choice': {\n                currentLevel: 0,\n                currentSection: 0,\n                sections: generateSections(),\n                xp: 0,\n                quests: generateDailyQuests(),\n                completedLevels: []\n            }\n        },\n        achievements: [],\n        gameAchievements: {},\n        recentChallenges: [],\n        updatedAt: new Date().toISOString()\n    };\n};\nconst useGameProgress = ()=>{\n    const { user } = (0,_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Real-time listener\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useGameProgress.useEffect\": ()=>{\n            if (!(user === null || user === void 0 ? void 0 : user.uid)) {\n                setLoading(false);\n                return;\n            }\n            console.log('[GameProgress] Setting up real-time listener for user:', user.uid);\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            const unsubscribe = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)(userDocRef, {\n                \"useGameProgress.useEffect.unsubscribe\": async (doc)=>{\n                    try {\n                        if (doc.exists()) {\n                            const docData = doc.data();\n                            console.log('[GameProgress] Real-time data received:', docData);\n                            // Migration: ensure 3 Levels with 10 challenges each for both games\n                            const needsMigration = {\n                                \"useGameProgress.useEffect.unsubscribe.needsMigration\": (progress)=>{\n                                    if (!progress || !progress.sections) return true;\n                                    if (progress.sections.length !== 3) return true;\n                                    for (const s of progress.sections){\n                                        if (!s.levels || s.levels.length !== 10) return true;\n                                    }\n                                    return false;\n                                }\n                            }[\"useGameProgress.useEffect.unsubscribe.needsMigration\"];\n                            const updatedProgress = {\n                                ...docData.progress\n                            };\n                            let didMigrate = false;\n                            for (const gameType of [\n                                'make-sentence',\n                                'multiple-choice'\n                            ]){\n                                var _docData_progress;\n                                const gp = (_docData_progress = docData.progress) === null || _docData_progress === void 0 ? void 0 : _docData_progress[gameType];\n                                if (!gp || needsMigration(gp)) {\n                                    didMigrate = true;\n                                    const sections = generateSections();\n                                    // Unlock first level and first challenge\n                                    if (sections.length > 0) {\n                                        sections[0].isLocked = false;\n                                        if (sections[0].levels.length > 0) sections[0].levels[0].isLocked = false;\n                                    }\n                                    updatedProgress[gameType] = {\n                                        sections,\n                                        xp: (gp === null || gp === void 0 ? void 0 : gp.xp) || 0,\n                                        quests: (gp === null || gp === void 0 ? void 0 : gp.quests) || [],\n                                        currentSection: 0,\n                                        currentLevel: 0,\n                                        completedLevels: []\n                                    };\n                                }\n                            }\n                            // Reset streak if a day was missed (device local date)\n                            try {\n                                const today = getTodayDateString();\n                                const missedDay = !!docData.lastStreakDate && !isSameDay(docData.lastStreakDate, today) && !isConsecutiveDay(docData.lastStreakDate, today) && (docData.streak || 0) > 0;\n                                if (missedDay) {\n                                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                                        streak: 0,\n                                        streakState: 'none',\n                                        updatedAt: new Date().toISOString()\n                                    });\n                                    docData.streak = 0;\n                                    docData.streakState = 'none';\n                                }\n                            } catch (e) {\n                                console.warn('[GameProgress] Streak reset check failed:', e);\n                            }\n                            if (didMigrate) {\n                                console.log('[GameProgress] Migrating progress to 3 levels × 10 challenges structure');\n                                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                                    progress: updatedProgress,\n                                    updatedAt: new Date().toISOString()\n                                });\n                                setData({\n                                    ...docData,\n                                    progress: updatedProgress\n                                });\n                            } else {\n                                setData(docData);\n                            }\n                        } else {\n                            // Create initial data if document doesn't exist\n                            console.log('[GameProgress] No document found, creating initial data');\n                            const initialData = getInitialData(user);\n                            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(userDocRef, initialData);\n                            setData(initialData);\n                        }\n                        setLoading(false);\n                        setError(null);\n                    } catch (err) {\n                        console.error('[GameProgress] Error processing real-time data:', err);\n                        setError(err instanceof Error ? err.message : 'Unknown error');\n                        setLoading(false);\n                    }\n                }\n            }[\"useGameProgress.useEffect.unsubscribe\"], {\n                \"useGameProgress.useEffect.unsubscribe\": (err)=>{\n                    console.error('[GameProgress] Real-time listener error:', err);\n                    setError(err.message);\n                    setLoading(false);\n                }\n            }[\"useGameProgress.useEffect.unsubscribe\"]);\n            return ({\n                \"useGameProgress.useEffect\": ()=>{\n                    console.log('[GameProgress] Cleaning up real-time listener');\n                    unsubscribe();\n                }\n            })[\"useGameProgress.useEffect\"];\n        }\n    }[\"useGameProgress.useEffect\"], [\n        user === null || user === void 0 ? void 0 : user.uid\n    ]);\n    // Action functions\n    const updateData = async (updates)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid)) return;\n        try {\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                ...updates,\n                updatedAt: new Date().toISOString()\n            });\n        } catch (err) {\n            console.error('[GameProgress] Error updating data:', err);\n            throw err;\n        }\n    };\n    const addPoints = async (points, gameType)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid)) return;\n        try {\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                [\"progress.\".concat(gameType, \".xp\")]: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.increment)(points),\n                score: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.increment)(points),\n                updatedAt: new Date().toISOString()\n            });\n        } catch (err) {\n            console.error('[GameProgress] Error incrementing XP:', err);\n            throw err;\n        }\n    };\n    const setQuests = async (gameType, quests)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid)) return;\n        try {\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                [\"progress.\".concat(gameType, \".quests\")]: quests,\n                updatedAt: new Date().toISOString()\n            });\n        } catch (err) {\n            console.error('[GameProgress] Error updating quests:', err);\n            throw err;\n        }\n    };\n    const increaseStreak = async ()=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const today = getTodayDateString();\n        let newStreak = data.streak;\n        // Don't increase if already played today\n        if (isSameDay(data.lastStreakDate, today)) {\n            return;\n        }\n        // Increase streak if consecutive day or starting new\n        if (isConsecutiveDay(data.lastStreakDate, today) || !data.lastStreakDate) {\n            newStreak += 1;\n        } else {\n            newStreak = 1; // Reset to 1 if missed days\n        }\n        await updateData({\n            streak: newStreak,\n            lastStreakDate: today,\n            streakState: 'active'\n        });\n    };\n    const completeLevel = async (gameType, sectionId, levelId, score)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress) return;\n        const updatedSections = [\n            ...gameProgress.sections\n        ];\n        const section = updatedSections[sectionId];\n        if (!section || !section.levels[levelId]) return;\n        const level = section.levels[levelId];\n        level.attempts = (level.attempts || 0) + 1;\n        level.lastPlayed = new Date().toISOString();\n        if (score !== undefined && (level.bestScore === undefined || score > level.bestScore)) {\n            level.bestScore = score;\n        }\n        // Treat invocation of completeLevel as \"finished the level\"\n        // Always mark as completed and advance unlocking\n        let nextSectionId = sectionId;\n        let nextLevelId = levelId;\n        level.isCompleted = true;\n        // Unlock next level or section\n        if (levelId < section.levels.length - 1) {\n            nextLevelId = levelId + 1;\n            section.levels[nextLevelId].isLocked = false;\n        } else {\n            // Completed section, unlock next section\n            section.isCompleted = true;\n            if (sectionId < updatedSections.length - 1) {\n                nextSectionId = sectionId + 1;\n                nextLevelId = 0;\n                updatedSections[nextSectionId].isLocked = false;\n                updatedSections[nextSectionId].levels[0].isLocked = false;\n            }\n        }\n        // Prepare achievements updates (simple MVP)\n        const updatedGameAchievements = {\n            ...data.gameAchievements || {}\n        };\n        const gameTypeAchievements = new Set(updatedGameAchievements[gameType] || []);\n        const updatedAchievements = new Set(data.achievements || []);\n        // First Steps: completing a first game\n        if (!gameTypeAchievements.has('first-steps')) {\n            gameTypeAchievements.add('first-steps');\n            updatedAchievements.add('first-steps');\n        }\n        // Perfect Score: score 100\n        if (score !== undefined && score >= 100 && !gameTypeAchievements.has('perfect-score')) {\n            gameTypeAchievements.add('perfect-score');\n            updatedAchievements.add('perfect-score');\n        }\n        // Section Champion: entire section completed\n        const sectionCompleted = section.levels.every((l)=>l.isCompleted);\n        if (sectionCompleted && !gameTypeAchievements.has('section-champion')) {\n            gameTypeAchievements.add('section-champion');\n            updatedAchievements.add('section-champion');\n        }\n        updatedGameAchievements[gameType] = Array.from(gameTypeAchievements);\n        await updateData({\n            progress: {\n                ...data.progress,\n                [gameType]: {\n                    ...gameProgress,\n                    sections: updatedSections,\n                    currentSection: nextSectionId,\n                    currentLevel: nextLevelId\n                }\n            },\n            achievements: Array.from(updatedAchievements),\n            gameAchievements: updatedGameAchievements\n        });\n    };\n    const canAccessLevel = (gameType, sectionId, levelId)=>{\n        if (!data || !data.progress[gameType]) return false;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress.sections || sectionId < 0 || sectionId >= gameProgress.sections.length) {\n            return false;\n        }\n        const section = gameProgress.sections[sectionId];\n        if (!section || section.isLocked) return false;\n        if (!section.levels || levelId < 0 || levelId >= section.levels.length) {\n            return false;\n        }\n        const level = section.levels[levelId];\n        return level && !level.isLocked;\n    };\n    return {\n        data,\n        loading,\n        error,\n        // Actions\n        updateData,\n        addPoints,\n        setQuests,\n        increaseStreak,\n        completeLevel,\n        canAccessLevel,\n        // Convenience getters\n        profile: (data === null || data === void 0 ? void 0 : data.profile) || null,\n        score: (data === null || data === void 0 ? void 0 : data.score) || 0,\n        streak: (data === null || data === void 0 ? void 0 : data.streak) || 0,\n        streakState: (data === null || data === void 0 ? void 0 : data.streakState) || 'none',\n        progress: (data === null || data === void 0 ? void 0 : data.progress) || {},\n        achievements: (data === null || data === void 0 ? void 0 : data.achievements) || [],\n        gameAchievements: (data === null || data === void 0 ? void 0 : data.gameAchievements) || {},\n        recentChallenges: (data === null || data === void 0 ? void 0 : data.recentChallenges) || []\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VHYW1lUHJvZ3Jlc3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FFQUU0QztBQUNtRDtBQUMzRDtBQUNZO0FBOEZoRCxtQkFBbUI7QUFDbkIsTUFBTVMscUJBQXFCO0lBQ3pCLE1BQU1DLFFBQVEsSUFBSUM7SUFDbEIsTUFBTUMsT0FBT0YsTUFBTUcsV0FBVztJQUM5QixNQUFNQyxRQUFRQyxPQUFPTCxNQUFNTSxRQUFRLEtBQUssR0FBR0MsUUFBUSxDQUFDLEdBQUc7SUFDdkQsTUFBTUMsTUFBTUgsT0FBT0wsTUFBTVMsT0FBTyxJQUFJRixRQUFRLENBQUMsR0FBRztJQUNoRCxPQUFPLEdBQVdILE9BQVJGLE1BQUssS0FBWU0sT0FBVEosT0FBTSxLQUFPLE9BQUpJO0FBQzdCO0FBRUEsTUFBTUUsWUFBWSxDQUFDQyxVQUFrQkM7SUFDbkMsSUFBSSxDQUFDRCxZQUFZLENBQUNDLFVBQVUsT0FBTztJQUNuQyxPQUFPRCxhQUFhQztBQUN0QjtBQUVBLE1BQU1DLG1CQUFtQixDQUFDQyxhQUFxQkM7SUFDN0MsSUFBSSxDQUFDRCxlQUFlLENBQUNDLFVBQVUsT0FBTztJQUV0QyxNQUFNQyxXQUFXLElBQUlmLEtBQUthO0lBQzFCLE1BQU1kLFFBQVEsSUFBSUMsS0FBS2M7SUFFdkIsTUFBTUUsV0FBV2pCLE1BQU1rQixPQUFPLEtBQUtGLFNBQVNFLE9BQU87SUFDbkQsTUFBTUMsV0FBV0YsV0FBWSxRQUFPLE9BQU8sRUFBQztJQUU1QyxPQUFPRyxLQUFLQyxLQUFLLENBQUNGLGNBQWM7QUFDbEM7QUFFQSxvRUFBb0U7QUFDcEUsTUFBTUcsbUJBQW1CO0lBQ3ZCLE1BQU1DLFdBQXNCLEVBQUU7SUFDOUIsTUFBTUMsYUFBYTtRQUFDO1FBQVE7UUFBYTtLQUFPO0lBRWhELElBQUssSUFBSUMsWUFBWSxHQUFHQSxZQUFZLEdBQUdBLFlBQWE7UUFDbEQsTUFBTUMsU0FBa0IsRUFBRTtRQUUxQixJQUFLLElBQUlD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d0IsUUFBUUQsUUFBUWxGLE1BQU0sQ0FBQ0MsUUFBUTtRQUNyQyxPQUFPa0YsU0FBUyxDQUFDQSxNQUFNOUUsUUFBUTtJQUNqQztJQUVBLE9BQU87UUFDTHdDO1FBQ0FFO1FBQ0FFO1FBQ0EsVUFBVTtRQUNWdUI7UUFDQUU7UUFDQUU7UUFDQUM7UUFDQUU7UUFDQW1CO1FBQ0Esc0JBQXNCO1FBQ3RCL0UsU0FBUzBCLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTTFCLE9BQU8sS0FBSTtRQUMxQlcsT0FBT2UsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNZixLQUFLLEtBQUk7UUFDdEJDLFFBQVFjLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTWQsTUFBTSxLQUFJO1FBQ3hCRSxhQUFhWSxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1aLFdBQVcsS0FBSTtRQUNsQ2xCLFVBQVU4QixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU05QixRQUFRLEtBQUksQ0FBQztRQUM3QnlCLGNBQWNLLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTUwsWUFBWSxLQUFJLEVBQUU7UUFDdENDLGtCQUFrQkksQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNSixnQkFBZ0IsS0FBSSxDQUFDO1FBQzdDQyxrQkFBa0JHLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTUgsZ0JBQWdCLEtBQUksRUFBRTtJQUNoRDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lcnZpbnJhcGhhZWxhbGJhL0Rlc2t0b3AvWDQyMC9zcmMvaG9va3MvdXNlR2FtZVByb2dyZXNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG9uU25hcHNob3QsIGRvYywgdXBkYXRlRG9jLCBzZXREb2MsIGluY3JlbWVudCwgYXJyYXlVbmlvbiB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJ0AvbGliL2ZpcmViYXNlJztcbmltcG9ydCB7IHVzZUF1dGggfSBmcm9tICdAL2NvbnRleHQvQXV0aENvbnRleHQnO1xuXG4vLyBUeXBlcyBmcm9tIGV4aXN0aW5nIGdhbWVTdG9yZVxuZXhwb3J0IHR5cGUgU2VjdGlvbiA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgdGl0bGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgaXNMb2NrZWQ6IGJvb2xlYW47XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBsZXZlbHM6IExldmVsW107XG59O1xuXG5leHBvcnQgdHlwZSBMZXZlbCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgdGl0bGU6IHN0cmluZztcbiAgaXNMb2NrZWQ6IGJvb2xlYW47XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBiZXN0U2NvcmU6IG51bWJlcjtcbiAgYXR0ZW1wdHM6IG51bWJlcjtcbiAgbGFzdFBsYXllZDogc3RyaW5nIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIERhaWx5UXVlc3QgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHJld2FyZDogbnVtYmVyO1xuICBwcm9ncmVzczogbnVtYmVyO1xuICB0YXJnZXQ6IG51bWJlcjtcbiAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47XG4gIGV4cGlyZXNBdDogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgVXNlclByb2ZpbGUgPSB7XG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsO1xuICBlbWFpbDogc3RyaW5nIHwgbnVsbDtcbiAgcGhvdG9VUkw6IHN0cmluZyB8IG51bGw7XG4gIGpvaW5EYXRlOiBzdHJpbmc7XG4gIGxhc3RBY3RpdmVEYXRlOiBzdHJpbmc7XG4gIGdyYWRlTGV2ZWw/OiAnRzFfMicgfCAnRzNfNCcgfCAnRzVfNicgfCBudWxsO1xuICBwcmVmZXJlbmNlczoge1xuICAgIGVtYWlsTm90aWZpY2F0aW9uczogYm9vbGVhbjtcbiAgICBkYWlseVJlbWluZGVyOiBib29sZWFuO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgQ2hhbGxlbmdlUmVzdWx0ID0ge1xuICBpZDogc3RyaW5nO1xuICBjaGFsbGVuZ2VUeXBlOiAnbWFrZS1zZW50ZW5jZScgfCAnbXVsdGlwbGUtY2hvaWNlJyB8ICdjb252ZXJzYXRpb24nO1xuICBzY29yZTogbnVtYmVyO1xuICBtYXhTY29yZTogbnVtYmVyO1xuICBjb21wbGV0ZWRBdDogc3RyaW5nO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBpc0NvcnJlY3Q6IGJvb2xlYW47XG4gIGdhbWVUeXBlOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBHYW1lUHJvZ3Jlc3NEYXRhID0ge1xuICAvLyBVc2VyIHByb2ZpbGVcbiAgcHJvZmlsZTogVXNlclByb2ZpbGUgfCBudWxsO1xuICBcbiAgLy8gR2FtZSBzdGF0aXN0aWNzXG4gIHNjb3JlOiBudW1iZXI7XG4gIHN0cmVhazogbnVtYmVyO1xuICBsYXN0U3RyZWFrRGF0ZTogc3RyaW5nO1xuICBzdHJlYWtTdGF0ZTogXCJub25lXCIgfCBcImluYWN0aXZlXCIgfCBcImFjdGl2ZVwiO1xuICB0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQ6IG51bWJlcjtcbiAgXG4gIC8vIEdhbWUgcHJvZ3Jlc3NcbiAgcHJvZ3Jlc3M6IHtcbiAgICBbZ2FtZVR5cGU6IHN0cmluZ106IHtcbiAgICAgIGN1cnJlbnRMZXZlbDogbnVtYmVyO1xuICAgICAgY3VycmVudFNlY3Rpb246IG51bWJlcjtcbiAgICAgIHNlY3Rpb25zOiBTZWN0aW9uW107XG4gICAgICB4cDogbnVtYmVyO1xuICAgICAgcXVlc3RzOiBEYWlseVF1ZXN0W107XG4gICAgICBjb21wbGV0ZWRMZXZlbHM6IHN0cmluZ1tdO1xuICAgICAgbGFzdFBsYXllZEF0Pzogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIFxuICAvLyBBY2hpZXZlbWVudHNcbiAgYWNoaWV2ZW1lbnRzOiBzdHJpbmdbXTtcbiAgZ2FtZUFjaGlldmVtZW50czoge1xuICAgIFtnYW1lVHlwZTogc3RyaW5nXTogc3RyaW5nW107XG4gIH07XG4gIFxuICAvLyBDaGFsbGVuZ2UgaGlzdG9yeVxuICByZWNlbnRDaGFsbGVuZ2VzOiBDaGFsbGVuZ2VSZXN1bHRbXTtcbiAgXG4gIC8vIE1ldGFkYXRhXG4gIHVwZGF0ZWRBdDogc3RyaW5nO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuY29uc3QgZ2V0VG9kYXlEYXRlU3RyaW5nID0gKCk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgeWVhciA9IHRvZGF5LmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IG1vbnRoID0gU3RyaW5nKHRvZGF5LmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpO1xuICBjb25zdCBkYXkgPSBTdHJpbmcodG9kYXkuZ2V0RGF0ZSgpKS5wYWRTdGFydCgyLCAnMCcpO1xuICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbn07XG5cbmNvbnN0IGlzU2FtZURheSA9IChkYXRlU3RyMTogc3RyaW5nLCBkYXRlU3RyMjogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIGlmICghZGF0ZVN0cjEgfHwgIWRhdGVTdHIyKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBkYXRlU3RyMSA9PT0gZGF0ZVN0cjI7XG59O1xuXG5jb25zdCBpc0NvbnNlY3V0aXZlRGF5ID0gKGxhc3REYXRlU3RyOiBzdHJpbmcsIHRvZGF5U3RyOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgaWYgKCFsYXN0RGF0ZVN0ciB8fCAhdG9kYXlTdHIpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IGxhc3REYXRlID0gbmV3IERhdGUobGFzdERhdGVTdHIpO1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKHRvZGF5U3RyKTtcbiAgXG4gIGNvbnN0IHRpbWVEaWZmID0gdG9kYXkuZ2V0VGltZSgpIC0gbGFzdERhdGUuZ2V0VGltZSgpO1xuICBjb25zdCBkYXlzRGlmZiA9IHRpbWVEaWZmIC8gKDEwMDAgKiAzNjAwICogMjQpO1xuICBcbiAgcmV0dXJuIE1hdGgucm91bmQoZGF5c0RpZmYpID09PSAxO1xufTtcblxuLy8gR2VuZXJhdGUgMyBMZXZlbHMgKEVhc3ksIERpZmZpY3VsdCwgSGFyZCkgZWFjaCB3aXRoIDEwIGNoYWxsZW5nZXNcbmNvbnN0IGdlbmVyYXRlU2VjdGlvbnMgPSAoKTogU2VjdGlvbltdID0+IHtcbiAgY29uc3Qgc2VjdGlvbnM6IFNlY3Rpb25bXSA9IFtdO1xuICBjb25zdCBsZXZlbE5hbWVzID0gWydFYXN5JywgJ0RpZmZpY3VsdCcsICdIYXJkJ107XG4gIFxuICBmb3IgKGxldCBzZWN0aW9uSWQgPSAwOyBzZWN0aW9uSWQgPCAzOyBzZWN0aW9uSWQrKykge1xuICAgIGNvbnN0IGxldmVsczogTGV2ZWxbXSA9IFtdO1xuICAgIFxuICAgIGZvciAobGV0IGxldmVsSWQgPSAwOyBsZXZlbElkIDwgMTA7IGxldmVsSWQrKykge1xuICAgICAgbGV2ZWxzLnB1c2goe1xuICAgICAgICBpZDogbGV2ZWxJZCxcbiAgICAgICAgdGl0bGU6IGBDaGFsbGVuZ2UgJHtsZXZlbElkICsgMX1gLFxuICAgICAgICBpc0xvY2tlZDogIShzZWN0aW9uSWQgPT09IDAgJiYgbGV2ZWxJZCA9PT0gMCksIC8vIE9ubHkgZmlyc3QgY2hhbGxlbmdlIHVubG9ja2VkXG4gICAgICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgYmVzdFNjb3JlOiAwLFxuICAgICAgICBhdHRlbXB0czogMCxcbiAgICAgICAgbGFzdFBsYXllZDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgaWQ6IHNlY3Rpb25JZCxcbiAgICAgIHRpdGxlOiBgTGV2ZWwgJHtzZWN0aW9uSWQgKyAxfTogJHtsZXZlbE5hbWVzW3NlY3Rpb25JZF0gfHwgJyd9YC50cmltKCksXG4gICAgICBkZXNjcmlwdGlvbjogYENvbXBsZXRlIGFsbCBjaGFsbGVuZ2VzIGluICR7bGV2ZWxOYW1lc1tzZWN0aW9uSWRdIHx8IGBMZXZlbCAke3NlY3Rpb25JZCArIDF9YH1gLFxuICAgICAgaXNMb2NrZWQ6IHNlY3Rpb25JZCAhPT0gMCwgLy8gT25seSBmaXJzdCBsZXZlbCB1bmxvY2tlZFxuICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgbGV2ZWxzXG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBzZWN0aW9ucztcbn07XG5cbi8vIEdlbmVyYXRlIGRhaWx5IHF1ZXN0c1xuY29uc3QgZ2VuZXJhdGVEYWlseVF1ZXN0cyA9ICgpOiBEYWlseVF1ZXN0W10gPT4ge1xuICBjb25zdCB0b2RheSA9IGdldFRvZGF5RGF0ZVN0cmluZygpO1xuICBjb25zdCBleHBpcmVzQXQgPSB0b2RheTsgLy8gRXhwaXJlcyBhdCBlbmQgb2YgdG9kYXlcbiAgXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgaWQ6ICdkYWlseS14cCcsXG4gICAgICB0aXRsZTogJ0RhaWx5IFhQJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRWFybiA1MCBYUCB0b2RheScsXG4gICAgICByZXdhcmQ6IDEwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB0YXJnZXQ6IDUwLFxuICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgZXhwaXJlc0F0XG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ3N0cmVhay1ib251cycsXG4gICAgICB0aXRsZTogJ0dldCAzIENvcnJlY3QgaW4gYSBSb3cnLFxuICAgICAgZGVzY3JpcHRpb246ICdBbnN3ZXIgdGhyZWUgcXVlc3Rpb25zIGNvcnJlY3RseSBpbiBhIHJvdycsXG4gICAgICByZXdhcmQ6IDEwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB0YXJnZXQ6IDEsXG4gICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICBleHBpcmVzQXRcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAnY29tcGxldGUtZ2FtZXMnLFxuICAgICAgdGl0bGU6ICdDb21wbGV0ZSAzIEdhbWVzJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29tcGxldGUgYW55IDMgZ2FtZXMgdG9kYXkgKGFueSBzY29yZSknLFxuICAgICAgcmV3YXJkOiAxNSxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgdGFyZ2V0OiAzLFxuICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgZXhwaXJlc0F0XG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ3BlcmZlY3Qtc2NvcmUnLFxuICAgICAgdGl0bGU6ICdQZXJmZWN0IFNjb3JlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29tcGxldGUgYSBsZXZlbCB3aXRoIGEgcGVyZmVjdCBzY29yZScsXG4gICAgICByZXdhcmQ6IDIwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB0YXJnZXQ6IDEsXG4gICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICBleHBpcmVzQXRcbiAgICB9XG4gIF07XG59O1xuXG4vLyBEZWZhdWx0IGluaXRpYWwgZGF0YVxuY29uc3QgZ2V0SW5pdGlhbERhdGEgPSAodXNlcjogYW55KTogR2FtZVByb2dyZXNzRGF0YSA9PiB7XG4gIHJldHVybiB7XG4gICAgcHJvZmlsZToge1xuICAgICAgZGlzcGxheU5hbWU6IHVzZXI/LmRpc3BsYXlOYW1lIHx8IG51bGwsXG4gICAgICBlbWFpbDogdXNlcj8uZW1haWwgfHwgbnVsbCxcbiAgICAgIHBob3RvVVJMOiB1c2VyPy5waG90b1VSTCB8fCBudWxsLFxuICAgICAgam9pbkRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGxhc3RBY3RpdmVEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBncmFkZUxldmVsOiBudWxsLFxuICAgICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgZW1haWxOb3RpZmljYXRpb25zOiBmYWxzZSxcbiAgICAgICAgZGFpbHlSZW1pbmRlcjogdHJ1ZSxcbiAgICAgIH1cbiAgICB9LFxuICAgIHNjb3JlOiAwLFxuICAgIHN0cmVhazogMCxcbiAgICBsYXN0U3RyZWFrRGF0ZTogJycsXG4gICAgc3RyZWFrU3RhdGU6ICdub25lJyxcbiAgICB0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQ6IDAsXG4gICAgcHJvZ3Jlc3M6IHtcbiAgICAgICdtYWtlLXNlbnRlbmNlJzoge1xuICAgICAgICBjdXJyZW50TGV2ZWw6IDAsXG4gICAgICAgIGN1cnJlbnRTZWN0aW9uOiAwLFxuICAgICAgICBzZWN0aW9uczogZ2VuZXJhdGVTZWN0aW9ucygpLFxuICAgICAgICB4cDogMCxcbiAgICAgICAgcXVlc3RzOiBnZW5lcmF0ZURhaWx5UXVlc3RzKCksXG4gICAgICAgIGNvbXBsZXRlZExldmVsczogW10sXG4gICAgICB9LFxuICAgICAgJ211bHRpcGxlLWNob2ljZSc6IHtcbiAgICAgICAgY3VycmVudExldmVsOiAwLFxuICAgICAgICBjdXJyZW50U2VjdGlvbjogMCxcbiAgICAgICAgc2VjdGlvbnM6IGdlbmVyYXRlU2VjdGlvbnMoKSxcbiAgICAgICAgeHA6IDAsXG4gICAgICAgIHF1ZXN0czogZ2VuZXJhdGVEYWlseVF1ZXN0cygpLFxuICAgICAgICBjb21wbGV0ZWRMZXZlbHM6IFtdLFxuICAgICAgfVxuICAgIH0sXG4gICAgYWNoaWV2ZW1lbnRzOiBbXSxcbiAgICBnYW1lQWNoaWV2ZW1lbnRzOiB7fSxcbiAgICByZWNlbnRDaGFsbGVuZ2VzOiBbXSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZUdhbWVQcm9ncmVzcyA9ICgpID0+IHtcbiAgY29uc3QgeyB1c2VyIH0gPSB1c2VBdXRoKCk7XG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IHVzZVN0YXRlPEdhbWVQcm9ncmVzc0RhdGEgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIFxuICAvLyBSZWFsLXRpbWUgbGlzdGVuZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXVzZXI/LnVpZCkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdbR2FtZVByb2dyZXNzXSBTZXR0aW5nIHVwIHJlYWwtdGltZSBsaXN0ZW5lciBmb3IgdXNlcjonLCB1c2VyLnVpZCk7XG4gICAgXG4gICAgY29uc3QgdXNlckRvY1JlZiA9IGRvYyhkYiwgJ2dhbWVQcm9ncmVzcycsIHVzZXIudWlkKTtcbiAgICBcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IG9uU25hcHNob3QoXG4gICAgICB1c2VyRG9jUmVmLFxuICAgICAgYXN5bmMgKGRvYykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChkb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY0RhdGEgPSBkb2MuZGF0YSgpIGFzIEdhbWVQcm9ncmVzc0RhdGE7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0dhbWVQcm9ncmVzc10gUmVhbC10aW1lIGRhdGEgcmVjZWl2ZWQ6JywgZG9jRGF0YSk7XG5cbiAgICAgICAgICAgIC8vIE1pZ3JhdGlvbjogZW5zdXJlIDMgTGV2ZWxzIHdpdGggMTAgY2hhbGxlbmdlcyBlYWNoIGZvciBib3RoIGdhbWVzXG4gICAgICAgICAgICBjb25zdCBuZWVkc01pZ3JhdGlvbiA9IChwcm9ncmVzczogYW55KTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICAgIGlmICghcHJvZ3Jlc3MgfHwgIXByb2dyZXNzLnNlY3Rpb25zKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKHByb2dyZXNzLnNlY3Rpb25zLmxlbmd0aCAhPT0gMykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBwcm9ncmVzcy5zZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghcy5sZXZlbHMgfHwgcy5sZXZlbHMubGVuZ3RoICE9PSAxMCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2dyZXNzOiBhbnkgPSB7IC4uLmRvY0RhdGEucHJvZ3Jlc3MgfTtcbiAgICAgICAgICAgIGxldCBkaWRNaWdyYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2FtZVR5cGUgb2YgWydtYWtlLXNlbnRlbmNlJywgJ211bHRpcGxlLWNob2ljZSddKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGdwID0gZG9jRGF0YS5wcm9ncmVzcz8uW2dhbWVUeXBlXTtcbiAgICAgICAgICAgICAgaWYgKCFncCB8fCBuZWVkc01pZ3JhdGlvbihncCkpIHtcbiAgICAgICAgICAgICAgICBkaWRNaWdyYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9ucyA9IGdlbmVyYXRlU2VjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAvLyBVbmxvY2sgZmlyc3QgbGV2ZWwgYW5kIGZpcnN0IGNoYWxsZW5nZVxuICAgICAgICAgICAgICAgIGlmIChzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBzZWN0aW9uc1swXS5pc0xvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb25zWzBdLmxldmVscy5sZW5ndGggPiAwKSBzZWN0aW9uc1swXS5sZXZlbHNbMF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlZFByb2dyZXNzW2dhbWVUeXBlXSA9IHtcbiAgICAgICAgICAgICAgICAgIHNlY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgeHA6IGdwPy54cCB8fCAwLFxuICAgICAgICAgICAgICAgICAgcXVlc3RzOiBncD8ucXVlc3RzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFNlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgICBjb21wbGV0ZWRMZXZlbHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCBzdHJlYWsgaWYgYSBkYXkgd2FzIG1pc3NlZCAoZGV2aWNlIGxvY2FsIGRhdGUpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB0b2RheSA9IGdldFRvZGF5RGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgICBjb25zdCBtaXNzZWREYXkgPSAhIWRvY0RhdGEubGFzdFN0cmVha0RhdGUgJiZcbiAgICAgICAgICAgICAgICAhaXNTYW1lRGF5KGRvY0RhdGEubGFzdFN0cmVha0RhdGUsIHRvZGF5KSAmJlxuICAgICAgICAgICAgICAgICFpc0NvbnNlY3V0aXZlRGF5KGRvY0RhdGEubGFzdFN0cmVha0RhdGUsIHRvZGF5KSAmJlxuICAgICAgICAgICAgICAgIChkb2NEYXRhLnN0cmVhayB8fCAwKSA+IDA7XG4gICAgICAgICAgICAgIGlmIChtaXNzZWREYXkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVEb2ModXNlckRvY1JlZiwge1xuICAgICAgICAgICAgICAgICAgc3RyZWFrOiAwLFxuICAgICAgICAgICAgICAgICAgc3RyZWFrU3RhdGU6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9jRGF0YS5zdHJlYWsgPSAwO1xuICAgICAgICAgICAgICAgIGRvY0RhdGEuc3RyZWFrU3RhdGUgPSAnbm9uZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbR2FtZVByb2dyZXNzXSBTdHJlYWsgcmVzZXQgY2hlY2sgZmFpbGVkOicsIGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlkTWlncmF0ZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0dhbWVQcm9ncmVzc10gTWlncmF0aW5nIHByb2dyZXNzIHRvIDMgbGV2ZWxzIMOXIDEwIGNoYWxsZW5nZXMgc3RydWN0dXJlJyk7XG4gICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZURvYyh1c2VyRG9jUmVmLCB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHVwZGF0ZWRQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2V0RGF0YSh7IC4uLmRvY0RhdGEsIHByb2dyZXNzOiB1cGRhdGVkUHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXREYXRhKGRvY0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgaW5pdGlhbCBkYXRhIGlmIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbR2FtZVByb2dyZXNzXSBObyBkb2N1bWVudCBmb3VuZCwgY3JlYXRpbmcgaW5pdGlhbCBkYXRhJyk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsRGF0YSA9IGdldEluaXRpYWxEYXRhKHVzZXIpO1xuICAgICAgICAgICAgYXdhaXQgc2V0RG9jKHVzZXJEb2NSZWYsIGluaXRpYWxEYXRhKTtcbiAgICAgICAgICAgIHNldERhdGEoaW5pdGlhbERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW0dhbWVQcm9ncmVzc10gRXJyb3IgcHJvY2Vzc2luZyByZWFsLXRpbWUgZGF0YTonLCBlcnIpO1xuICAgICAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpO1xuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbR2FtZVByb2dyZXNzXSBSZWFsLXRpbWUgbGlzdGVuZXIgZXJyb3I6JywgZXJyKTtcbiAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICApO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnW0dhbWVQcm9ncmVzc10gQ2xlYW5pbmcgdXAgcmVhbC10aW1lIGxpc3RlbmVyJyk7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFt1c2VyPy51aWRdKTtcbiAgXG4gIC8vIEFjdGlvbiBmdW5jdGlvbnNcbiAgY29uc3QgdXBkYXRlRGF0YSA9IGFzeW5jICh1cGRhdGVzOiBQYXJ0aWFsPEdhbWVQcm9ncmVzc0RhdGE+KSA9PiB7XG4gICAgaWYgKCF1c2VyPy51aWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlckRvY1JlZiA9IGRvYyhkYiwgJ2dhbWVQcm9ncmVzcycsIHVzZXIudWlkKTtcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyh1c2VyRG9jUmVmLCB7XG4gICAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tHYW1lUHJvZ3Jlc3NdIEVycm9yIHVwZGF0aW5nIGRhdGE6JywgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBhZGRQb2ludHMgPSBhc3luYyAocG9pbnRzOiBudW1iZXIsIGdhbWVUeXBlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXI/LnVpZCkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyRG9jUmVmID0gZG9jKGRiLCAnZ2FtZVByb2dyZXNzJywgdXNlci51aWQpO1xuICAgICAgYXdhaXQgdXBkYXRlRG9jKHVzZXJEb2NSZWYsIHtcbiAgICAgICAgW2Bwcm9ncmVzcy4ke2dhbWVUeXBlfS54cGBdOiBpbmNyZW1lbnQocG9pbnRzKSxcbiAgICAgICAgc2NvcmU6IGluY3JlbWVudChwb2ludHMpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbR2FtZVByb2dyZXNzXSBFcnJvciBpbmNyZW1lbnRpbmcgWFA6JywgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2V0UXVlc3RzID0gYXN5bmMgKGdhbWVUeXBlOiBzdHJpbmcsIHF1ZXN0czogRGFpbHlRdWVzdFtdKSA9PiB7XG4gICAgaWYgKCF1c2VyPy51aWQpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlckRvY1JlZiA9IGRvYyhkYiwgJ2dhbWVQcm9ncmVzcycsIHVzZXIudWlkKTtcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyh1c2VyRG9jUmVmLCB7XG4gICAgICAgIFtgcHJvZ3Jlc3MuJHtnYW1lVHlwZX0ucXVlc3RzYF06IHF1ZXN0cyxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignW0dhbWVQcm9ncmVzc10gRXJyb3IgdXBkYXRpbmcgcXVlc3RzOicsIGVycik7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgaW5jcmVhc2VTdHJlYWsgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF1c2VyPy51aWQgfHwgIWRhdGEpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB0b2RheSA9IGdldFRvZGF5RGF0ZVN0cmluZygpO1xuICAgIGxldCBuZXdTdHJlYWsgPSBkYXRhLnN0cmVhaztcbiAgICBcbiAgICAvLyBEb24ndCBpbmNyZWFzZSBpZiBhbHJlYWR5IHBsYXllZCB0b2RheVxuICAgIGlmIChpc1NhbWVEYXkoZGF0YS5sYXN0U3RyZWFrRGF0ZSwgdG9kYXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIEluY3JlYXNlIHN0cmVhayBpZiBjb25zZWN1dGl2ZSBkYXkgb3Igc3RhcnRpbmcgbmV3XG4gICAgaWYgKGlzQ29uc2VjdXRpdmVEYXkoZGF0YS5sYXN0U3RyZWFrRGF0ZSwgdG9kYXkpIHx8ICFkYXRhLmxhc3RTdHJlYWtEYXRlKSB7XG4gICAgICBuZXdTdHJlYWsgKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RyZWFrID0gMTsgLy8gUmVzZXQgdG8gMSBpZiBtaXNzZWQgZGF5c1xuICAgIH1cbiAgICBcbiAgICBhd2FpdCB1cGRhdGVEYXRhKHtcbiAgICAgIHN0cmVhazogbmV3U3RyZWFrLFxuICAgICAgbGFzdFN0cmVha0RhdGU6IHRvZGF5LFxuICAgICAgc3RyZWFrU3RhdGU6ICdhY3RpdmUnXG4gICAgfSk7XG4gIH07XG4gIFxuICBjb25zdCBjb21wbGV0ZUxldmVsID0gYXN5bmMgKGdhbWVUeXBlOiBzdHJpbmcsIHNlY3Rpb25JZDogbnVtYmVyLCBsZXZlbElkOiBudW1iZXIsIHNjb3JlPzogbnVtYmVyKSA9PiB7XG4gICAgaWYgKCF1c2VyPy51aWQgfHwgIWRhdGEpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBnYW1lUHJvZ3Jlc3MgPSBkYXRhLnByb2dyZXNzW2dhbWVUeXBlXTtcbiAgICBpZiAoIWdhbWVQcm9ncmVzcykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHVwZGF0ZWRTZWN0aW9ucyA9IFsuLi5nYW1lUHJvZ3Jlc3Muc2VjdGlvbnNdO1xuICAgIGNvbnN0IHNlY3Rpb24gPSB1cGRhdGVkU2VjdGlvbnNbc2VjdGlvbklkXTtcbiAgICBpZiAoIXNlY3Rpb24gfHwgIXNlY3Rpb24ubGV2ZWxzW2xldmVsSWRdKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgbGV2ZWwgPSBzZWN0aW9uLmxldmVsc1tsZXZlbElkXTtcbiAgICBsZXZlbC5hdHRlbXB0cyA9IChsZXZlbC5hdHRlbXB0cyB8fCAwKSArIDE7XG4gICAgbGV2ZWwubGFzdFBsYXllZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBcbiAgICBpZiAoc2NvcmUgIT09IHVuZGVmaW5lZCAmJiAobGV2ZWwuYmVzdFNjb3JlID09PSB1bmRlZmluZWQgfHwgc2NvcmUgPiBsZXZlbC5iZXN0U2NvcmUpKSB7XG4gICAgICBsZXZlbC5iZXN0U2NvcmUgPSBzY29yZTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJlYXQgaW52b2NhdGlvbiBvZiBjb21wbGV0ZUxldmVsIGFzIFwiZmluaXNoZWQgdGhlIGxldmVsXCJcbiAgICAvLyBBbHdheXMgbWFyayBhcyBjb21wbGV0ZWQgYW5kIGFkdmFuY2UgdW5sb2NraW5nXG4gICAgbGV0IG5leHRTZWN0aW9uSWQgPSBzZWN0aW9uSWQ7XG4gICAgbGV0IG5leHRMZXZlbElkID0gbGV2ZWxJZDtcbiAgICBcbiAgICBsZXZlbC5pc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgXG4gICAgLy8gVW5sb2NrIG5leHQgbGV2ZWwgb3Igc2VjdGlvblxuICAgIGlmIChsZXZlbElkIDwgc2VjdGlvbi5sZXZlbHMubGVuZ3RoIC0gMSkge1xuICAgICAgbmV4dExldmVsSWQgPSBsZXZlbElkICsgMTtcbiAgICAgIHNlY3Rpb24ubGV2ZWxzW25leHRMZXZlbElkXS5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb21wbGV0ZWQgc2VjdGlvbiwgdW5sb2NrIG5leHQgc2VjdGlvblxuICAgICAgc2VjdGlvbi5pc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICBpZiAoc2VjdGlvbklkIDwgdXBkYXRlZFNlY3Rpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbmV4dFNlY3Rpb25JZCA9IHNlY3Rpb25JZCArIDE7XG4gICAgICAgIG5leHRMZXZlbElkID0gMDtcbiAgICAgICAgdXBkYXRlZFNlY3Rpb25zW25leHRTZWN0aW9uSWRdLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHVwZGF0ZWRTZWN0aW9uc1tuZXh0U2VjdGlvbklkXS5sZXZlbHNbMF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIGFjaGlldmVtZW50cyB1cGRhdGVzIChzaW1wbGUgTVZQKVxuICAgIGNvbnN0IHVwZGF0ZWRHYW1lQWNoaWV2ZW1lbnRzID0geyAuLi4oZGF0YS5nYW1lQWNoaWV2ZW1lbnRzIHx8IHt9KSB9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPjtcbiAgICBjb25zdCBnYW1lVHlwZUFjaGlldmVtZW50cyA9IG5ldyBTZXQ8c3RyaW5nPih1cGRhdGVkR2FtZUFjaGlldmVtZW50c1tnYW1lVHlwZV0gfHwgW10pO1xuICAgIGNvbnN0IHVwZGF0ZWRBY2hpZXZlbWVudHMgPSBuZXcgU2V0PHN0cmluZz4oZGF0YS5hY2hpZXZlbWVudHMgfHwgW10pO1xuXG4gICAgLy8gRmlyc3QgU3RlcHM6IGNvbXBsZXRpbmcgYSBmaXJzdCBnYW1lXG4gICAgaWYgKCFnYW1lVHlwZUFjaGlldmVtZW50cy5oYXMoJ2ZpcnN0LXN0ZXBzJykpIHtcbiAgICAgIGdhbWVUeXBlQWNoaWV2ZW1lbnRzLmFkZCgnZmlyc3Qtc3RlcHMnKTtcbiAgICAgIHVwZGF0ZWRBY2hpZXZlbWVudHMuYWRkKCdmaXJzdC1zdGVwcycpO1xuICAgIH1cbiAgICAvLyBQZXJmZWN0IFNjb3JlOiBzY29yZSAxMDBcbiAgICBpZiAoc2NvcmUgIT09IHVuZGVmaW5lZCAmJiBzY29yZSA+PSAxMDAgJiYgIWdhbWVUeXBlQWNoaWV2ZW1lbnRzLmhhcygncGVyZmVjdC1zY29yZScpKSB7XG4gICAgICBnYW1lVHlwZUFjaGlldmVtZW50cy5hZGQoJ3BlcmZlY3Qtc2NvcmUnKTtcbiAgICAgIHVwZGF0ZWRBY2hpZXZlbWVudHMuYWRkKCdwZXJmZWN0LXNjb3JlJyk7XG4gICAgfVxuICAgIC8vIFNlY3Rpb24gQ2hhbXBpb246IGVudGlyZSBzZWN0aW9uIGNvbXBsZXRlZFxuICAgIGNvbnN0IHNlY3Rpb25Db21wbGV0ZWQgPSBzZWN0aW9uLmxldmVscy5ldmVyeShsID0+IGwuaXNDb21wbGV0ZWQpO1xuICAgIGlmIChzZWN0aW9uQ29tcGxldGVkICYmICFnYW1lVHlwZUFjaGlldmVtZW50cy5oYXMoJ3NlY3Rpb24tY2hhbXBpb24nKSkge1xuICAgICAgZ2FtZVR5cGVBY2hpZXZlbWVudHMuYWRkKCdzZWN0aW9uLWNoYW1waW9uJyk7XG4gICAgICB1cGRhdGVkQWNoaWV2ZW1lbnRzLmFkZCgnc2VjdGlvbi1jaGFtcGlvbicpO1xuICAgIH1cbiAgICB1cGRhdGVkR2FtZUFjaGlldmVtZW50c1tnYW1lVHlwZV0gPSBBcnJheS5mcm9tKGdhbWVUeXBlQWNoaWV2ZW1lbnRzKTtcbiAgICBcbiAgICBhd2FpdCB1cGRhdGVEYXRhKHtcbiAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgIC4uLmRhdGEucHJvZ3Jlc3MsXG4gICAgICAgIFtnYW1lVHlwZV06IHtcbiAgICAgICAgICAuLi5nYW1lUHJvZ3Jlc3MsXG4gICAgICAgICAgc2VjdGlvbnM6IHVwZGF0ZWRTZWN0aW9ucyxcbiAgICAgICAgICBjdXJyZW50U2VjdGlvbjogbmV4dFNlY3Rpb25JZCxcbiAgICAgICAgICBjdXJyZW50TGV2ZWw6IG5leHRMZXZlbElkXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhY2hpZXZlbWVudHM6IEFycmF5LmZyb20odXBkYXRlZEFjaGlldmVtZW50cyksXG4gICAgICBnYW1lQWNoaWV2ZW1lbnRzOiB1cGRhdGVkR2FtZUFjaGlldmVtZW50c1xuICAgIH0pO1xuICB9O1xuICBcbiAgY29uc3QgY2FuQWNjZXNzTGV2ZWwgPSAoZ2FtZVR5cGU6IHN0cmluZywgc2VjdGlvbklkOiBudW1iZXIsIGxldmVsSWQ6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghZGF0YSB8fCAhZGF0YS5wcm9ncmVzc1tnYW1lVHlwZV0pIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICBjb25zdCBnYW1lUHJvZ3Jlc3MgPSBkYXRhLnByb2dyZXNzW2dhbWVUeXBlXTtcbiAgICBpZiAoIWdhbWVQcm9ncmVzcy5zZWN0aW9ucyB8fCBzZWN0aW9uSWQgPCAwIHx8IHNlY3Rpb25JZCA+PSBnYW1lUHJvZ3Jlc3Muc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHNlY3Rpb24gPSBnYW1lUHJvZ3Jlc3Muc2VjdGlvbnNbc2VjdGlvbklkXTtcbiAgICBpZiAoIXNlY3Rpb24gfHwgc2VjdGlvbi5pc0xvY2tlZCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIGlmICghc2VjdGlvbi5sZXZlbHMgfHwgbGV2ZWxJZCA8IDAgfHwgbGV2ZWxJZCA+PSBzZWN0aW9uLmxldmVscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgbGV2ZWwgPSBzZWN0aW9uLmxldmVsc1tsZXZlbElkXTtcbiAgICByZXR1cm4gbGV2ZWwgJiYgIWxldmVsLmlzTG9ja2VkO1xuICB9O1xuICBcbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgLy8gQWN0aW9uc1xuICAgIHVwZGF0ZURhdGEsXG4gICAgYWRkUG9pbnRzLFxuICAgIHNldFF1ZXN0cyxcbiAgICBpbmNyZWFzZVN0cmVhayxcbiAgICBjb21wbGV0ZUxldmVsLFxuICAgIGNhbkFjY2Vzc0xldmVsLFxuICAgIC8vIENvbnZlbmllbmNlIGdldHRlcnNcbiAgICBwcm9maWxlOiBkYXRhPy5wcm9maWxlIHx8IG51bGwsXG4gICAgc2NvcmU6IGRhdGE/LnNjb3JlIHx8IDAsXG4gICAgc3RyZWFrOiBkYXRhPy5zdHJlYWsgfHwgMCxcbiAgICBzdHJlYWtTdGF0ZTogZGF0YT8uc3RyZWFrU3RhdGUgfHwgJ25vbmUnLFxuICAgIHByb2dyZXNzOiBkYXRhPy5wcm9ncmVzcyB8fCB7fSxcbiAgICBhY2hpZXZlbWVudHM6IGRhdGE/LmFjaGlldmVtZW50cyB8fCBbXSxcbiAgICBnYW1lQWNoaWV2ZW1lbnRzOiBkYXRhPy5nYW1lQWNoaWV2ZW1lbnRzIHx8IHt9LFxuICAgIHJlY2VudENoYWxsZW5nZXM6IGRhdGE/LnJlY2VudENoYWxsZW5nZXMgfHwgW11cbiAgfTtcbn07ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIm9uU25hcHNob3QiLCJkb2MiLCJ1cGRhdGVEb2MiLCJzZXREb2MiLCJpbmNyZW1lbnQiLCJkYiIsInVzZUF1dGgiLCJnZXRUb2RheURhdGVTdHJpbmciLCJ0b2RheSIsIkRhdGUiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJtb250aCIsIlN0cmluZyIsImdldE1vbnRoIiwicGFkU3RhcnQiLCJkYXkiLCJnZXREYXRlIiwiaXNTYW1lRGF5IiwiZGF0ZVN0cjEiLCJkYXRlU3RyMiIsImlzQ29uc2VjdXRpdmVEYXkiLCJsYXN0RGF0ZVN0ciIsInRvZGF5U3RyIiwibGFzdERhdGUiLCJ0aW1lRGlmZiIsImdldFRpbWUiLCJkYXlzRGlmZiIsIk1hdGgiLCJyb3VuZCIsImdlbmVyYXRlU2VjdGlvbnMiLCJzZWN0aW9ucyIsImxldmVsTmFtZXMiLCJzZWN0aW9uSWQiLCJsZXZlbHMiLCJsZXZlbElkIiwicHVzaCIsImlkIiwidGl0bGUiLCJpc0xvY2tlZCIsImlzQ29tcGxldGVkIiwiYmVzdFNjb3JlIiwiYXR0ZW1wdHMiLCJsYXN0UGxheWVkIiwidHJpbSIsImRlc2NyaXB0aW9uIiwiZ2VuZXJhdGVEYWlseVF1ZXN0cyIsImV4cGlyZXNBdCIsInJld2FyZCIsInByb2dyZXNzIiwidGFyZ2V0IiwiZ2V0SW5pdGlhbERhdGEiLCJ1c2VyIiwicHJvZmlsZSIsImRpc3BsYXlOYW1lIiwiZW1haWwiLCJwaG90b1VSTCIsImpvaW5EYXRlIiwidG9JU09TdHJpbmciLCJsYXN0QWN0aXZlRGF0ZSIsImdyYWRlTGV2ZWwiLCJwcmVmZXJlbmNlcyIsImVtYWlsTm90aWZpY2F0aW9ucyIsImRhaWx5UmVtaW5kZXIiLCJzY29yZSIsInN0cmVhayIsImxhc3RTdHJlYWtEYXRlIiwic3RyZWFrU3RhdGUiLCJ0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQiLCJjdXJyZW50TGV2ZWwiLCJjdXJyZW50U2VjdGlvbiIsInhwIiwicXVlc3RzIiwiY29tcGxldGVkTGV2ZWxzIiwiYWNoaWV2ZW1lbnRzIiwiZ2FtZUFjaGlldmVtZW50cyIsInJlY2VudENoYWxsZW5nZXMiLCJ1cGRhdGVkQXQiLCJ1c2VHYW1lUHJvZ3Jlc3MiLCJkYXRhIiwic2V0RGF0YSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInVpZCIsImNvbnNvbGUiLCJsb2ciLCJ1c2VyRG9jUmVmIiwidW5zdWJzY3JpYmUiLCJleGlzdHMiLCJkb2NEYXRhIiwibmVlZHNNaWdyYXRpb24iLCJsZW5ndGgiLCJzIiwidXBkYXRlZFByb2dyZXNzIiwiZGlkTWlncmF0ZSIsImdhbWVUeXBlIiwiZ3AiLCJtaXNzZWREYXkiLCJlIiwid2FybiIsImluaXRpYWxEYXRhIiwiZXJyIiwiRXJyb3IiLCJtZXNzYWdlIiwidXBkYXRlRGF0YSIsInVwZGF0ZXMiLCJhZGRQb2ludHMiLCJwb2ludHMiLCJzZXRRdWVzdHMiLCJpbmNyZWFzZVN0cmVhayIsIm5ld1N0cmVhayIsImNvbXBsZXRlTGV2ZWwiLCJnYW1lUHJvZ3Jlc3MiLCJ1cGRhdGVkU2VjdGlvbnMiLCJzZWN0aW9uIiwibGV2ZWwiLCJ1bmRlZmluZWQiLCJuZXh0U2VjdGlvbklkIiwibmV4dExldmVsSWQiLCJ1cGRhdGVkR2FtZUFjaGlldmVtZW50cyIsImdhbWVUeXBlQWNoaWV2ZW1lbnRzIiwiU2V0IiwidXBkYXRlZEFjaGlldmVtZW50cyIsImhhcyIsImFkZCIsInNlY3Rpb25Db21wbGV0ZWQiLCJldmVyeSIsImwiLCJBcnJheSIsImZyb20iLCJjYW5BY2Nlc3NMZXZlbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useGameProgress.ts\n"));

/***/ })

});