"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/challenges/multiple-choice/page",{

/***/ "(app-pages-browser)/./src/hooks/useGameProgress.ts":
/*!**************************************!*\
  !*** ./src/hooks/useGameProgress.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameProgress: () => (/* binding */ useGameProgress)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var _context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/context/AuthContext */ \"(app-pages-browser)/./src/context/AuthContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ useGameProgress auto */ \n\n\n\n// Helper functions\nconst getTodayDateString = ()=>{\n    const today = new Date();\n    const year = today.getFullYear();\n    const month = String(today.getMonth() + 1).padStart(2, '0');\n    const day = String(today.getDate()).padStart(2, '0');\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n};\nconst isSameDay = (dateStr1, dateStr2)=>{\n    if (!dateStr1 || !dateStr2) return false;\n    return dateStr1 === dateStr2;\n};\nconst isConsecutiveDay = (lastDateStr, todayStr)=>{\n    if (!lastDateStr || !todayStr) return false;\n    const lastDate = new Date(lastDateStr);\n    const today = new Date(todayStr);\n    const timeDiff = today.getTime() - lastDate.getTime();\n    const daysDiff = timeDiff / (1000 * 3600 * 24);\n    return Math.round(daysDiff) === 1;\n};\n// Generate 3 Levels (Easy, Difficult, Hard) each with 10 challenges\nconst generateSections = ()=>{\n    const sections = [];\n    const levelNames = [\n        'Easy',\n        'Difficult',\n        'Hard'\n    ];\n    for(let sectionId = 0; sectionId < 3; sectionId++){\n        const levels = [];\n        for(let levelId = 0; levelId < 10; levelId++){\n            levels.push({\n                id: levelId,\n                title: \"Challenge \".concat(levelId + 1),\n                isLocked: !(sectionId === 0 && levelId === 0),\n                isCompleted: false,\n                bestScore: 0,\n                attempts: 0,\n                lastPlayed: null\n            });\n        }\n        sections.push({\n            id: sectionId,\n            title: \"Level \".concat(sectionId + 1, \": \").concat(levelNames[sectionId] || '').trim(),\n            description: \"Complete all challenges in \".concat(levelNames[sectionId] || \"Level \".concat(sectionId + 1)),\n            isLocked: sectionId !== 0,\n            isCompleted: false,\n            levels\n        });\n    }\n    return sections;\n};\n// Generate daily quests\nconst generateDailyQuests = ()=>{\n    const today = getTodayDateString();\n    const expiresAt = today; // Expires at end of today\n    return [\n        {\n            id: 'daily-xp',\n            title: 'Daily XP',\n            description: 'Earn 50 XP today',\n            reward: 10,\n            progress: 0,\n            target: 50,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'streak-bonus',\n            title: 'Get 3 Correct in a Row',\n            description: 'Answer three questions correctly in a row',\n            reward: 10,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'complete-games',\n            title: 'Complete 3 Games',\n            description: 'Complete any 3 games today (any score)',\n            reward: 15,\n            progress: 0,\n            target: 3,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'perfect-score',\n            title: 'Perfect Score',\n            description: 'Complete a level with a perfect score',\n            reward: 20,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        }\n    ];\n};\n// Default initial data\nconst getInitialData = (user)=>{\n    return {\n        profile: {\n            displayName: (user === null || user === void 0 ? void 0 : user.displayName) || null,\n            email: (user === null || user === void 0 ? void 0 : user.email) || null,\n            photoURL: (user === null || user === void 0 ? void 0 : user.photoURL) || null,\n            joinDate: new Date().toISOString(),\n            lastActiveDate: new Date().toISOString(),\n            gradeLevel: null,\n            preferences: {\n                emailNotifications: false,\n                dailyReminder: true\n            }\n        },\n        score: 0,\n        streak: 0,\n        lastStreakDate: '',\n        streakState: 'none',\n        totalChallengesCompleted: 0,\n        progress: {\n            'make-sentence': {\n                currentLevel: 0,\n                currentSection: 0,\n                sections: generateSections(),\n                xp: 0,\n                quests: generateDailyQuests(),\n                completedLevels: []\n            },\n            'multiple-choice': {\n                currentLevel: 0,\n                currentSection: 0,\n                sections: generateSections(),\n                xp: 0,\n                quests: generateDailyQuests(),\n                completedLevels: []\n            }\n        },\n        achievements: [],\n        gameAchievements: {},\n        recentChallenges: [],\n        updatedAt: new Date().toISOString()\n    };\n};\nconst useGameProgress = ()=>{\n    const { user } = (0,_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Real-time listener\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useGameProgress.useEffect\": ()=>{\n            if (!(user === null || user === void 0 ? void 0 : user.uid)) {\n                setLoading(false);\n                return;\n            }\n            console.log('[GameProgress] Setting up real-time listener for user:', user.uid);\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            const unsubscribe = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)(userDocRef, {\n                \"useGameProgress.useEffect.unsubscribe\": async (doc)=>{\n                    try {\n                        if (doc.exists()) {\n                            const docData = doc.data();\n                            console.log('[GameProgress] Real-time data received:', docData);\n                            // Migration: ensure 3 Levels with 10 challenges each for both games\n                            const needsMigration = {\n                                \"useGameProgress.useEffect.unsubscribe.needsMigration\": (progress)=>{\n                                    if (!progress || !progress.sections) return true;\n                                    if (progress.sections.length !== 3) return true;\n                                    for (const s of progress.sections){\n                                        if (!s.levels || s.levels.length !== 10) return true;\n                                    }\n                                    return false;\n                                }\n                            }[\"useGameProgress.useEffect.unsubscribe.needsMigration\"];\n                            const updatedProgress = {\n                                ...docData.progress\n                            };\n                            let didMigrate = false;\n                            for (const gameType of [\n                                'make-sentence',\n                                'multiple-choice'\n                            ]){\n                                var _docData_progress;\n                                const gp = (_docData_progress = docData.progress) === null || _docData_progress === void 0 ? void 0 : _docData_progress[gameType];\n                                if (!gp || needsMigration(gp)) {\n                                    didMigrate = true;\n                                    const sections = generateSections();\n                                    // Unlock first level and first challenge\n                                    if (sections.length > 0) {\n                                        sections[0].isLocked = false;\n                                        if (sections[0].levels.length > 0) sections[0].levels[0].isLocked = false;\n                                    }\n                                    updatedProgress[gameType] = {\n                                        sections,\n                                        xp: (gp === null || gp === void 0 ? void 0 : gp.xp) || 0,\n                                        quests: (gp === null || gp === void 0 ? void 0 : gp.quests) || [],\n                                        currentSection: 0,\n                                        currentLevel: 0,\n                                        completedLevels: []\n                                    };\n                                }\n                            }\n                            if (didMigrate) {\n                                console.log('[GameProgress] Migrating progress to 3 levels Ã— 10 challenges structure');\n                                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                                    progress: updatedProgress,\n                                    updatedAt: new Date().toISOString()\n                                });\n                                setData({\n                                    ...docData,\n                                    progress: updatedProgress\n                                });\n                            } else {\n                                setData(docData);\n                            }\n                        } else {\n                            // Create initial data if document doesn't exist\n                            console.log('[GameProgress] No document found, creating initial data');\n                            const initialData = getInitialData(user);\n                            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(userDocRef, initialData);\n                            setData(initialData);\n                        }\n                        setLoading(false);\n                        setError(null);\n                    } catch (err) {\n                        console.error('[GameProgress] Error processing real-time data:', err);\n                        setError(err instanceof Error ? err.message : 'Unknown error');\n                        setLoading(false);\n                    }\n                }\n            }[\"useGameProgress.useEffect.unsubscribe\"], {\n                \"useGameProgress.useEffect.unsubscribe\": (err)=>{\n                    console.error('[GameProgress] Real-time listener error:', err);\n                    setError(err.message);\n                    setLoading(false);\n                }\n            }[\"useGameProgress.useEffect.unsubscribe\"]);\n            return ({\n                \"useGameProgress.useEffect\": ()=>{\n                    console.log('[GameProgress] Cleaning up real-time listener');\n                    unsubscribe();\n                }\n            })[\"useGameProgress.useEffect\"];\n        }\n    }[\"useGameProgress.useEffect\"], [\n        user === null || user === void 0 ? void 0 : user.uid\n    ]);\n    // Action functions\n    const updateData = async (updates)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid)) return;\n        try {\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                ...updates,\n                updatedAt: new Date().toISOString()\n            });\n        } catch (err) {\n            console.error('[GameProgress] Error updating data:', err);\n            throw err;\n        }\n    };\n    const addPoints = async (points, gameType)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress) return;\n        const newXP = Math.max(0, gameProgress.xp + points);\n        await updateData({\n            score: data.score + points,\n            progress: {\n                ...data.progress,\n                [gameType]: {\n                    ...gameProgress,\n                    xp: newXP\n                }\n            }\n        });\n    };\n    const increaseStreak = async ()=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const today = getTodayDateString();\n        let newStreak = data.streak;\n        // Don't increase if already played today\n        if (isSameDay(data.lastStreakDate, today)) {\n            return;\n        }\n        // Increase streak if consecutive day or starting new\n        if (isConsecutiveDay(data.lastStreakDate, today) || !data.lastStreakDate) {\n            newStreak += 1;\n        } else {\n            newStreak = 1; // Reset to 1 if missed days\n        }\n        await updateData({\n            streak: newStreak,\n            lastStreakDate: today,\n            streakState: 'active'\n        });\n    };\n    const completeLevel = async (gameType, sectionId, levelId, score)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress) return;\n        const updatedSections = [\n            ...gameProgress.sections\n        ];\n        const section = updatedSections[sectionId];\n        if (!section || !section.levels[levelId]) return;\n        const level = section.levels[levelId];\n        level.attempts = (level.attempts || 0) + 1;\n        level.lastPlayed = new Date().toISOString();\n        if (score !== undefined && (level.bestScore === undefined || score > level.bestScore)) {\n            level.bestScore = score;\n        }\n        // Treat invocation of completeLevel as \"finished the level\"\n        // Always mark as completed and advance unlocking\n        let nextSectionId = sectionId;\n        let nextLevelId = levelId;\n        level.isCompleted = true;\n        // Unlock next level or section\n        if (levelId < section.levels.length - 1) {\n            nextLevelId = levelId + 1;\n            section.levels[nextLevelId].isLocked = false;\n        } else {\n            // Completed section, unlock next section\n            section.isCompleted = true;\n            if (sectionId < updatedSections.length - 1) {\n                nextSectionId = sectionId + 1;\n                nextLevelId = 0;\n                updatedSections[nextSectionId].isLocked = false;\n                updatedSections[nextSectionId].levels[0].isLocked = false;\n            }\n        }\n        // Prepare achievements updates (simple MVP)\n        const updatedGameAchievements = {\n            ...data.gameAchievements || {}\n        };\n        const gameTypeAchievements = new Set(updatedGameAchievements[gameType] || []);\n        const updatedAchievements = new Set(data.achievements || []);\n        // First Steps: completing a first game\n        if (!gameTypeAchievements.has('first-steps')) {\n            gameTypeAchievements.add('first-steps');\n            updatedAchievements.add('first-steps');\n        }\n        // Perfect Score: score 100\n        if (score !== undefined && score >= 100 && !gameTypeAchievements.has('perfect-score')) {\n            gameTypeAchievements.add('perfect-score');\n            updatedAchievements.add('perfect-score');\n        }\n        // Section Champion: entire section completed\n        const sectionCompleted = section.levels.every((l)=>l.isCompleted);\n        if (sectionCompleted && !gameTypeAchievements.has('section-champion')) {\n            gameTypeAchievements.add('section-champion');\n            updatedAchievements.add('section-champion');\n        }\n        updatedGameAchievements[gameType] = Array.from(gameTypeAchievements);\n        await updateData({\n            progress: {\n                ...data.progress,\n                [gameType]: {\n                    ...gameProgress,\n                    sections: updatedSections,\n                    currentSection: nextSectionId,\n                    currentLevel: nextLevelId\n                }\n            },\n            achievements: Array.from(updatedAchievements),\n            gameAchievements: updatedGameAchievements\n        });\n    };\n    const canAccessLevel = (gameType, sectionId, levelId)=>{\n        if (!data || !data.progress[gameType]) return false;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress.sections || sectionId < 0 || sectionId >= gameProgress.sections.length) {\n            return false;\n        }\n        const section = gameProgress.sections[sectionId];\n        if (!section || section.isLocked) return false;\n        if (!section.levels || levelId < 0 || levelId >= section.levels.length) {\n            return false;\n        }\n        const level = section.levels[levelId];\n        return level && !level.isLocked;\n    };\n    return {\n        data,\n        loading,\n        error,\n        // Actions\n        updateData,\n        addPoints,\n        increaseStreak,\n        completeLevel,\n        canAccessLevel,\n        // Convenience getters\n        profile: (data === null || data === void 0 ? void 0 : data.profile) || null,\n        score: (data === null || data === void 0 ? void 0 : data.score) || 0,\n        streak: (data === null || data === void 0 ? void 0 : data.streak) || 0,\n        streakState: (data === null || data === void 0 ? void 0 : data.streakState) || 'none',\n        progress: (data === null || data === void 0 ? void 0 : data.progress) || {},\n        achievements: (data === null || data === void 0 ? void 0 : data.achievements) || [],\n        gameAchievements: (data === null || data === void 0 ? void 0 : data.gameAchievements) || {},\n        recentChallenges: (data === null || data === void 0 ? void 0 : data.recentChallenges) || []\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VHYW1lUHJvZ3Jlc3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FFQUU0QztBQUNtRDtBQUMzRDtBQUNZO0FBOEZoRCxtQkFBbUI7QUFDbkIsTUFBTVEscUJBQXFCO0lBQ3pCLE1BQU1DLFFBQVEsSUFBSUM7SUFDbEIsTUFBTUMsT0FBT0YsTUFBTUcsV0FBVztJQUM5QixNQUFNQyxRQUFRQyxPQUFPTCxNQUFNTSxRQUFRLEtBQUssR0FBR0MsUUFBUSxDQUFDLEdBQUc7SUFDdkQsTUFBTUMsTUFBTUgsT0FBT0wsTUFBTVMsT0FBTyxJQUFJRixRQUFRLENBQUMsR0FBRztJQUNoRCxPQUFPLEdBQVdILE9BQVJGLE1BQUssS0FBWU0sT0FBVEosT0FBTSxLQUFPLE9BQUpJO0FBQzdCO0FBRUEsTUFBTUUsWUFBWSxDQUFDQyxVQUFrQkM7SUFDbkMsSUFBSSxDQUFDRCxZQUFZLENBQUNDLFVBQVUsT0FBTztJQUNuQyxPQUFPRCxhQUFhQztBQUN0QjtBQUVBLE1BQU1DLG1CQUFtQixDQUFDQyxhQUFxQkM7SUFDN0MsSUFBSSxDQUFDRCxlQUFlLENBQUNDLFVBQVUsT0FBTztJQUV0QyxNQUFNQyxXQUFXLElBQUlmLEtBQUthO0lBQzFCLE1BQU1kLFFBQVEsSUFBSUMsS0FBS2M7SUFFdkIsTUFBTUUsV0FBV2pCLE1BQU1rQixPQUFPLEtBQUtGLFNBQVNFLE9BQU87SUFDbkQsTUFBTUMsV0FBV0YsV0FBWSxRQUFPLE9BQU8sRUFBQztJQUU1QyxPQUFPRyxLQUFLQyxLQUFLLENBQUNGLGNBQWM7QUFDbEM7QUFFQSxvRUFBb0U7QUFDcEUsTUFBTUcsbUJBQW1CO0lBQ3ZCLE1BQU1DLFdBQXNCLEVBQUU7SUFDOUIsTUFBTUMsYUFBYTtRQUFDO1FBQVE7UUFBYTtLQUFPO0lBRWhELElBQUssSUFBSUMsWUFBWSxHQUFHQSxZQUFZLEdBQUdBLFlBQWE7UUFDbEQsTUFBTUMsU0FBa0IsRUFBRTtRQUUxQixJQUFLLElBQUlD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T0FBTztRQUV6QyxJQUFJLENBQUMyRSxRQUFRaEYsTUFBTSxJQUFJQyxVQUFVLEtBQUtBLFdBQVcrRSxRQUFRaEYsTUFBTSxDQUFDMkQsTUFBTSxFQUFFO1lBQ3RFLE9BQU87UUFDVDtRQUVBLE1BQU1zQixRQUFRRCxRQUFRaEYsTUFBTSxDQUFDQyxRQUFRO1FBQ3JDLE9BQU9nRixTQUFTLENBQUNBLE1BQU01RSxRQUFRO0lBQ2pDO0lBRUEsT0FBTztRQUNMd0M7UUFDQUU7UUFDQUU7UUFDQSxVQUFVO1FBQ1ZvQjtRQUNBRTtRQUNBSztRQUNBRTtRQUNBa0I7UUFDQSxzQkFBc0I7UUFDdEI3RSxTQUFTMEIsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNMUIsT0FBTyxLQUFJO1FBQzFCVyxPQUFPZSxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1mLEtBQUssS0FBSTtRQUN0QkMsUUFBUWMsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNZCxNQUFNLEtBQUk7UUFDeEJFLGFBQWFZLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTVosV0FBVyxLQUFJO1FBQ2xDbEIsVUFBVThCLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTTlCLFFBQVEsS0FBSSxDQUFDO1FBQzdCeUIsY0FBY0ssQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNTCxZQUFZLEtBQUksRUFBRTtRQUN0Q0Msa0JBQWtCSSxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1KLGdCQUFnQixLQUFJLENBQUM7UUFDN0NDLGtCQUFrQkcsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNSCxnQkFBZ0IsS0FBSSxFQUFFO0lBQ2hEO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL2VydmlucmFwaGFlbGFsYmEvRGVza3RvcC9YNDIwL3NyYy9ob29rcy91c2VHYW1lUHJvZ3Jlc3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgb25TbmFwc2hvdCwgZG9jLCB1cGRhdGVEb2MsIHNldERvYywgaW5jcmVtZW50LCBhcnJheVVuaW9uIH0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcbmltcG9ydCB7IGRiIH0gZnJvbSAnQC9saWIvZmlyZWJhc2UnO1xuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gJ0AvY29udGV4dC9BdXRoQ29udGV4dCc7XG5cbi8vIFR5cGVzIGZyb20gZXhpc3RpbmcgZ2FtZVN0b3JlXG5leHBvcnQgdHlwZSBTZWN0aW9uID0ge1xuICBpZDogbnVtYmVyO1xuICB0aXRsZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBpc0xvY2tlZDogYm9vbGVhbjtcbiAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47XG4gIGxldmVsczogTGV2ZWxbXTtcbn07XG5cbmV4cG9ydCB0eXBlIExldmVsID0ge1xuICBpZDogbnVtYmVyO1xuICB0aXRsZTogc3RyaW5nO1xuICBpc0xvY2tlZDogYm9vbGVhbjtcbiAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47XG4gIGJlc3RTY29yZTogbnVtYmVyO1xuICBhdHRlbXB0czogbnVtYmVyO1xuICBsYXN0UGxheWVkOiBzdHJpbmcgfCBudWxsO1xufTtcblxuZXhwb3J0IHR5cGUgRGFpbHlRdWVzdCA9IHtcbiAgaWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgcmV3YXJkOiBudW1iZXI7XG4gIHByb2dyZXNzOiBudW1iZXI7XG4gIHRhcmdldDogbnVtYmVyO1xuICBpc0NvbXBsZXRlZDogYm9vbGVhbjtcbiAgZXhwaXJlc0F0OiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBVc2VyUHJvZmlsZSA9IHtcbiAgZGlzcGxheU5hbWU6IHN0cmluZyB8IG51bGw7XG4gIGVtYWlsOiBzdHJpbmcgfCBudWxsO1xuICBwaG90b1VSTDogc3RyaW5nIHwgbnVsbDtcbiAgam9pbkRhdGU6IHN0cmluZztcbiAgbGFzdEFjdGl2ZURhdGU6IHN0cmluZztcbiAgZ3JhZGVMZXZlbD86ICdHMV8yJyB8ICdHM180JyB8ICdHNV82JyB8IG51bGw7XG4gIHByZWZlcmVuY2VzOiB7XG4gICAgZW1haWxOb3RpZmljYXRpb25zOiBib29sZWFuO1xuICAgIGRhaWx5UmVtaW5kZXI6IGJvb2xlYW47XG4gIH07XG59O1xuXG5leHBvcnQgdHlwZSBDaGFsbGVuZ2VSZXN1bHQgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIGNoYWxsZW5nZVR5cGU6ICdtYWtlLXNlbnRlbmNlJyB8ICdtdWx0aXBsZS1jaG9pY2UnIHwgJ2NvbnZlcnNhdGlvbic7XG4gIHNjb3JlOiBudW1iZXI7XG4gIG1heFNjb3JlOiBudW1iZXI7XG4gIGNvbXBsZXRlZEF0OiBzdHJpbmc7XG4gIGR1cmF0aW9uOiBudW1iZXI7XG4gIGlzQ29ycmVjdDogYm9vbGVhbjtcbiAgZ2FtZVR5cGU6IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIEdhbWVQcm9ncmVzc0RhdGEgPSB7XG4gIC8vIFVzZXIgcHJvZmlsZVxuICBwcm9maWxlOiBVc2VyUHJvZmlsZSB8IG51bGw7XG4gIFxuICAvLyBHYW1lIHN0YXRpc3RpY3NcbiAgc2NvcmU6IG51bWJlcjtcbiAgc3RyZWFrOiBudW1iZXI7XG4gIGxhc3RTdHJlYWtEYXRlOiBzdHJpbmc7XG4gIHN0cmVha1N0YXRlOiBcIm5vbmVcIiB8IFwiaW5hY3RpdmVcIiB8IFwiYWN0aXZlXCI7XG4gIHRvdGFsQ2hhbGxlbmdlc0NvbXBsZXRlZDogbnVtYmVyO1xuICBcbiAgLy8gR2FtZSBwcm9ncmVzc1xuICBwcm9ncmVzczoge1xuICAgIFtnYW1lVHlwZTogc3RyaW5nXToge1xuICAgICAgY3VycmVudExldmVsOiBudW1iZXI7XG4gICAgICBjdXJyZW50U2VjdGlvbjogbnVtYmVyO1xuICAgICAgc2VjdGlvbnM6IFNlY3Rpb25bXTtcbiAgICAgIHhwOiBudW1iZXI7XG4gICAgICBxdWVzdHM6IERhaWx5UXVlc3RbXTtcbiAgICAgIGNvbXBsZXRlZExldmVsczogc3RyaW5nW107XG4gICAgICBsYXN0UGxheWVkQXQ/OiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXG4gIC8vIEFjaGlldmVtZW50c1xuICBhY2hpZXZlbWVudHM6IHN0cmluZ1tdO1xuICBnYW1lQWNoaWV2ZW1lbnRzOiB7XG4gICAgW2dhbWVUeXBlOiBzdHJpbmddOiBzdHJpbmdbXTtcbiAgfTtcbiAgXG4gIC8vIENoYWxsZW5nZSBoaXN0b3J5XG4gIHJlY2VudENoYWxsZW5nZXM6IENoYWxsZW5nZVJlc3VsdFtdO1xuICBcbiAgLy8gTWV0YWRhdGFcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5jb25zdCBnZXRUb2RheURhdGVTdHJpbmcgPSAoKTogc3RyaW5nID0+IHtcbiAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCB5ZWFyID0gdG9kYXkuZ2V0RnVsbFllYXIoKTtcbiAgY29uc3QgbW9udGggPSBTdHJpbmcodG9kYXkuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsICcwJyk7XG4gIGNvbnN0IGRheSA9IFN0cmluZyh0b2RheS5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1gO1xufTtcblxuY29uc3QgaXNTYW1lRGF5ID0gKGRhdGVTdHIxOiBzdHJpbmcsIGRhdGVTdHIyOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgaWYgKCFkYXRlU3RyMSB8fCAhZGF0ZVN0cjIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGRhdGVTdHIxID09PSBkYXRlU3RyMjtcbn07XG5cbmNvbnN0IGlzQ29uc2VjdXRpdmVEYXkgPSAobGFzdERhdGVTdHI6IHN0cmluZywgdG9kYXlTdHI6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICBpZiAoIWxhc3REYXRlU3RyIHx8ICF0b2RheVN0cikgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3QgbGFzdERhdGUgPSBuZXcgRGF0ZShsYXN0RGF0ZVN0cik7XG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUodG9kYXlTdHIpO1xuICBcbiAgY29uc3QgdGltZURpZmYgPSB0b2RheS5nZXRUaW1lKCkgLSBsYXN0RGF0ZS5nZXRUaW1lKCk7XG4gIGNvbnN0IGRheXNEaWZmID0gdGltZURpZmYgLyAoMTAwMCAqIDM2MDAgKiAyNCk7XG4gIFxuICByZXR1cm4gTWF0aC5yb3VuZChkYXlzRGlmZikgPT09IDE7XG59O1xuXG4vLyBHZW5lcmF0ZSAzIExldmVscyAoRWFzeSwgRGlmZmljdWx0LCBIYXJkKSBlYWNoIHdpdGggMTAgY2hhbGxlbmdlc1xuY29uc3QgZ2VuZXJhdGVTZWN0aW9ucyA9ICgpOiBTZWN0aW9uW10gPT4ge1xuICBjb25zdCBzZWN0aW9uczogU2VjdGlvbltdID0gW107XG4gIGNvbnN0IGxldmVsTmFtZXMgPSBbJ0Vhc3knLCAnRGlmZmljdWx0JywgJ0hhcmQnXTtcbiAgXG4gIGZvciAobGV0IHNlY3Rpb25JZCA9IDA7IHNlY3Rpb25JZCA8IDM7IHNlY3Rpb25JZCsrKSB7XG4gICAgY29uc3QgbGV2ZWxzOiBMZXZlbFtdID0gW107XG4gICAgXG4gICAgZm9yIChsZXQgbGV2ZWxJZCA9IDA7IGxldmVsSWQgPCAxMDsgbGV2ZWxJZCsrKSB7XG4gICAgICBsZXZlbHMucHVzaCh7XG4gICAgICAgIGlkOiBsZXZlbElkLFxuICAgICAgICB0aXRsZTogYENoYWxsZW5nZSAke2xldmVsSWQgKyAxfWAsXG4gICAgICAgIGlzTG9ja2VkOiAhKHNlY3Rpb25JZCA9PT0gMCAmJiBsZXZlbElkID09PSAwKSwgLy8gT25seSBmaXJzdCBjaGFsbGVuZ2UgdW5sb2NrZWRcbiAgICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBiZXN0U2NvcmU6IDAsXG4gICAgICAgIGF0dGVtcHRzOiAwLFxuICAgICAgICBsYXN0UGxheWVkOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICBpZDogc2VjdGlvbklkLFxuICAgICAgdGl0bGU6IGBMZXZlbCAke3NlY3Rpb25JZCArIDF9OiAke2xldmVsTmFtZXNbc2VjdGlvbklkXSB8fCAnJ31gLnRyaW0oKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBgQ29tcGxldGUgYWxsIGNoYWxsZW5nZXMgaW4gJHtsZXZlbE5hbWVzW3NlY3Rpb25JZF0gfHwgYExldmVsICR7c2VjdGlvbklkICsgMX1gfWAsXG4gICAgICBpc0xvY2tlZDogc2VjdGlvbklkICE9PSAwLCAvLyBPbmx5IGZpcnN0IGxldmVsIHVubG9ja2VkXG4gICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICBsZXZlbHNcbiAgICB9KTtcbiAgfVxuICBcbiAgcmV0dXJuIHNlY3Rpb25zO1xufTtcblxuLy8gR2VuZXJhdGUgZGFpbHkgcXVlc3RzXG5jb25zdCBnZW5lcmF0ZURhaWx5UXVlc3RzID0gKCk6IERhaWx5UXVlc3RbXSA9PiB7XG4gIGNvbnN0IHRvZGF5ID0gZ2V0VG9kYXlEYXRlU3RyaW5nKCk7XG4gIGNvbnN0IGV4cGlyZXNBdCA9IHRvZGF5OyAvLyBFeHBpcmVzIGF0IGVuZCBvZiB0b2RheVxuICBcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBpZDogJ2RhaWx5LXhwJyxcbiAgICAgIHRpdGxlOiAnRGFpbHkgWFAnLFxuICAgICAgZGVzY3JpcHRpb246ICdFYXJuIDUwIFhQIHRvZGF5JyxcbiAgICAgIHJld2FyZDogMTAsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHRhcmdldDogNTAsXG4gICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICBleHBpcmVzQXRcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAnc3RyZWFrLWJvbnVzJyxcbiAgICAgIHRpdGxlOiAnR2V0IDMgQ29ycmVjdCBpbiBhIFJvdycsXG4gICAgICBkZXNjcmlwdGlvbjogJ0Fuc3dlciB0aHJlZSBxdWVzdGlvbnMgY29ycmVjdGx5IGluIGEgcm93JyxcbiAgICAgIHJld2FyZDogMTAsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHRhcmdldDogMSxcbiAgICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcbiAgICAgIGV4cGlyZXNBdFxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6ICdjb21wbGV0ZS1nYW1lcycsXG4gICAgICB0aXRsZTogJ0NvbXBsZXRlIDMgR2FtZXMnLFxuICAgICAgZGVzY3JpcHRpb246ICdDb21wbGV0ZSBhbnkgMyBnYW1lcyB0b2RheSAoYW55IHNjb3JlKScsXG4gICAgICByZXdhcmQ6IDE1LFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB0YXJnZXQ6IDMsXG4gICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICBleHBpcmVzQXRcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAncGVyZmVjdC1zY29yZScsXG4gICAgICB0aXRsZTogJ1BlcmZlY3QgU2NvcmUnLFxuICAgICAgZGVzY3JpcHRpb246ICdDb21wbGV0ZSBhIGxldmVsIHdpdGggYSBwZXJmZWN0IHNjb3JlJyxcbiAgICAgIHJld2FyZDogMjAsXG4gICAgICBwcm9ncmVzczogMCxcbiAgICAgIHRhcmdldDogMSxcbiAgICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcbiAgICAgIGV4cGlyZXNBdFxuICAgIH1cbiAgXTtcbn07XG5cbi8vIERlZmF1bHQgaW5pdGlhbCBkYXRhXG5jb25zdCBnZXRJbml0aWFsRGF0YSA9ICh1c2VyOiBhbnkpOiBHYW1lUHJvZ3Jlc3NEYXRhID0+IHtcbiAgcmV0dXJuIHtcbiAgICBwcm9maWxlOiB7XG4gICAgICBkaXNwbGF5TmFtZTogdXNlcj8uZGlzcGxheU5hbWUgfHwgbnVsbCxcbiAgICAgIGVtYWlsOiB1c2VyPy5lbWFpbCB8fCBudWxsLFxuICAgICAgcGhvdG9VUkw6IHVzZXI/LnBob3RvVVJMIHx8IG51bGwsXG4gICAgICBqb2luRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgbGFzdEFjdGl2ZURhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGdyYWRlTGV2ZWw6IG51bGwsXG4gICAgICBwcmVmZXJlbmNlczoge1xuICAgICAgICBlbWFpbE5vdGlmaWNhdGlvbnM6IGZhbHNlLFxuICAgICAgICBkYWlseVJlbWluZGVyOiB0cnVlLFxuICAgICAgfVxuICAgIH0sXG4gICAgc2NvcmU6IDAsXG4gICAgc3RyZWFrOiAwLFxuICAgIGxhc3RTdHJlYWtEYXRlOiAnJyxcbiAgICBzdHJlYWtTdGF0ZTogJ25vbmUnLFxuICAgIHRvdGFsQ2hhbGxlbmdlc0NvbXBsZXRlZDogMCxcbiAgICBwcm9ncmVzczoge1xuICAgICAgJ21ha2Utc2VudGVuY2UnOiB7XG4gICAgICAgIGN1cnJlbnRMZXZlbDogMCxcbiAgICAgICAgY3VycmVudFNlY3Rpb246IDAsXG4gICAgICAgIHNlY3Rpb25zOiBnZW5lcmF0ZVNlY3Rpb25zKCksXG4gICAgICAgIHhwOiAwLFxuICAgICAgICBxdWVzdHM6IGdlbmVyYXRlRGFpbHlRdWVzdHMoKSxcbiAgICAgICAgY29tcGxldGVkTGV2ZWxzOiBbXSxcbiAgICAgIH0sXG4gICAgICAnbXVsdGlwbGUtY2hvaWNlJzoge1xuICAgICAgICBjdXJyZW50TGV2ZWw6IDAsXG4gICAgICAgIGN1cnJlbnRTZWN0aW9uOiAwLFxuICAgICAgICBzZWN0aW9uczogZ2VuZXJhdGVTZWN0aW9ucygpLFxuICAgICAgICB4cDogMCxcbiAgICAgICAgcXVlc3RzOiBnZW5lcmF0ZURhaWx5UXVlc3RzKCksXG4gICAgICAgIGNvbXBsZXRlZExldmVsczogW10sXG4gICAgICB9XG4gICAgfSxcbiAgICBhY2hpZXZlbWVudHM6IFtdLFxuICAgIGdhbWVBY2hpZXZlbWVudHM6IHt9LFxuICAgIHJlY2VudENoYWxsZW5nZXM6IFtdLFxuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdXNlR2FtZVByb2dyZXNzID0gKCkgPT4ge1xuICBjb25zdCB7IHVzZXIgfSA9IHVzZUF1dGgoKTtcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gdXNlU3RhdGU8R2FtZVByb2dyZXNzRGF0YSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgXG4gIC8vIFJlYWwtdGltZSBsaXN0ZW5lclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdXNlcj8udWlkKSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1tHYW1lUHJvZ3Jlc3NdIFNldHRpbmcgdXAgcmVhbC10aW1lIGxpc3RlbmVyIGZvciB1c2VyOicsIHVzZXIudWlkKTtcbiAgICBcbiAgICBjb25zdCB1c2VyRG9jUmVmID0gZG9jKGRiLCAnZ2FtZVByb2dyZXNzJywgdXNlci51aWQpO1xuICAgIFxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb25TbmFwc2hvdChcbiAgICAgIHVzZXJEb2NSZWYsXG4gICAgICBhc3luYyAoZG9jKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGRvYy5leGlzdHMoKSkge1xuICAgICAgICAgICAgY29uc3QgZG9jRGF0YSA9IGRvYy5kYXRhKCkgYXMgR2FtZVByb2dyZXNzRGF0YTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbR2FtZVByb2dyZXNzXSBSZWFsLXRpbWUgZGF0YSByZWNlaXZlZDonLCBkb2NEYXRhKTtcblxuICAgICAgICAgICAgLy8gTWlncmF0aW9uOiBlbnN1cmUgMyBMZXZlbHMgd2l0aCAxMCBjaGFsbGVuZ2VzIGVhY2ggZm9yIGJvdGggZ2FtZXNcbiAgICAgICAgICAgIGNvbnN0IG5lZWRzTWlncmF0aW9uID0gKHByb2dyZXNzOiBhbnkpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFwcm9ncmVzcyB8fCAhcHJvZ3Jlc3Muc2VjdGlvbnMpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3Muc2VjdGlvbnMubGVuZ3RoICE9PSAzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHByb2dyZXNzLnNlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzLmxldmVscyB8fCBzLmxldmVscy5sZW5ndGggIT09IDEwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkUHJvZ3Jlc3M6IGFueSA9IHsgLi4uZG9jRGF0YS5wcm9ncmVzcyB9O1xuICAgICAgICAgICAgbGV0IGRpZE1pZ3JhdGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBnYW1lVHlwZSBvZiBbJ21ha2Utc2VudGVuY2UnLCAnbXVsdGlwbGUtY2hvaWNlJ10pIHtcbiAgICAgICAgICAgICAgY29uc3QgZ3AgPSBkb2NEYXRhLnByb2dyZXNzPy5bZ2FtZVR5cGVdO1xuICAgICAgICAgICAgICBpZiAoIWdwIHx8IG5lZWRzTWlncmF0aW9uKGdwKSkge1xuICAgICAgICAgICAgICAgIGRpZE1pZ3JhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25zID0gZ2VuZXJhdGVTZWN0aW9ucygpO1xuICAgICAgICAgICAgICAgIC8vIFVubG9jayBmaXJzdCBsZXZlbCBhbmQgZmlyc3QgY2hhbGxlbmdlXG4gICAgICAgICAgICAgICAgaWYgKHNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHNlY3Rpb25zWzBdLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBpZiAoc2VjdGlvbnNbMF0ubGV2ZWxzLmxlbmd0aCA+IDApIHNlY3Rpb25zWzBdLmxldmVsc1swXS5pc0xvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVkUHJvZ3Jlc3NbZ2FtZVR5cGVdID0ge1xuICAgICAgICAgICAgICAgICAgc2VjdGlvbnMsXG4gICAgICAgICAgICAgICAgICB4cDogZ3A/LnhwIHx8IDAsXG4gICAgICAgICAgICAgICAgICBxdWVzdHM6IGdwPy5xdWVzdHMgfHwgW10sXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U2VjdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZXZlbDogMCxcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZExldmVsczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkaWRNaWdyYXRlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbR2FtZVByb2dyZXNzXSBNaWdyYXRpbmcgcHJvZ3Jlc3MgdG8gMyBsZXZlbHMgw5cgMTAgY2hhbGxlbmdlcyBzdHJ1Y3R1cmUnKTtcbiAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlRG9jKHVzZXJEb2NSZWYsIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzczogdXBkYXRlZFByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZXREYXRhKHsgLi4uZG9jRGF0YSwgcHJvZ3Jlc3M6IHVwZGF0ZWRQcm9ncmVzcyB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldERhdGEoZG9jRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBpbml0aWFsIGRhdGEgaWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tHYW1lUHJvZ3Jlc3NdIE5vIGRvY3VtZW50IGZvdW5kLCBjcmVhdGluZyBpbml0aWFsIGRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxEYXRhID0gZ2V0SW5pdGlhbERhdGEodXNlcik7XG4gICAgICAgICAgICBhd2FpdCBzZXREb2ModXNlckRvY1JlZiwgaW5pdGlhbERhdGEpO1xuICAgICAgICAgICAgc2V0RGF0YShpbml0aWFsRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbR2FtZVByb2dyZXNzXSBFcnJvciBwcm9jZXNzaW5nIHJlYWwtdGltZSBkYXRhOicsIGVycik7XG4gICAgICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoZXJyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tHYW1lUHJvZ3Jlc3NdIFJlYWwtdGltZSBsaXN0ZW5lciBlcnJvcjonLCBlcnIpO1xuICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdbR2FtZVByb2dyZXNzXSBDbGVhbmluZyB1cCByZWFsLXRpbWUgbGlzdGVuZXInKTtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW3VzZXI/LnVpZF0pO1xuICBcbiAgLy8gQWN0aW9uIGZ1bmN0aW9uc1xuICBjb25zdCB1cGRhdGVEYXRhID0gYXN5bmMgKHVwZGF0ZXM6IFBhcnRpYWw8R2FtZVByb2dyZXNzRGF0YT4pID0+IHtcbiAgICBpZiAoIXVzZXI/LnVpZCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyRG9jUmVmID0gZG9jKGRiLCAnZ2FtZVByb2dyZXNzJywgdXNlci51aWQpO1xuICAgICAgYXdhaXQgdXBkYXRlRG9jKHVzZXJEb2NSZWYsIHtcbiAgICAgICAgLi4udXBkYXRlcyxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignW0dhbWVQcm9ncmVzc10gRXJyb3IgdXBkYXRpbmcgZGF0YTonLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGFkZFBvaW50cyA9IGFzeW5jIChwb2ludHM6IG51bWJlciwgZ2FtZVR5cGU6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcj8udWlkIHx8ICFkYXRhKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZ2FtZVByb2dyZXNzID0gZGF0YS5wcm9ncmVzc1tnYW1lVHlwZV07XG4gICAgaWYgKCFnYW1lUHJvZ3Jlc3MpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBuZXdYUCA9IE1hdGgubWF4KDAsIGdhbWVQcm9ncmVzcy54cCArIHBvaW50cyk7XG4gICAgXG4gICAgYXdhaXQgdXBkYXRlRGF0YSh7XG4gICAgICBzY29yZTogZGF0YS5zY29yZSArIHBvaW50cyxcbiAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgIC4uLmRhdGEucHJvZ3Jlc3MsXG4gICAgICAgIFtnYW1lVHlwZV06IHtcbiAgICAgICAgICAuLi5nYW1lUHJvZ3Jlc3MsXG4gICAgICAgICAgeHA6IG5ld1hQXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgXG4gIGNvbnN0IGluY3JlYXNlU3RyZWFrID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcj8udWlkIHx8ICFkYXRhKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdG9kYXkgPSBnZXRUb2RheURhdGVTdHJpbmcoKTtcbiAgICBsZXQgbmV3U3RyZWFrID0gZGF0YS5zdHJlYWs7XG4gICAgXG4gICAgLy8gRG9uJ3QgaW5jcmVhc2UgaWYgYWxyZWFkeSBwbGF5ZWQgdG9kYXlcbiAgICBpZiAoaXNTYW1lRGF5KGRhdGEubGFzdFN0cmVha0RhdGUsIHRvZGF5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBJbmNyZWFzZSBzdHJlYWsgaWYgY29uc2VjdXRpdmUgZGF5IG9yIHN0YXJ0aW5nIG5ld1xuICAgIGlmIChpc0NvbnNlY3V0aXZlRGF5KGRhdGEubGFzdFN0cmVha0RhdGUsIHRvZGF5KSB8fCAhZGF0YS5sYXN0U3RyZWFrRGF0ZSkge1xuICAgICAgbmV3U3RyZWFrICs9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0cmVhayA9IDE7IC8vIFJlc2V0IHRvIDEgaWYgbWlzc2VkIGRheXNcbiAgICB9XG4gICAgXG4gICAgYXdhaXQgdXBkYXRlRGF0YSh7XG4gICAgICBzdHJlYWs6IG5ld1N0cmVhayxcbiAgICAgIGxhc3RTdHJlYWtEYXRlOiB0b2RheSxcbiAgICAgIHN0cmVha1N0YXRlOiAnYWN0aXZlJ1xuICAgIH0pO1xuICB9O1xuICBcbiAgY29uc3QgY29tcGxldGVMZXZlbCA9IGFzeW5jIChnYW1lVHlwZTogc3RyaW5nLCBzZWN0aW9uSWQ6IG51bWJlciwgbGV2ZWxJZDogbnVtYmVyLCBzY29yZT86IG51bWJlcikgPT4ge1xuICAgIGlmICghdXNlcj8udWlkIHx8ICFkYXRhKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZ2FtZVByb2dyZXNzID0gZGF0YS5wcm9ncmVzc1tnYW1lVHlwZV07XG4gICAgaWYgKCFnYW1lUHJvZ3Jlc3MpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB1cGRhdGVkU2VjdGlvbnMgPSBbLi4uZ2FtZVByb2dyZXNzLnNlY3Rpb25zXTtcbiAgICBjb25zdCBzZWN0aW9uID0gdXBkYXRlZFNlY3Rpb25zW3NlY3Rpb25JZF07XG4gICAgaWYgKCFzZWN0aW9uIHx8ICFzZWN0aW9uLmxldmVsc1tsZXZlbElkXSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGxldmVsID0gc2VjdGlvbi5sZXZlbHNbbGV2ZWxJZF07XG4gICAgbGV2ZWwuYXR0ZW1wdHMgPSAobGV2ZWwuYXR0ZW1wdHMgfHwgMCkgKyAxO1xuICAgIGxldmVsLmxhc3RQbGF5ZWQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgXG4gICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQgJiYgKGxldmVsLmJlc3RTY29yZSA9PT0gdW5kZWZpbmVkIHx8IHNjb3JlID4gbGV2ZWwuYmVzdFNjb3JlKSkge1xuICAgICAgbGV2ZWwuYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyZWF0IGludm9jYXRpb24gb2YgY29tcGxldGVMZXZlbCBhcyBcImZpbmlzaGVkIHRoZSBsZXZlbFwiXG4gICAgLy8gQWx3YXlzIG1hcmsgYXMgY29tcGxldGVkIGFuZCBhZHZhbmNlIHVubG9ja2luZ1xuICAgIGxldCBuZXh0U2VjdGlvbklkID0gc2VjdGlvbklkO1xuICAgIGxldCBuZXh0TGV2ZWxJZCA9IGxldmVsSWQ7XG4gICAgXG4gICAgbGV2ZWwuaXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgIFxuICAgIC8vIFVubG9jayBuZXh0IGxldmVsIG9yIHNlY3Rpb25cbiAgICBpZiAobGV2ZWxJZCA8IHNlY3Rpb24ubGV2ZWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgIG5leHRMZXZlbElkID0gbGV2ZWxJZCArIDE7XG4gICAgICBzZWN0aW9uLmxldmVsc1tuZXh0TGV2ZWxJZF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29tcGxldGVkIHNlY3Rpb24sIHVubG9jayBuZXh0IHNlY3Rpb25cbiAgICAgIHNlY3Rpb24uaXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgaWYgKHNlY3Rpb25JZCA8IHVwZGF0ZWRTZWN0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIG5leHRTZWN0aW9uSWQgPSBzZWN0aW9uSWQgKyAxO1xuICAgICAgICBuZXh0TGV2ZWxJZCA9IDA7XG4gICAgICAgIHVwZGF0ZWRTZWN0aW9uc1tuZXh0U2VjdGlvbklkXS5pc0xvY2tlZCA9IGZhbHNlO1xuICAgICAgICB1cGRhdGVkU2VjdGlvbnNbbmV4dFNlY3Rpb25JZF0ubGV2ZWxzWzBdLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSBhY2hpZXZlbWVudHMgdXBkYXRlcyAoc2ltcGxlIE1WUClcbiAgICBjb25zdCB1cGRhdGVkR2FtZUFjaGlldmVtZW50cyA9IHsgLi4uKGRhdGEuZ2FtZUFjaGlldmVtZW50cyB8fCB7fSkgfSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT47XG4gICAgY29uc3QgZ2FtZVR5cGVBY2hpZXZlbWVudHMgPSBuZXcgU2V0PHN0cmluZz4odXBkYXRlZEdhbWVBY2hpZXZlbWVudHNbZ2FtZVR5cGVdIHx8IFtdKTtcbiAgICBjb25zdCB1cGRhdGVkQWNoaWV2ZW1lbnRzID0gbmV3IFNldDxzdHJpbmc+KGRhdGEuYWNoaWV2ZW1lbnRzIHx8IFtdKTtcblxuICAgIC8vIEZpcnN0IFN0ZXBzOiBjb21wbGV0aW5nIGEgZmlyc3QgZ2FtZVxuICAgIGlmICghZ2FtZVR5cGVBY2hpZXZlbWVudHMuaGFzKCdmaXJzdC1zdGVwcycpKSB7XG4gICAgICBnYW1lVHlwZUFjaGlldmVtZW50cy5hZGQoJ2ZpcnN0LXN0ZXBzJyk7XG4gICAgICB1cGRhdGVkQWNoaWV2ZW1lbnRzLmFkZCgnZmlyc3Qtc3RlcHMnKTtcbiAgICB9XG4gICAgLy8gUGVyZmVjdCBTY29yZTogc2NvcmUgMTAwXG4gICAgaWYgKHNjb3JlICE9PSB1bmRlZmluZWQgJiYgc2NvcmUgPj0gMTAwICYmICFnYW1lVHlwZUFjaGlldmVtZW50cy5oYXMoJ3BlcmZlY3Qtc2NvcmUnKSkge1xuICAgICAgZ2FtZVR5cGVBY2hpZXZlbWVudHMuYWRkKCdwZXJmZWN0LXNjb3JlJyk7XG4gICAgICB1cGRhdGVkQWNoaWV2ZW1lbnRzLmFkZCgncGVyZmVjdC1zY29yZScpO1xuICAgIH1cbiAgICAvLyBTZWN0aW9uIENoYW1waW9uOiBlbnRpcmUgc2VjdGlvbiBjb21wbGV0ZWRcbiAgICBjb25zdCBzZWN0aW9uQ29tcGxldGVkID0gc2VjdGlvbi5sZXZlbHMuZXZlcnkobCA9PiBsLmlzQ29tcGxldGVkKTtcbiAgICBpZiAoc2VjdGlvbkNvbXBsZXRlZCAmJiAhZ2FtZVR5cGVBY2hpZXZlbWVudHMuaGFzKCdzZWN0aW9uLWNoYW1waW9uJykpIHtcbiAgICAgIGdhbWVUeXBlQWNoaWV2ZW1lbnRzLmFkZCgnc2VjdGlvbi1jaGFtcGlvbicpO1xuICAgICAgdXBkYXRlZEFjaGlldmVtZW50cy5hZGQoJ3NlY3Rpb24tY2hhbXBpb24nKTtcbiAgICB9XG4gICAgdXBkYXRlZEdhbWVBY2hpZXZlbWVudHNbZ2FtZVR5cGVdID0gQXJyYXkuZnJvbShnYW1lVHlwZUFjaGlldmVtZW50cyk7XG4gICAgXG4gICAgYXdhaXQgdXBkYXRlRGF0YSh7XG4gICAgICBwcm9ncmVzczoge1xuICAgICAgICAuLi5kYXRhLnByb2dyZXNzLFxuICAgICAgICBbZ2FtZVR5cGVdOiB7XG4gICAgICAgICAgLi4uZ2FtZVByb2dyZXNzLFxuICAgICAgICAgIHNlY3Rpb25zOiB1cGRhdGVkU2VjdGlvbnMsXG4gICAgICAgICAgY3VycmVudFNlY3Rpb246IG5leHRTZWN0aW9uSWQsXG4gICAgICAgICAgY3VycmVudExldmVsOiBuZXh0TGV2ZWxJZFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWNoaWV2ZW1lbnRzOiBBcnJheS5mcm9tKHVwZGF0ZWRBY2hpZXZlbWVudHMpLFxuICAgICAgZ2FtZUFjaGlldmVtZW50czogdXBkYXRlZEdhbWVBY2hpZXZlbWVudHNcbiAgICB9KTtcbiAgfTtcbiAgXG4gIGNvbnN0IGNhbkFjY2Vzc0xldmVsID0gKGdhbWVUeXBlOiBzdHJpbmcsIHNlY3Rpb25JZDogbnVtYmVyLCBsZXZlbElkOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEucHJvZ3Jlc3NbZ2FtZVR5cGVdKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgY29uc3QgZ2FtZVByb2dyZXNzID0gZGF0YS5wcm9ncmVzc1tnYW1lVHlwZV07XG4gICAgaWYgKCFnYW1lUHJvZ3Jlc3Muc2VjdGlvbnMgfHwgc2VjdGlvbklkIDwgMCB8fCBzZWN0aW9uSWQgPj0gZ2FtZVByb2dyZXNzLnNlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBzZWN0aW9uID0gZ2FtZVByb2dyZXNzLnNlY3Rpb25zW3NlY3Rpb25JZF07XG4gICAgaWYgKCFzZWN0aW9uIHx8IHNlY3Rpb24uaXNMb2NrZWQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICBpZiAoIXNlY3Rpb24ubGV2ZWxzIHx8IGxldmVsSWQgPCAwIHx8IGxldmVsSWQgPj0gc2VjdGlvbi5sZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGxldmVsID0gc2VjdGlvbi5sZXZlbHNbbGV2ZWxJZF07XG4gICAgcmV0dXJuIGxldmVsICYmICFsZXZlbC5pc0xvY2tlZDtcbiAgfTtcbiAgXG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIC8vIEFjdGlvbnNcbiAgICB1cGRhdGVEYXRhLFxuICAgIGFkZFBvaW50cyxcbiAgICBpbmNyZWFzZVN0cmVhayxcbiAgICBjb21wbGV0ZUxldmVsLFxuICAgIGNhbkFjY2Vzc0xldmVsLFxuICAgIC8vIENvbnZlbmllbmNlIGdldHRlcnNcbiAgICBwcm9maWxlOiBkYXRhPy5wcm9maWxlIHx8IG51bGwsXG4gICAgc2NvcmU6IGRhdGE/LnNjb3JlIHx8IDAsXG4gICAgc3RyZWFrOiBkYXRhPy5zdHJlYWsgfHwgMCxcbiAgICBzdHJlYWtTdGF0ZTogZGF0YT8uc3RyZWFrU3RhdGUgfHwgJ25vbmUnLFxuICAgIHByb2dyZXNzOiBkYXRhPy5wcm9ncmVzcyB8fCB7fSxcbiAgICBhY2hpZXZlbWVudHM6IGRhdGE/LmFjaGlldmVtZW50cyB8fCBbXSxcbiAgICBnYW1lQWNoaWV2ZW1lbnRzOiBkYXRhPy5nYW1lQWNoaWV2ZW1lbnRzIHx8IHt9LFxuICAgIHJlY2VudENoYWxsZW5nZXM6IGRhdGE/LnJlY2VudENoYWxsZW5nZXMgfHwgW11cbiAgfTtcbn07ICJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIm9uU25hcHNob3QiLCJkb2MiLCJ1cGRhdGVEb2MiLCJzZXREb2MiLCJkYiIsInVzZUF1dGgiLCJnZXRUb2RheURhdGVTdHJpbmciLCJ0b2RheSIsIkRhdGUiLCJ5ZWFyIiwiZ2V0RnVsbFllYXIiLCJtb250aCIsIlN0cmluZyIsImdldE1vbnRoIiwicGFkU3RhcnQiLCJkYXkiLCJnZXREYXRlIiwiaXNTYW1lRGF5IiwiZGF0ZVN0cjEiLCJkYXRlU3RyMiIsImlzQ29uc2VjdXRpdmVEYXkiLCJsYXN0RGF0ZVN0ciIsInRvZGF5U3RyIiwibGFzdERhdGUiLCJ0aW1lRGlmZiIsImdldFRpbWUiLCJkYXlzRGlmZiIsIk1hdGgiLCJyb3VuZCIsImdlbmVyYXRlU2VjdGlvbnMiLCJzZWN0aW9ucyIsImxldmVsTmFtZXMiLCJzZWN0aW9uSWQiLCJsZXZlbHMiLCJsZXZlbElkIiwicHVzaCIsImlkIiwidGl0bGUiLCJpc0xvY2tlZCIsImlzQ29tcGxldGVkIiwiYmVzdFNjb3JlIiwiYXR0ZW1wdHMiLCJsYXN0UGxheWVkIiwidHJpbSIsImRlc2NyaXB0aW9uIiwiZ2VuZXJhdGVEYWlseVF1ZXN0cyIsImV4cGlyZXNBdCIsInJld2FyZCIsInByb2dyZXNzIiwidGFyZ2V0IiwiZ2V0SW5pdGlhbERhdGEiLCJ1c2VyIiwicHJvZmlsZSIsImRpc3BsYXlOYW1lIiwiZW1haWwiLCJwaG90b1VSTCIsImpvaW5EYXRlIiwidG9JU09TdHJpbmciLCJsYXN0QWN0aXZlRGF0ZSIsImdyYWRlTGV2ZWwiLCJwcmVmZXJlbmNlcyIsImVtYWlsTm90aWZpY2F0aW9ucyIsImRhaWx5UmVtaW5kZXIiLCJzY29yZSIsInN0cmVhayIsImxhc3RTdHJlYWtEYXRlIiwic3RyZWFrU3RhdGUiLCJ0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQiLCJjdXJyZW50TGV2ZWwiLCJjdXJyZW50U2VjdGlvbiIsInhwIiwicXVlc3RzIiwiY29tcGxldGVkTGV2ZWxzIiwiYWNoaWV2ZW1lbnRzIiwiZ2FtZUFjaGlldmVtZW50cyIsInJlY2VudENoYWxsZW5nZXMiLCJ1cGRhdGVkQXQiLCJ1c2VHYW1lUHJvZ3Jlc3MiLCJkYXRhIiwic2V0RGF0YSIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInVpZCIsImNvbnNvbGUiLCJsb2ciLCJ1c2VyRG9jUmVmIiwidW5zdWJzY3JpYmUiLCJleGlzdHMiLCJkb2NEYXRhIiwibmVlZHNNaWdyYXRpb24iLCJsZW5ndGgiLCJzIiwidXBkYXRlZFByb2dyZXNzIiwiZGlkTWlncmF0ZSIsImdhbWVUeXBlIiwiZ3AiLCJpbml0aWFsRGF0YSIsImVyciIsIkVycm9yIiwibWVzc2FnZSIsInVwZGF0ZURhdGEiLCJ1cGRhdGVzIiwiYWRkUG9pbnRzIiwicG9pbnRzIiwiZ2FtZVByb2dyZXNzIiwibmV3WFAiLCJtYXgiLCJpbmNyZWFzZVN0cmVhayIsIm5ld1N0cmVhayIsImNvbXBsZXRlTGV2ZWwiLCJ1cGRhdGVkU2VjdGlvbnMiLCJzZWN0aW9uIiwibGV2ZWwiLCJ1bmRlZmluZWQiLCJuZXh0U2VjdGlvbklkIiwibmV4dExldmVsSWQiLCJ1cGRhdGVkR2FtZUFjaGlldmVtZW50cyIsImdhbWVUeXBlQWNoaWV2ZW1lbnRzIiwiU2V0IiwidXBkYXRlZEFjaGlldmVtZW50cyIsImhhcyIsImFkZCIsInNlY3Rpb25Db21wbGV0ZWQiLCJldmVyeSIsImwiLCJBcnJheSIsImZyb20iLCJjYW5BY2Nlc3NMZXZlbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useGameProgress.ts\n"));

/***/ })

});