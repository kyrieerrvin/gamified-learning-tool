"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/challenges/multiple-choice/page",{

/***/ "(app-pages-browser)/./src/hooks/useGameProgress.ts":
/*!**************************************!*\
  !*** ./src/hooks/useGameProgress.ts ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGameProgress: () => (/* binding */ useGameProgress)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var _context_AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/context/AuthContext */ \"(app-pages-browser)/./src/context/AuthContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ useGameProgress auto */ \n\n\n\n// Helper functions\nconst getTodayDateString = ()=>{\n    const today = new Date();\n    const year = today.getFullYear();\n    const month = String(today.getMonth() + 1).padStart(2, '0');\n    const day = String(today.getDate()).padStart(2, '0');\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n};\nconst isSameDay = (dateStr1, dateStr2)=>{\n    if (!dateStr1 || !dateStr2) return false;\n    return dateStr1 === dateStr2;\n};\nconst isConsecutiveDay = (lastDateStr, todayStr)=>{\n    if (!lastDateStr || !todayStr) return false;\n    const lastDate = new Date(lastDateStr);\n    const today = new Date(todayStr);\n    const timeDiff = today.getTime() - lastDate.getTime();\n    const daysDiff = timeDiff / (1000 * 3600 * 24);\n    return Math.round(daysDiff) === 1;\n};\n// Generate 3 Levels (Easy, Difficult, Hard) each with 10 challenges\nconst generateSections = ()=>{\n    const sections = [];\n    const levelNames = [\n        'Easy',\n        'Difficult',\n        'Hard'\n    ];\n    for(let sectionId = 0; sectionId < 3; sectionId++){\n        const levels = [];\n        for(let levelId = 0; levelId < 10; levelId++){\n            levels.push({\n                id: levelId,\n                title: \"Challenge \".concat(levelId + 1),\n                isLocked: !(sectionId === 0 && levelId === 0),\n                isCompleted: false,\n                bestScore: 0,\n                attempts: 0,\n                lastPlayed: null\n            });\n        }\n        sections.push({\n            id: sectionId,\n            title: \"Level \".concat(sectionId + 1, \": \").concat(levelNames[sectionId] || '').trim(),\n            description: \"Complete all challenges in \".concat(levelNames[sectionId] || \"Level \".concat(sectionId + 1)),\n            isLocked: sectionId !== 0,\n            isCompleted: false,\n            levels\n        });\n    }\n    return sections;\n};\n// Generate daily quests\nconst generateDailyQuests = ()=>{\n    const today = getTodayDateString();\n    const expiresAt = today; // Expires at end of today\n    return [\n        {\n            id: 'daily-xp',\n            title: 'Daily XP',\n            description: 'Earn 50 XP today',\n            reward: 10,\n            progress: 0,\n            target: 50,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'streak-bonus',\n            title: 'Get 3 Correct in a Row',\n            description: 'Answer three questions correctly in a row',\n            reward: 10,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'complete-games',\n            title: 'Complete 3 Games',\n            description: 'Complete any 3 games today (any score)',\n            reward: 15,\n            progress: 0,\n            target: 3,\n            isCompleted: false,\n            expiresAt\n        },\n        {\n            id: 'perfect-score',\n            title: 'Perfect Score',\n            description: 'Complete a level with a perfect score',\n            reward: 20,\n            progress: 0,\n            target: 1,\n            isCompleted: false,\n            expiresAt\n        }\n    ];\n};\n// Default initial data\nconst getInitialData = (user)=>{\n    return {\n        profile: {\n            displayName: (user === null || user === void 0 ? void 0 : user.displayName) || null,\n            email: (user === null || user === void 0 ? void 0 : user.email) || null,\n            photoURL: (user === null || user === void 0 ? void 0 : user.photoURL) || null,\n            joinDate: new Date().toISOString(),\n            lastActiveDate: new Date().toISOString(),\n            gradeLevel: null,\n            preferences: {\n                emailNotifications: false,\n                dailyReminder: true\n            }\n        },\n        score: 0,\n        streak: 0,\n        lastStreakDate: '',\n        streakState: 'none',\n        totalChallengesCompleted: 0,\n        progress: {\n            'make-sentence': {\n                currentLevel: 0,\n                currentSection: 0,\n                sections: generateSections(),\n                xp: 0,\n                quests: generateDailyQuests(),\n                completedLevels: []\n            },\n            'multiple-choice': {\n                currentLevel: 0,\n                currentSection: 0,\n                sections: generateSections(),\n                xp: 0,\n                quests: generateDailyQuests(),\n                completedLevels: []\n            }\n        },\n        achievements: [],\n        gameAchievements: {},\n        recentChallenges: [],\n        updatedAt: new Date().toISOString()\n    };\n};\nconst useGameProgress = ()=>{\n    const { user } = (0,_context_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [data, setData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    // Real-time listener\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useGameProgress.useEffect\": ()=>{\n            if (!(user === null || user === void 0 ? void 0 : user.uid)) {\n                setLoading(false);\n                return;\n            }\n            console.log('[GameProgress] Setting up real-time listener for user:', user.uid);\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            const unsubscribe = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.onSnapshot)(userDocRef, {\n                \"useGameProgress.useEffect.unsubscribe\": async (doc)=>{\n                    try {\n                        if (doc.exists()) {\n                            const docData = doc.data();\n                            console.log('[GameProgress] Real-time data received:', docData);\n                            // Migration: ensure 3 Levels with 10 challenges each for both games\n                            const needsMigration = {\n                                \"useGameProgress.useEffect.unsubscribe.needsMigration\": (progress)=>{\n                                    if (!progress || !progress.sections) return true;\n                                    if (progress.sections.length !== 3) return true;\n                                    for (const s of progress.sections){\n                                        if (!s.levels || s.levels.length !== 10) return true;\n                                    }\n                                    return false;\n                                }\n                            }[\"useGameProgress.useEffect.unsubscribe.needsMigration\"];\n                            const updatedProgress = {\n                                ...docData.progress\n                            };\n                            let didMigrate = false;\n                            for (const gameType of [\n                                'make-sentence',\n                                'multiple-choice'\n                            ]){\n                                var _docData_progress;\n                                const gp = (_docData_progress = docData.progress) === null || _docData_progress === void 0 ? void 0 : _docData_progress[gameType];\n                                if (!gp || needsMigration(gp)) {\n                                    didMigrate = true;\n                                    const sections = generateSections();\n                                    // Unlock first level and first challenge\n                                    if (sections.length > 0) {\n                                        sections[0].isLocked = false;\n                                        if (sections[0].levels.length > 0) sections[0].levels[0].isLocked = false;\n                                    }\n                                    updatedProgress[gameType] = {\n                                        sections,\n                                        xp: (gp === null || gp === void 0 ? void 0 : gp.xp) || 0,\n                                        quests: (gp === null || gp === void 0 ? void 0 : gp.quests) || [],\n                                        currentSection: 0,\n                                        currentLevel: 0,\n                                        completedLevels: []\n                                    };\n                                }\n                            }\n                            if (didMigrate) {\n                                console.log('[GameProgress] Migrating progress to 3 levels × 10 challenges structure');\n                                await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                                    progress: updatedProgress,\n                                    updatedAt: new Date().toISOString()\n                                });\n                                setData({\n                                    ...docData,\n                                    progress: updatedProgress\n                                });\n                            } else {\n                                setData(docData);\n                            }\n                        } else {\n                            // Create initial data if document doesn't exist\n                            console.log('[GameProgress] No document found, creating initial data');\n                            const initialData = getInitialData(user);\n                            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.setDoc)(userDocRef, initialData);\n                            setData(initialData);\n                        }\n                        setLoading(false);\n                        setError(null);\n                    } catch (err) {\n                        console.error('[GameProgress] Error processing real-time data:', err);\n                        setError(err instanceof Error ? err.message : 'Unknown error');\n                        setLoading(false);\n                    }\n                }\n            }[\"useGameProgress.useEffect.unsubscribe\"], {\n                \"useGameProgress.useEffect.unsubscribe\": (err)=>{\n                    console.error('[GameProgress] Real-time listener error:', err);\n                    setError(err.message);\n                    setLoading(false);\n                }\n            }[\"useGameProgress.useEffect.unsubscribe\"]);\n            return ({\n                \"useGameProgress.useEffect\": ()=>{\n                    console.log('[GameProgress] Cleaning up real-time listener');\n                    unsubscribe();\n                }\n            })[\"useGameProgress.useEffect\"];\n        }\n    }[\"useGameProgress.useEffect\"], [\n        user === null || user === void 0 ? void 0 : user.uid\n    ]);\n    // Action functions\n    const updateData = async (updates)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid)) return;\n        try {\n            const userDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.doc)(_lib_firebase__WEBPACK_IMPORTED_MODULE_2__.db, 'gameProgress', user.uid);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.updateDoc)(userDocRef, {\n                ...updates,\n                updatedAt: new Date().toISOString()\n            });\n        } catch (err) {\n            console.error('[GameProgress] Error updating data:', err);\n            throw err;\n        }\n    };\n    const addPoints = async (points, gameType)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress) return;\n        const newXP = Math.max(0, gameProgress.xp + points);\n        await updateData({\n            score: data.score + points,\n            progress: {\n                ...data.progress,\n                [gameType]: {\n                    ...gameProgress,\n                    xp: newXP\n                }\n            }\n        });\n    };\n    const increaseStreak = async ()=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const today = getTodayDateString();\n        let newStreak = data.streak;\n        // Don't increase if already played today\n        if (isSameDay(data.lastStreakDate, today)) {\n            return;\n        }\n        // Increase streak if consecutive day or starting new\n        if (isConsecutiveDay(data.lastStreakDate, today) || !data.lastStreakDate) {\n            newStreak += 1;\n        } else {\n            newStreak = 1; // Reset to 1 if missed days\n        }\n        await updateData({\n            streak: newStreak,\n            lastStreakDate: today,\n            streakState: 'active'\n        });\n    };\n    const completeLevel = async (gameType, sectionId, levelId, score)=>{\n        if (!(user === null || user === void 0 ? void 0 : user.uid) || !data) return;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress) return;\n        const updatedSections = [\n            ...gameProgress.sections\n        ];\n        const section = updatedSections[sectionId];\n        if (!section || !section.levels[levelId]) return;\n        const level = section.levels[levelId];\n        level.attempts = (level.attempts || 0) + 1;\n        level.lastPlayed = new Date().toISOString();\n        if (score !== undefined && (level.bestScore === undefined || score > level.bestScore)) {\n            level.bestScore = score;\n        }\n        // Mark as completed if score >= 80%\n        const isLevelCompleted = score !== undefined && score >= 80;\n        let nextSectionId = sectionId;\n        let nextLevelId = levelId;\n        if (isLevelCompleted) {\n            level.isCompleted = true;\n            // Unlock next level\n            if (levelId < section.levels.length - 1) {\n                nextLevelId = levelId + 1;\n                section.levels[nextLevelId].isLocked = false;\n            } else {\n                // Completed section, unlock next section\n                section.isCompleted = true;\n                if (sectionId < updatedSections.length - 1) {\n                    nextSectionId = sectionId + 1;\n                    nextLevelId = 0;\n                    updatedSections[nextSectionId].isLocked = false;\n                    updatedSections[nextSectionId].levels[0].isLocked = false;\n                }\n            }\n        }\n        // Prepare achievements updates (simple MVP)\n        const updatedGameAchievements = {\n            ...data.gameAchievements || {}\n        };\n        const gameTypeAchievements = new Set(updatedGameAchievements[gameType] || []);\n        const updatedAchievements = new Set(data.achievements || []);\n        // First Steps: completing a first game\n        if (!gameTypeAchievements.has('first-steps')) {\n            gameTypeAchievements.add('first-steps');\n            updatedAchievements.add('first-steps');\n        }\n        // Perfect Score: score 100\n        if (score !== undefined && score >= 100 && !gameTypeAchievements.has('perfect-score')) {\n            gameTypeAchievements.add('perfect-score');\n            updatedAchievements.add('perfect-score');\n        }\n        // Section Champion: entire section completed\n        const sectionCompleted = section.levels.every((l)=>l.isCompleted);\n        if (sectionCompleted && !gameTypeAchievements.has('section-champion')) {\n            gameTypeAchievements.add('section-champion');\n            updatedAchievements.add('section-champion');\n        }\n        updatedGameAchievements[gameType] = Array.from(gameTypeAchievements);\n        await updateData({\n            progress: {\n                ...data.progress,\n                [gameType]: {\n                    ...gameProgress,\n                    sections: updatedSections,\n                    currentSection: nextSectionId,\n                    currentLevel: nextLevelId\n                }\n            },\n            achievements: Array.from(updatedAchievements),\n            gameAchievements: updatedGameAchievements\n        });\n    };\n    const canAccessLevel = (gameType, sectionId, levelId)=>{\n        if (!data || !data.progress[gameType]) return false;\n        const gameProgress = data.progress[gameType];\n        if (!gameProgress.sections || sectionId < 0 || sectionId >= gameProgress.sections.length) {\n            return false;\n        }\n        const section = gameProgress.sections[sectionId];\n        if (!section || section.isLocked) return false;\n        if (!section.levels || levelId < 0 || levelId >= section.levels.length) {\n            return false;\n        }\n        const level = section.levels[levelId];\n        return level && !level.isLocked;\n    };\n    return {\n        data,\n        loading,\n        error,\n        // Actions\n        updateData,\n        addPoints,\n        increaseStreak,\n        completeLevel,\n        canAccessLevel,\n        // Convenience getters\n        profile: (data === null || data === void 0 ? void 0 : data.profile) || null,\n        score: (data === null || data === void 0 ? void 0 : data.score) || 0,\n        streak: (data === null || data === void 0 ? void 0 : data.streak) || 0,\n        streakState: (data === null || data === void 0 ? void 0 : data.streakState) || 'none',\n        progress: (data === null || data === void 0 ? void 0 : data.progress) || {},\n        achievements: (data === null || data === void 0 ? void 0 : data.achievements) || [],\n        gameAchievements: (data === null || data === void 0 ? void 0 : data.gameAchievements) || {},\n        recentChallenges: (data === null || data === void 0 ? void 0 : data.recentChallenges) || []\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VHYW1lUHJvZ3Jlc3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FFQUU0QztBQUNtRDtBQUMzRDtBQUNZO0FBOEZoRCxtQkFBbUI7QUFDbkIsTUFBTVEscUJBQXFCO0lBQ3pCLE1BQU1DLFFBQVEsSUFBSUM7SUFDbEIsTUFBTUMsT0FBT0YsTUFBTUcsV0FBVztJQUM5QixNQUFNQyxRQUFRQyxPQUFPTCxNQUFNTSxRQUFRLEtBQUssR0FBR0MsUUFBUSxDQUFDLEdBQUc7SUFDdkQsTUFBTUMsTUFBTUgsT0FBT0wsTUFBTVMsT0FBTyxJQUFJRixRQUFRLENBQUMsR0FBRztJQUNoRCxPQUFPLEdBQVdILE9BQVJGLE1BQUssS0FBWU0sT0FBVEosT0FBTSxLQUFPLE9BQUpJO0FBQzdCO0FBRUEsTUFBTUUsWUFBWSxDQUFDQyxVQUFrQkM7SUFDbkMsSUFBSSxDQUFDRCxZQUFZLENBQUNDLFVBQVUsT0FBTztJQUNuQyxPQUFPRCxhQUFhQztBQUN0QjtBQUVBLE1BQU1DLG1CQUFtQixDQUFDQyxhQUFxQkM7SUFDN0MsSUFBSSxDQUFDRCxlQUFlLENBQUNDLFVBQVUsT0FBTztJQUV0QyxNQUFNQyxXQUFXLElBQUlmLEtBQUthO0lBQzFCLE1BQU1kLFFBQVEsSUFBSUMsS0FBS2M7SUFFdkIsTUFBTUUsV0FBV2pCLE1BQU1rQixPQUFPLEtBQUtGLFNBQVNFLE9BQU87SUFDbkQsTUFBTUMsV0FBV0YsV0FBWSxRQUFPLE9BQU8sRUFBQztJQUU1QyxPQUFPRyxLQUFLQyxLQUFLLENBQUNGLGNBQWM7QUFDbEM7QUFFQSxvRUFBb0U7QUFDcEUsTUFBTUcsbUJBQW1CO0lBQ3ZCLE1BQU1DLFdBQXNCLEVBQUU7SUFDOUIsTUFBTUMsYUFBYTtRQUFDO1FBQVE7UUFBYTtLQUFPO0lBRWhELElBQUssSUFBSUMsWUFBWSxHQUFHQSxZQUFZLEdBQUdBLFlBQWE7UUFDbEQsTUFBTUMsU0FBa0IsRUFBRTtRQUUxQixJQUFLLElBQUlD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LFFBQVEsQ0FBQ0UsVUFBVTtRQUNoRCxJQUFJLENBQUNpRixXQUFXQSxRQUFRM0UsUUFBUSxFQUFFLE9BQU87UUFFekMsSUFBSSxDQUFDMkUsUUFBUWhGLE1BQU0sSUFBSUMsVUFBVSxLQUFLQSxXQUFXK0UsUUFBUWhGLE1BQU0sQ0FBQzJELE1BQU0sRUFBRTtZQUN0RSxPQUFPO1FBQ1Q7UUFFQSxNQUFNc0IsUUFBUUQsUUFBUWhGLE1BQU0sQ0FBQ0MsUUFBUTtRQUNyQyxPQUFPZ0YsU0FBUyxDQUFDQSxNQUFNNUUsUUFBUTtJQUNqQztJQUVBLE9BQU87UUFDTHdDO1FBQ0FFO1FBQ0FFO1FBQ0EsVUFBVTtRQUNWb0I7UUFDQUU7UUFDQUs7UUFDQUU7UUFDQW1CO1FBQ0Esc0JBQXNCO1FBQ3RCOUUsU0FBUzBCLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTTFCLE9BQU8sS0FBSTtRQUMxQlcsT0FBT2UsQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNZixLQUFLLEtBQUk7UUFDdEJDLFFBQVFjLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTWQsTUFBTSxLQUFJO1FBQ3hCRSxhQUFhWSxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU1aLFdBQVcsS0FBSTtRQUNsQ2xCLFVBQVU4QixDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU05QixRQUFRLEtBQUksQ0FBQztRQUM3QnlCLGNBQWNLLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTUwsWUFBWSxLQUFJLEVBQUU7UUFDdENDLGtCQUFrQkksQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNSixnQkFBZ0IsS0FBSSxDQUFDO1FBQzdDQyxrQkFBa0JHLENBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTUgsZ0JBQWdCLEtBQUksRUFBRTtJQUNoRDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lcnZpbnJhcGhhZWxhbGJhL0Rlc2t0b3AvWDQyMC9zcmMvaG9va3MvdXNlR2FtZVByb2dyZXNzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG9uU25hcHNob3QsIGRvYywgdXBkYXRlRG9jLCBzZXREb2MsIGluY3JlbWVudCwgYXJyYXlVbmlvbiB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyBkYiB9IGZyb20gJ0AvbGliL2ZpcmViYXNlJztcbmltcG9ydCB7IHVzZUF1dGggfSBmcm9tICdAL2NvbnRleHQvQXV0aENvbnRleHQnO1xuXG4vLyBUeXBlcyBmcm9tIGV4aXN0aW5nIGdhbWVTdG9yZVxuZXhwb3J0IHR5cGUgU2VjdGlvbiA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgdGl0bGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgaXNMb2NrZWQ6IGJvb2xlYW47XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBsZXZlbHM6IExldmVsW107XG59O1xuXG5leHBvcnQgdHlwZSBMZXZlbCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgdGl0bGU6IHN0cmluZztcbiAgaXNMb2NrZWQ6IGJvb2xlYW47XG4gIGlzQ29tcGxldGVkOiBib29sZWFuO1xuICBiZXN0U2NvcmU6IG51bWJlcjtcbiAgYXR0ZW1wdHM6IG51bWJlcjtcbiAgbGFzdFBsYXllZDogc3RyaW5nIHwgbnVsbDtcbn07XG5cbmV4cG9ydCB0eXBlIERhaWx5UXVlc3QgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHJld2FyZDogbnVtYmVyO1xuICBwcm9ncmVzczogbnVtYmVyO1xuICB0YXJnZXQ6IG51bWJlcjtcbiAgaXNDb21wbGV0ZWQ6IGJvb2xlYW47XG4gIGV4cGlyZXNBdDogc3RyaW5nO1xufTtcblxuZXhwb3J0IHR5cGUgVXNlclByb2ZpbGUgPSB7XG4gIGRpc3BsYXlOYW1lOiBzdHJpbmcgfCBudWxsO1xuICBlbWFpbDogc3RyaW5nIHwgbnVsbDtcbiAgcGhvdG9VUkw6IHN0cmluZyB8IG51bGw7XG4gIGpvaW5EYXRlOiBzdHJpbmc7XG4gIGxhc3RBY3RpdmVEYXRlOiBzdHJpbmc7XG4gIGdyYWRlTGV2ZWw/OiAnRzFfMicgfCAnRzNfNCcgfCAnRzVfNicgfCBudWxsO1xuICBwcmVmZXJlbmNlczoge1xuICAgIGVtYWlsTm90aWZpY2F0aW9uczogYm9vbGVhbjtcbiAgICBkYWlseVJlbWluZGVyOiBib29sZWFuO1xuICB9O1xufTtcblxuZXhwb3J0IHR5cGUgQ2hhbGxlbmdlUmVzdWx0ID0ge1xuICBpZDogc3RyaW5nO1xuICBjaGFsbGVuZ2VUeXBlOiAnbWFrZS1zZW50ZW5jZScgfCAnbXVsdGlwbGUtY2hvaWNlJyB8ICdjb252ZXJzYXRpb24nO1xuICBzY29yZTogbnVtYmVyO1xuICBtYXhTY29yZTogbnVtYmVyO1xuICBjb21wbGV0ZWRBdDogc3RyaW5nO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBpc0NvcnJlY3Q6IGJvb2xlYW47XG4gIGdhbWVUeXBlOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBHYW1lUHJvZ3Jlc3NEYXRhID0ge1xuICAvLyBVc2VyIHByb2ZpbGVcbiAgcHJvZmlsZTogVXNlclByb2ZpbGUgfCBudWxsO1xuICBcbiAgLy8gR2FtZSBzdGF0aXN0aWNzXG4gIHNjb3JlOiBudW1iZXI7XG4gIHN0cmVhazogbnVtYmVyO1xuICBsYXN0U3RyZWFrRGF0ZTogc3RyaW5nO1xuICBzdHJlYWtTdGF0ZTogXCJub25lXCIgfCBcImluYWN0aXZlXCIgfCBcImFjdGl2ZVwiO1xuICB0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQ6IG51bWJlcjtcbiAgXG4gIC8vIEdhbWUgcHJvZ3Jlc3NcbiAgcHJvZ3Jlc3M6IHtcbiAgICBbZ2FtZVR5cGU6IHN0cmluZ106IHtcbiAgICAgIGN1cnJlbnRMZXZlbDogbnVtYmVyO1xuICAgICAgY3VycmVudFNlY3Rpb246IG51bWJlcjtcbiAgICAgIHNlY3Rpb25zOiBTZWN0aW9uW107XG4gICAgICB4cDogbnVtYmVyO1xuICAgICAgcXVlc3RzOiBEYWlseVF1ZXN0W107XG4gICAgICBjb21wbGV0ZWRMZXZlbHM6IHN0cmluZ1tdO1xuICAgICAgbGFzdFBsYXllZEF0Pzogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIFxuICAvLyBBY2hpZXZlbWVudHNcbiAgYWNoaWV2ZW1lbnRzOiBzdHJpbmdbXTtcbiAgZ2FtZUFjaGlldmVtZW50czoge1xuICAgIFtnYW1lVHlwZTogc3RyaW5nXTogc3RyaW5nW107XG4gIH07XG4gIFxuICAvLyBDaGFsbGVuZ2UgaGlzdG9yeVxuICByZWNlbnRDaGFsbGVuZ2VzOiBDaGFsbGVuZ2VSZXN1bHRbXTtcbiAgXG4gIC8vIE1ldGFkYXRhXG4gIHVwZGF0ZWRBdDogc3RyaW5nO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuY29uc3QgZ2V0VG9kYXlEYXRlU3RyaW5nID0gKCk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgeWVhciA9IHRvZGF5LmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IG1vbnRoID0gU3RyaW5nKHRvZGF5LmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpO1xuICBjb25zdCBkYXkgPSBTdHJpbmcodG9kYXkuZ2V0RGF0ZSgpKS5wYWRTdGFydCgyLCAnMCcpO1xuICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbn07XG5cbmNvbnN0IGlzU2FtZURheSA9IChkYXRlU3RyMTogc3RyaW5nLCBkYXRlU3RyMjogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIGlmICghZGF0ZVN0cjEgfHwgIWRhdGVTdHIyKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBkYXRlU3RyMSA9PT0gZGF0ZVN0cjI7XG59O1xuXG5jb25zdCBpc0NvbnNlY3V0aXZlRGF5ID0gKGxhc3REYXRlU3RyOiBzdHJpbmcsIHRvZGF5U3RyOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgaWYgKCFsYXN0RGF0ZVN0ciB8fCAhdG9kYXlTdHIpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IGxhc3REYXRlID0gbmV3IERhdGUobGFzdERhdGVTdHIpO1xuICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKHRvZGF5U3RyKTtcbiAgXG4gIGNvbnN0IHRpbWVEaWZmID0gdG9kYXkuZ2V0VGltZSgpIC0gbGFzdERhdGUuZ2V0VGltZSgpO1xuICBjb25zdCBkYXlzRGlmZiA9IHRpbWVEaWZmIC8gKDEwMDAgKiAzNjAwICogMjQpO1xuICBcbiAgcmV0dXJuIE1hdGgucm91bmQoZGF5c0RpZmYpID09PSAxO1xufTtcblxuLy8gR2VuZXJhdGUgMyBMZXZlbHMgKEVhc3ksIERpZmZpY3VsdCwgSGFyZCkgZWFjaCB3aXRoIDEwIGNoYWxsZW5nZXNcbmNvbnN0IGdlbmVyYXRlU2VjdGlvbnMgPSAoKTogU2VjdGlvbltdID0+IHtcbiAgY29uc3Qgc2VjdGlvbnM6IFNlY3Rpb25bXSA9IFtdO1xuICBjb25zdCBsZXZlbE5hbWVzID0gWydFYXN5JywgJ0RpZmZpY3VsdCcsICdIYXJkJ107XG4gIFxuICBmb3IgKGxldCBzZWN0aW9uSWQgPSAwOyBzZWN0aW9uSWQgPCAzOyBzZWN0aW9uSWQrKykge1xuICAgIGNvbnN0IGxldmVsczogTGV2ZWxbXSA9IFtdO1xuICAgIFxuICAgIGZvciAobGV0IGxldmVsSWQgPSAwOyBsZXZlbElkIDwgMTA7IGxldmVsSWQrKykge1xuICAgICAgbGV2ZWxzLnB1c2goe1xuICAgICAgICBpZDogbGV2ZWxJZCxcbiAgICAgICAgdGl0bGU6IGBDaGFsbGVuZ2UgJHtsZXZlbElkICsgMX1gLFxuICAgICAgICBpc0xvY2tlZDogIShzZWN0aW9uSWQgPT09IDAgJiYgbGV2ZWxJZCA9PT0gMCksIC8vIE9ubHkgZmlyc3QgY2hhbGxlbmdlIHVubG9ja2VkXG4gICAgICAgIGlzQ29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgYmVzdFNjb3JlOiAwLFxuICAgICAgICBhdHRlbXB0czogMCxcbiAgICAgICAgbGFzdFBsYXllZDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgaWQ6IHNlY3Rpb25JZCxcbiAgICAgIHRpdGxlOiBgTGV2ZWwgJHtzZWN0aW9uSWQgKyAxfTogJHtsZXZlbE5hbWVzW3NlY3Rpb25JZF0gfHwgJyd9YC50cmltKCksXG4gICAgICBkZXNjcmlwdGlvbjogYENvbXBsZXRlIGFsbCBjaGFsbGVuZ2VzIGluICR7bGV2ZWxOYW1lc1tzZWN0aW9uSWRdIHx8IGBMZXZlbCAke3NlY3Rpb25JZCArIDF9YH1gLFxuICAgICAgaXNMb2NrZWQ6IHNlY3Rpb25JZCAhPT0gMCwgLy8gT25seSBmaXJzdCBsZXZlbCB1bmxvY2tlZFxuICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgbGV2ZWxzXG4gICAgfSk7XG4gIH1cbiAgXG4gIHJldHVybiBzZWN0aW9ucztcbn07XG5cbi8vIEdlbmVyYXRlIGRhaWx5IHF1ZXN0c1xuY29uc3QgZ2VuZXJhdGVEYWlseVF1ZXN0cyA9ICgpOiBEYWlseVF1ZXN0W10gPT4ge1xuICBjb25zdCB0b2RheSA9IGdldFRvZGF5RGF0ZVN0cmluZygpO1xuICBjb25zdCBleHBpcmVzQXQgPSB0b2RheTsgLy8gRXhwaXJlcyBhdCBlbmQgb2YgdG9kYXlcbiAgXG4gIHJldHVybiBbXG4gICAge1xuICAgICAgaWQ6ICdkYWlseS14cCcsXG4gICAgICB0aXRsZTogJ0RhaWx5IFhQJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnRWFybiA1MCBYUCB0b2RheScsXG4gICAgICByZXdhcmQ6IDEwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB0YXJnZXQ6IDUwLFxuICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgZXhwaXJlc0F0XG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ3N0cmVhay1ib251cycsXG4gICAgICB0aXRsZTogJ0dldCAzIENvcnJlY3QgaW4gYSBSb3cnLFxuICAgICAgZGVzY3JpcHRpb246ICdBbnN3ZXIgdGhyZWUgcXVlc3Rpb25zIGNvcnJlY3RseSBpbiBhIHJvdycsXG4gICAgICByZXdhcmQ6IDEwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB0YXJnZXQ6IDEsXG4gICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICBleHBpcmVzQXRcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAnY29tcGxldGUtZ2FtZXMnLFxuICAgICAgdGl0bGU6ICdDb21wbGV0ZSAzIEdhbWVzJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29tcGxldGUgYW55IDMgZ2FtZXMgdG9kYXkgKGFueSBzY29yZSknLFxuICAgICAgcmV3YXJkOiAxNSxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgdGFyZ2V0OiAzLFxuICAgICAgaXNDb21wbGV0ZWQ6IGZhbHNlLFxuICAgICAgZXhwaXJlc0F0XG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJ3BlcmZlY3Qtc2NvcmUnLFxuICAgICAgdGl0bGU6ICdQZXJmZWN0IFNjb3JlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ29tcGxldGUgYSBsZXZlbCB3aXRoIGEgcGVyZmVjdCBzY29yZScsXG4gICAgICByZXdhcmQ6IDIwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICB0YXJnZXQ6IDEsXG4gICAgICBpc0NvbXBsZXRlZDogZmFsc2UsXG4gICAgICBleHBpcmVzQXRcbiAgICB9XG4gIF07XG59O1xuXG4vLyBEZWZhdWx0IGluaXRpYWwgZGF0YVxuY29uc3QgZ2V0SW5pdGlhbERhdGEgPSAodXNlcjogYW55KTogR2FtZVByb2dyZXNzRGF0YSA9PiB7XG4gIHJldHVybiB7XG4gICAgcHJvZmlsZToge1xuICAgICAgZGlzcGxheU5hbWU6IHVzZXI/LmRpc3BsYXlOYW1lIHx8IG51bGwsXG4gICAgICBlbWFpbDogdXNlcj8uZW1haWwgfHwgbnVsbCxcbiAgICAgIHBob3RvVVJMOiB1c2VyPy5waG90b1VSTCB8fCBudWxsLFxuICAgICAgam9pbkRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGxhc3RBY3RpdmVEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBncmFkZUxldmVsOiBudWxsLFxuICAgICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgZW1haWxOb3RpZmljYXRpb25zOiBmYWxzZSxcbiAgICAgICAgZGFpbHlSZW1pbmRlcjogdHJ1ZSxcbiAgICAgIH1cbiAgICB9LFxuICAgIHNjb3JlOiAwLFxuICAgIHN0cmVhazogMCxcbiAgICBsYXN0U3RyZWFrRGF0ZTogJycsXG4gICAgc3RyZWFrU3RhdGU6ICdub25lJyxcbiAgICB0b3RhbENoYWxsZW5nZXNDb21wbGV0ZWQ6IDAsXG4gICAgcHJvZ3Jlc3M6IHtcbiAgICAgICdtYWtlLXNlbnRlbmNlJzoge1xuICAgICAgICBjdXJyZW50TGV2ZWw6IDAsXG4gICAgICAgIGN1cnJlbnRTZWN0aW9uOiAwLFxuICAgICAgICBzZWN0aW9uczogZ2VuZXJhdGVTZWN0aW9ucygpLFxuICAgICAgICB4cDogMCxcbiAgICAgICAgcXVlc3RzOiBnZW5lcmF0ZURhaWx5UXVlc3RzKCksXG4gICAgICAgIGNvbXBsZXRlZExldmVsczogW10sXG4gICAgICB9LFxuICAgICAgJ211bHRpcGxlLWNob2ljZSc6IHtcbiAgICAgICAgY3VycmVudExldmVsOiAwLFxuICAgICAgICBjdXJyZW50U2VjdGlvbjogMCxcbiAgICAgICAgc2VjdGlvbnM6IGdlbmVyYXRlU2VjdGlvbnMoKSxcbiAgICAgICAgeHA6IDAsXG4gICAgICAgIHF1ZXN0czogZ2VuZXJhdGVEYWlseVF1ZXN0cygpLFxuICAgICAgICBjb21wbGV0ZWRMZXZlbHM6IFtdLFxuICAgICAgfVxuICAgIH0sXG4gICAgYWNoaWV2ZW1lbnRzOiBbXSxcbiAgICBnYW1lQWNoaWV2ZW1lbnRzOiB7fSxcbiAgICByZWNlbnRDaGFsbGVuZ2VzOiBbXSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZUdhbWVQcm9ncmVzcyA9ICgpID0+IHtcbiAgY29uc3QgeyB1c2VyIH0gPSB1c2VBdXRoKCk7XG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IHVzZVN0YXRlPEdhbWVQcm9ncmVzc0RhdGEgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIFxuICAvLyBSZWFsLXRpbWUgbGlzdGVuZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXVzZXI/LnVpZCkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdbR2FtZVByb2dyZXNzXSBTZXR0aW5nIHVwIHJlYWwtdGltZSBsaXN0ZW5lciBmb3IgdXNlcjonLCB1c2VyLnVpZCk7XG4gICAgXG4gICAgY29uc3QgdXNlckRvY1JlZiA9IGRvYyhkYiwgJ2dhbWVQcm9ncmVzcycsIHVzZXIudWlkKTtcbiAgICBcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IG9uU25hcHNob3QoXG4gICAgICB1c2VyRG9jUmVmLFxuICAgICAgYXN5bmMgKGRvYykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChkb2MuZXhpc3RzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY0RhdGEgPSBkb2MuZGF0YSgpIGFzIEdhbWVQcm9ncmVzc0RhdGE7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0dhbWVQcm9ncmVzc10gUmVhbC10aW1lIGRhdGEgcmVjZWl2ZWQ6JywgZG9jRGF0YSk7XG5cbiAgICAgICAgICAgIC8vIE1pZ3JhdGlvbjogZW5zdXJlIDMgTGV2ZWxzIHdpdGggMTAgY2hhbGxlbmdlcyBlYWNoIGZvciBib3RoIGdhbWVzXG4gICAgICAgICAgICBjb25zdCBuZWVkc01pZ3JhdGlvbiA9IChwcm9ncmVzczogYW55KTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICAgIGlmICghcHJvZ3Jlc3MgfHwgIXByb2dyZXNzLnNlY3Rpb25zKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKHByb2dyZXNzLnNlY3Rpb25zLmxlbmd0aCAhPT0gMykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBwcm9ncmVzcy5zZWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghcy5sZXZlbHMgfHwgcy5sZXZlbHMubGVuZ3RoICE9PSAxMCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFByb2dyZXNzOiBhbnkgPSB7IC4uLmRvY0RhdGEucHJvZ3Jlc3MgfTtcbiAgICAgICAgICAgIGxldCBkaWRNaWdyYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2FtZVR5cGUgb2YgWydtYWtlLXNlbnRlbmNlJywgJ211bHRpcGxlLWNob2ljZSddKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGdwID0gZG9jRGF0YS5wcm9ncmVzcz8uW2dhbWVUeXBlXTtcbiAgICAgICAgICAgICAgaWYgKCFncCB8fCBuZWVkc01pZ3JhdGlvbihncCkpIHtcbiAgICAgICAgICAgICAgICBkaWRNaWdyYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9ucyA9IGdlbmVyYXRlU2VjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAvLyBVbmxvY2sgZmlyc3QgbGV2ZWwgYW5kIGZpcnN0IGNoYWxsZW5nZVxuICAgICAgICAgICAgICAgIGlmIChzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBzZWN0aW9uc1swXS5pc0xvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgaWYgKHNlY3Rpb25zWzBdLmxldmVscy5sZW5ndGggPiAwKSBzZWN0aW9uc1swXS5sZXZlbHNbMF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlZFByb2dyZXNzW2dhbWVUeXBlXSA9IHtcbiAgICAgICAgICAgICAgICAgIHNlY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgeHA6IGdwPy54cCB8fCAwLFxuICAgICAgICAgICAgICAgICAgcXVlc3RzOiBncD8ucXVlc3RzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFNlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWw6IDAsXG4gICAgICAgICAgICAgICAgICBjb21wbGV0ZWRMZXZlbHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlkTWlncmF0ZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0dhbWVQcm9ncmVzc10gTWlncmF0aW5nIHByb2dyZXNzIHRvIDMgbGV2ZWxzIMOXIDEwIGNoYWxsZW5nZXMgc3RydWN0dXJlJyk7XG4gICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZURvYyh1c2VyRG9jUmVmLCB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IHVwZGF0ZWRQcm9ncmVzcyxcbiAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc2V0RGF0YSh7IC4uLmRvY0RhdGEsIHByb2dyZXNzOiB1cGRhdGVkUHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXREYXRhKGRvY0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgaW5pdGlhbCBkYXRhIGlmIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbR2FtZVByb2dyZXNzXSBObyBkb2N1bWVudCBmb3VuZCwgY3JlYXRpbmcgaW5pdGlhbCBkYXRhJyk7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsRGF0YSA9IGdldEluaXRpYWxEYXRhKHVzZXIpO1xuICAgICAgICAgICAgYXdhaXQgc2V0RG9jKHVzZXJEb2NSZWYsIGluaXRpYWxEYXRhKTtcbiAgICAgICAgICAgIHNldERhdGEoaW5pdGlhbERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW0dhbWVQcm9ncmVzc10gRXJyb3IgcHJvY2Vzc2luZyByZWFsLXRpbWUgZGF0YTonLCBlcnIpO1xuICAgICAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpO1xuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbR2FtZVByb2dyZXNzXSBSZWFsLXRpbWUgbGlzdGVuZXIgZXJyb3I6JywgZXJyKTtcbiAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICApO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnW0dhbWVQcm9ncmVzc10gQ2xlYW5pbmcgdXAgcmVhbC10aW1lIGxpc3RlbmVyJyk7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFt1c2VyPy51aWRdKTtcbiAgXG4gIC8vIEFjdGlvbiBmdW5jdGlvbnNcbiAgY29uc3QgdXBkYXRlRGF0YSA9IGFzeW5jICh1cGRhdGVzOiBQYXJ0aWFsPEdhbWVQcm9ncmVzc0RhdGE+KSA9PiB7XG4gICAgaWYgKCF1c2VyPy51aWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlckRvY1JlZiA9IGRvYyhkYiwgJ2dhbWVQcm9ncmVzcycsIHVzZXIudWlkKTtcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyh1c2VyRG9jUmVmLCB7XG4gICAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tHYW1lUHJvZ3Jlc3NdIEVycm9yIHVwZGF0aW5nIGRhdGE6JywgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBhZGRQb2ludHMgPSBhc3luYyAocG9pbnRzOiBudW1iZXIsIGdhbWVUeXBlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXI/LnVpZCB8fCAhZGF0YSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGdhbWVQcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3NbZ2FtZVR5cGVdO1xuICAgIGlmICghZ2FtZVByb2dyZXNzKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgbmV3WFAgPSBNYXRoLm1heCgwLCBnYW1lUHJvZ3Jlc3MueHAgKyBwb2ludHMpO1xuICAgIFxuICAgIGF3YWl0IHVwZGF0ZURhdGEoe1xuICAgICAgc2NvcmU6IGRhdGEuc2NvcmUgKyBwb2ludHMsXG4gICAgICBwcm9ncmVzczoge1xuICAgICAgICAuLi5kYXRhLnByb2dyZXNzLFxuICAgICAgICBbZ2FtZVR5cGVdOiB7XG4gICAgICAgICAgLi4uZ2FtZVByb2dyZXNzLFxuICAgICAgICAgIHhwOiBuZXdYUFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIFxuICBjb25zdCBpbmNyZWFzZVN0cmVhayA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXVzZXI/LnVpZCB8fCAhZGF0YSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHRvZGF5ID0gZ2V0VG9kYXlEYXRlU3RyaW5nKCk7XG4gICAgbGV0IG5ld1N0cmVhayA9IGRhdGEuc3RyZWFrO1xuICAgIFxuICAgIC8vIERvbid0IGluY3JlYXNlIGlmIGFscmVhZHkgcGxheWVkIHRvZGF5XG4gICAgaWYgKGlzU2FtZURheShkYXRhLmxhc3RTdHJlYWtEYXRlLCB0b2RheSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gSW5jcmVhc2Ugc3RyZWFrIGlmIGNvbnNlY3V0aXZlIGRheSBvciBzdGFydGluZyBuZXdcbiAgICBpZiAoaXNDb25zZWN1dGl2ZURheShkYXRhLmxhc3RTdHJlYWtEYXRlLCB0b2RheSkgfHwgIWRhdGEubGFzdFN0cmVha0RhdGUpIHtcbiAgICAgIG5ld1N0cmVhayArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHJlYWsgPSAxOyAvLyBSZXNldCB0byAxIGlmIG1pc3NlZCBkYXlzXG4gICAgfVxuICAgIFxuICAgIGF3YWl0IHVwZGF0ZURhdGEoe1xuICAgICAgc3RyZWFrOiBuZXdTdHJlYWssXG4gICAgICBsYXN0U3RyZWFrRGF0ZTogdG9kYXksXG4gICAgICBzdHJlYWtTdGF0ZTogJ2FjdGl2ZSdcbiAgICB9KTtcbiAgfTtcbiAgXG4gIGNvbnN0IGNvbXBsZXRlTGV2ZWwgPSBhc3luYyAoZ2FtZVR5cGU6IHN0cmluZywgc2VjdGlvbklkOiBudW1iZXIsIGxldmVsSWQ6IG51bWJlciwgc2NvcmU/OiBudW1iZXIpID0+IHtcbiAgICBpZiAoIXVzZXI/LnVpZCB8fCAhZGF0YSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGdhbWVQcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3NbZ2FtZVR5cGVdO1xuICAgIGlmICghZ2FtZVByb2dyZXNzKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdXBkYXRlZFNlY3Rpb25zID0gWy4uLmdhbWVQcm9ncmVzcy5zZWN0aW9uc107XG4gICAgY29uc3Qgc2VjdGlvbiA9IHVwZGF0ZWRTZWN0aW9uc1tzZWN0aW9uSWRdO1xuICAgIGlmICghc2VjdGlvbiB8fCAhc2VjdGlvbi5sZXZlbHNbbGV2ZWxJZF0pIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBsZXZlbCA9IHNlY3Rpb24ubGV2ZWxzW2xldmVsSWRdO1xuICAgIGxldmVsLmF0dGVtcHRzID0gKGxldmVsLmF0dGVtcHRzIHx8IDApICsgMTtcbiAgICBsZXZlbC5sYXN0UGxheWVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIFxuICAgIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkICYmIChsZXZlbC5iZXN0U2NvcmUgPT09IHVuZGVmaW5lZCB8fCBzY29yZSA+IGxldmVsLmJlc3RTY29yZSkpIHtcbiAgICAgIGxldmVsLmJlc3RTY29yZSA9IHNjb3JlO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYXJrIGFzIGNvbXBsZXRlZCBpZiBzY29yZSA+PSA4MCVcbiAgICBjb25zdCBpc0xldmVsQ29tcGxldGVkID0gc2NvcmUgIT09IHVuZGVmaW5lZCAmJiBzY29yZSA+PSA4MDtcbiAgICBsZXQgbmV4dFNlY3Rpb25JZCA9IHNlY3Rpb25JZDtcbiAgICBsZXQgbmV4dExldmVsSWQgPSBsZXZlbElkO1xuICAgIFxuICAgIGlmIChpc0xldmVsQ29tcGxldGVkKSB7XG4gICAgICBsZXZlbC5pc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICBcbiAgICAgIC8vIFVubG9jayBuZXh0IGxldmVsXG4gICAgICBpZiAobGV2ZWxJZCA8IHNlY3Rpb24ubGV2ZWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbmV4dExldmVsSWQgPSBsZXZlbElkICsgMTtcbiAgICAgICAgc2VjdGlvbi5sZXZlbHNbbmV4dExldmVsSWRdLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb21wbGV0ZWQgc2VjdGlvbiwgdW5sb2NrIG5leHQgc2VjdGlvblxuICAgICAgICBzZWN0aW9uLmlzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNlY3Rpb25JZCA8IHVwZGF0ZWRTZWN0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgbmV4dFNlY3Rpb25JZCA9IHNlY3Rpb25JZCArIDE7XG4gICAgICAgICAgbmV4dExldmVsSWQgPSAwO1xuICAgICAgICAgIHVwZGF0ZWRTZWN0aW9uc1tuZXh0U2VjdGlvbklkXS5pc0xvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIHVwZGF0ZWRTZWN0aW9uc1tuZXh0U2VjdGlvbklkXS5sZXZlbHNbMF0uaXNMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByZXBhcmUgYWNoaWV2ZW1lbnRzIHVwZGF0ZXMgKHNpbXBsZSBNVlApXG4gICAgY29uc3QgdXBkYXRlZEdhbWVBY2hpZXZlbWVudHMgPSB7IC4uLihkYXRhLmdhbWVBY2hpZXZlbWVudHMgfHwge30pIH0gYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nW10+O1xuICAgIGNvbnN0IGdhbWVUeXBlQWNoaWV2ZW1lbnRzID0gbmV3IFNldDxzdHJpbmc+KHVwZGF0ZWRHYW1lQWNoaWV2ZW1lbnRzW2dhbWVUeXBlXSB8fCBbXSk7XG4gICAgY29uc3QgdXBkYXRlZEFjaGlldmVtZW50cyA9IG5ldyBTZXQ8c3RyaW5nPihkYXRhLmFjaGlldmVtZW50cyB8fCBbXSk7XG5cbiAgICAvLyBGaXJzdCBTdGVwczogY29tcGxldGluZyBhIGZpcnN0IGdhbWVcbiAgICBpZiAoIWdhbWVUeXBlQWNoaWV2ZW1lbnRzLmhhcygnZmlyc3Qtc3RlcHMnKSkge1xuICAgICAgZ2FtZVR5cGVBY2hpZXZlbWVudHMuYWRkKCdmaXJzdC1zdGVwcycpO1xuICAgICAgdXBkYXRlZEFjaGlldmVtZW50cy5hZGQoJ2ZpcnN0LXN0ZXBzJyk7XG4gICAgfVxuICAgIC8vIFBlcmZlY3QgU2NvcmU6IHNjb3JlIDEwMFxuICAgIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkICYmIHNjb3JlID49IDEwMCAmJiAhZ2FtZVR5cGVBY2hpZXZlbWVudHMuaGFzKCdwZXJmZWN0LXNjb3JlJykpIHtcbiAgICAgIGdhbWVUeXBlQWNoaWV2ZW1lbnRzLmFkZCgncGVyZmVjdC1zY29yZScpO1xuICAgICAgdXBkYXRlZEFjaGlldmVtZW50cy5hZGQoJ3BlcmZlY3Qtc2NvcmUnKTtcbiAgICB9XG4gICAgLy8gU2VjdGlvbiBDaGFtcGlvbjogZW50aXJlIHNlY3Rpb24gY29tcGxldGVkXG4gICAgY29uc3Qgc2VjdGlvbkNvbXBsZXRlZCA9IHNlY3Rpb24ubGV2ZWxzLmV2ZXJ5KGwgPT4gbC5pc0NvbXBsZXRlZCk7XG4gICAgaWYgKHNlY3Rpb25Db21wbGV0ZWQgJiYgIWdhbWVUeXBlQWNoaWV2ZW1lbnRzLmhhcygnc2VjdGlvbi1jaGFtcGlvbicpKSB7XG4gICAgICBnYW1lVHlwZUFjaGlldmVtZW50cy5hZGQoJ3NlY3Rpb24tY2hhbXBpb24nKTtcbiAgICAgIHVwZGF0ZWRBY2hpZXZlbWVudHMuYWRkKCdzZWN0aW9uLWNoYW1waW9uJyk7XG4gICAgfVxuICAgIHVwZGF0ZWRHYW1lQWNoaWV2ZW1lbnRzW2dhbWVUeXBlXSA9IEFycmF5LmZyb20oZ2FtZVR5cGVBY2hpZXZlbWVudHMpO1xuICAgIFxuICAgIGF3YWl0IHVwZGF0ZURhdGEoe1xuICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgLi4uZGF0YS5wcm9ncmVzcyxcbiAgICAgICAgW2dhbWVUeXBlXToge1xuICAgICAgICAgIC4uLmdhbWVQcm9ncmVzcyxcbiAgICAgICAgICBzZWN0aW9uczogdXBkYXRlZFNlY3Rpb25zLFxuICAgICAgICAgIGN1cnJlbnRTZWN0aW9uOiBuZXh0U2VjdGlvbklkLFxuICAgICAgICAgIGN1cnJlbnRMZXZlbDogbmV4dExldmVsSWRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFjaGlldmVtZW50czogQXJyYXkuZnJvbSh1cGRhdGVkQWNoaWV2ZW1lbnRzKSxcbiAgICAgIGdhbWVBY2hpZXZlbWVudHM6IHVwZGF0ZWRHYW1lQWNoaWV2ZW1lbnRzXG4gICAgfSk7XG4gIH07XG4gIFxuICBjb25zdCBjYW5BY2Nlc3NMZXZlbCA9IChnYW1lVHlwZTogc3RyaW5nLCBzZWN0aW9uSWQ6IG51bWJlciwgbGV2ZWxJZDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLnByb2dyZXNzW2dhbWVUeXBlXSkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIGNvbnN0IGdhbWVQcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3NbZ2FtZVR5cGVdO1xuICAgIGlmICghZ2FtZVByb2dyZXNzLnNlY3Rpb25zIHx8IHNlY3Rpb25JZCA8IDAgfHwgc2VjdGlvbklkID49IGdhbWVQcm9ncmVzcy5zZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2VjdGlvbiA9IGdhbWVQcm9ncmVzcy5zZWN0aW9uc1tzZWN0aW9uSWRdO1xuICAgIGlmICghc2VjdGlvbiB8fCBzZWN0aW9uLmlzTG9ja2VkKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgaWYgKCFzZWN0aW9uLmxldmVscyB8fCBsZXZlbElkIDwgMCB8fCBsZXZlbElkID49IHNlY3Rpb24ubGV2ZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBsZXZlbCA9IHNlY3Rpb24ubGV2ZWxzW2xldmVsSWRdO1xuICAgIHJldHVybiBsZXZlbCAmJiAhbGV2ZWwuaXNMb2NrZWQ7XG4gIH07XG4gIFxuICByZXR1cm4ge1xuICAgIGRhdGEsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICAvLyBBY3Rpb25zXG4gICAgdXBkYXRlRGF0YSxcbiAgICBhZGRQb2ludHMsXG4gICAgaW5jcmVhc2VTdHJlYWssXG4gICAgY29tcGxldGVMZXZlbCxcbiAgICBjYW5BY2Nlc3NMZXZlbCxcbiAgICAvLyBDb252ZW5pZW5jZSBnZXR0ZXJzXG4gICAgcHJvZmlsZTogZGF0YT8ucHJvZmlsZSB8fCBudWxsLFxuICAgIHNjb3JlOiBkYXRhPy5zY29yZSB8fCAwLFxuICAgIHN0cmVhazogZGF0YT8uc3RyZWFrIHx8IDAsXG4gICAgc3RyZWFrU3RhdGU6IGRhdGE/LnN0cmVha1N0YXRlIHx8ICdub25lJyxcbiAgICBwcm9ncmVzczogZGF0YT8ucHJvZ3Jlc3MgfHwge30sXG4gICAgYWNoaWV2ZW1lbnRzOiBkYXRhPy5hY2hpZXZlbWVudHMgfHwgW10sXG4gICAgZ2FtZUFjaGlldmVtZW50czogZGF0YT8uZ2FtZUFjaGlldmVtZW50cyB8fCB7fSxcbiAgICByZWNlbnRDaGFsbGVuZ2VzOiBkYXRhPy5yZWNlbnRDaGFsbGVuZ2VzIHx8IFtdXG4gIH07XG59OyAiXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJvblNuYXBzaG90IiwiZG9jIiwidXBkYXRlRG9jIiwic2V0RG9jIiwiZGIiLCJ1c2VBdXRoIiwiZ2V0VG9kYXlEYXRlU3RyaW5nIiwidG9kYXkiLCJEYXRlIiwieWVhciIsImdldEZ1bGxZZWFyIiwibW9udGgiLCJTdHJpbmciLCJnZXRNb250aCIsInBhZFN0YXJ0IiwiZGF5IiwiZ2V0RGF0ZSIsImlzU2FtZURheSIsImRhdGVTdHIxIiwiZGF0ZVN0cjIiLCJpc0NvbnNlY3V0aXZlRGF5IiwibGFzdERhdGVTdHIiLCJ0b2RheVN0ciIsImxhc3REYXRlIiwidGltZURpZmYiLCJnZXRUaW1lIiwiZGF5c0RpZmYiLCJNYXRoIiwicm91bmQiLCJnZW5lcmF0ZVNlY3Rpb25zIiwic2VjdGlvbnMiLCJsZXZlbE5hbWVzIiwic2VjdGlvbklkIiwibGV2ZWxzIiwibGV2ZWxJZCIsInB1c2giLCJpZCIsInRpdGxlIiwiaXNMb2NrZWQiLCJpc0NvbXBsZXRlZCIsImJlc3RTY29yZSIsImF0dGVtcHRzIiwibGFzdFBsYXllZCIsInRyaW0iLCJkZXNjcmlwdGlvbiIsImdlbmVyYXRlRGFpbHlRdWVzdHMiLCJleHBpcmVzQXQiLCJyZXdhcmQiLCJwcm9ncmVzcyIsInRhcmdldCIsImdldEluaXRpYWxEYXRhIiwidXNlciIsInByb2ZpbGUiLCJkaXNwbGF5TmFtZSIsImVtYWlsIiwicGhvdG9VUkwiLCJqb2luRGF0ZSIsInRvSVNPU3RyaW5nIiwibGFzdEFjdGl2ZURhdGUiLCJncmFkZUxldmVsIiwicHJlZmVyZW5jZXMiLCJlbWFpbE5vdGlmaWNhdGlvbnMiLCJkYWlseVJlbWluZGVyIiwic2NvcmUiLCJzdHJlYWsiLCJsYXN0U3RyZWFrRGF0ZSIsInN0cmVha1N0YXRlIiwidG90YWxDaGFsbGVuZ2VzQ29tcGxldGVkIiwiY3VycmVudExldmVsIiwiY3VycmVudFNlY3Rpb24iLCJ4cCIsInF1ZXN0cyIsImNvbXBsZXRlZExldmVscyIsImFjaGlldmVtZW50cyIsImdhbWVBY2hpZXZlbWVudHMiLCJyZWNlbnRDaGFsbGVuZ2VzIiwidXBkYXRlZEF0IiwidXNlR2FtZVByb2dyZXNzIiwiZGF0YSIsInNldERhdGEiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJ1aWQiLCJjb25zb2xlIiwibG9nIiwidXNlckRvY1JlZiIsInVuc3Vic2NyaWJlIiwiZXhpc3RzIiwiZG9jRGF0YSIsIm5lZWRzTWlncmF0aW9uIiwibGVuZ3RoIiwicyIsInVwZGF0ZWRQcm9ncmVzcyIsImRpZE1pZ3JhdGUiLCJnYW1lVHlwZSIsImdwIiwiaW5pdGlhbERhdGEiLCJlcnIiLCJFcnJvciIsIm1lc3NhZ2UiLCJ1cGRhdGVEYXRhIiwidXBkYXRlcyIsImFkZFBvaW50cyIsInBvaW50cyIsImdhbWVQcm9ncmVzcyIsIm5ld1hQIiwibWF4IiwiaW5jcmVhc2VTdHJlYWsiLCJuZXdTdHJlYWsiLCJjb21wbGV0ZUxldmVsIiwidXBkYXRlZFNlY3Rpb25zIiwic2VjdGlvbiIsImxldmVsIiwidW5kZWZpbmVkIiwiaXNMZXZlbENvbXBsZXRlZCIsIm5leHRTZWN0aW9uSWQiLCJuZXh0TGV2ZWxJZCIsInVwZGF0ZWRHYW1lQWNoaWV2ZW1lbnRzIiwiZ2FtZVR5cGVBY2hpZXZlbWVudHMiLCJTZXQiLCJ1cGRhdGVkQWNoaWV2ZW1lbnRzIiwiaGFzIiwiYWRkIiwic2VjdGlvbkNvbXBsZXRlZCIsImV2ZXJ5IiwibCIsIkFycmF5IiwiZnJvbSIsImNhbkFjY2Vzc0xldmVsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useGameProgress.ts\n"));

/***/ })

});